WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:24.516 --> 00:00:31.906 A:middle
[ Applause ]

00:00:32.406 --> 00:00:32.846 A:middle
&gt;&gt; WOODY LIDSTONE: Hi, everyone.

00:00:34.116 --> 00:00:36.746 A:middle
I made a comment to Stefan
earlier today, saying,

00:00:36.746 --> 00:00:37.956 A:middle
I hope some people
come out to this.

00:00:38.886 --> 00:00:39.866 A:middle
And it's incredible.

00:00:39.866 --> 00:00:40.816 A:middle
You are just packing the place.

00:00:41.016 --> 00:00:42.026 A:middle
So, thank you for coming out.

00:00:42.026 --> 00:00:44.346 A:middle
My name is Woody, and I
would like to introduce you

00:00:44.346 --> 00:00:46.406 A:middle
to Improving Your
Existing Apps with Swift.

00:00:46.986 --> 00:00:48.696 A:middle
Can I get a show of hands,

00:00:48.696 --> 00:00:49.996 A:middle
how many of you are
actually using Swift

00:00:49.996 --> 00:00:53.296 A:middle
in your code right now?

00:00:53.526 --> 00:00:54.366 A:middle
Okay. Excellent.

00:00:54.476 --> 00:00:55.746 A:middle
Then you are all at
the right session,

00:00:56.426 --> 00:00:57.606 A:middle
whether you've done it or not.

00:00:57.786 --> 00:00:59.876 A:middle
Hopefully by the end of it
you will all be using Swift

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:00.246 --> 00:01:01.946 A:middle
with your existing
Objective-C projects.

00:01:01.946 --> 00:01:07.066 A:middle
You know, last year I was also
in this room, I was sitting

00:01:07.066 --> 00:01:11.316 A:middle
in the back corner as an
attendee, using my laptop,

00:01:11.316 --> 00:01:14.776 A:middle
trying to figure out how to
use some of the technologies

00:01:14.776 --> 00:01:16.616 A:middle
that I learned about
in an earlier session,

00:01:16.966 --> 00:01:19.396 A:middle
replying to work email even
though I told them I wouldn't,

00:01:20.006 --> 00:01:23.126 A:middle
and half paying attention to
the presenter that was up here,

00:01:23.176 --> 00:01:25.266 A:middle
as I am sure many
of us are right now.

00:01:25.866 --> 00:01:29.196 A:middle
Well, since then,
I've switched sides

00:01:29.406 --> 00:01:31.486 A:middle
from the attendee to the stage.

00:01:31.786 --> 00:01:34.506 A:middle
I have moved sides of the
continent from Halifax,

00:01:34.536 --> 00:01:38.836 A:middle
Nova Scotia, to California,
and I am out today

00:01:38.836 --> 00:01:41.486 A:middle
to help you learn some
techniques to work

00:01:41.486 --> 00:01:42.986 A:middle
with Swift and Objective-C.

00:01:44.056 --> 00:01:47.856 A:middle
I don't have to go
over and move it.

00:01:47.856 --> 00:01:51.216 A:middle
I've got a remote control now.

00:01:51.656 --> 00:01:57.626 A:middle
So what I want to do is
take you through some

00:01:57.626 --> 00:02:00.966 A:middle
of the techniques you can use to
add Swift to an existing project

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:57.626 --> 00:02:00.966 A:middle
of the techniques you can use to
add Swift to an existing project

00:02:00.966 --> 00:02:02.076 A:middle
to make that project better.

00:02:02.456 --> 00:02:04.706 A:middle
And I thought the approach
I would use would be

00:02:04.706 --> 00:02:06.216 A:middle
to do exactly that
in this session.

00:02:06.806 --> 00:02:10.116 A:middle
So I went to Infinite Loop, I
went down to the parking garage,

00:02:10.116 --> 00:02:12.796 A:middle
and down to a floor below that
where we have our catacombs,

00:02:13.216 --> 00:02:16.006 A:middle
and I went past the three-headed
dog that guards the entrance

00:02:16.066 --> 00:02:17.876 A:middle
to industrial design, to the end

00:02:17.876 --> 00:02:19.026 A:middle
where we keep our
software vault.

00:02:19.196 --> 00:02:21.176 A:middle
And I opened the
software vault and I took

00:02:21.176 --> 00:02:24.876 A:middle
out an app called The Elements
that we haven't seen at WWDC

00:02:24.876 --> 00:02:26.276 A:middle
for maybe two or three years.

00:02:26.666 --> 00:02:28.726 A:middle
I'd like to show you
how it is right now.

00:02:30.666 --> 00:02:32.366 A:middle
Alright, this is The Elements.

00:02:32.366 --> 00:02:34.276 A:middle
Do you remember seeing
this before?

00:02:34.536 --> 00:02:36.286 A:middle
Yeah? Some of you do,
some of you don't.

00:02:36.506 --> 00:02:37.536 A:middle
Somebody really like it.

00:02:37.536 --> 00:02:38.176 A:middle
I like it too.

00:02:38.556 --> 00:02:42.846 A:middle
So it's a standard
UIKit-based table view app.

00:02:42.846 --> 00:02:45.326 A:middle
We have got a bunch
of cells for each

00:02:45.616 --> 00:02:47.486 A:middle
of the elements in
the atomic table.

00:02:47.486 --> 00:02:49.176 A:middle
We have this small,
little detail view

00:02:49.176 --> 00:02:50.526 A:middle
with a little bit
of information.

00:02:50.526 --> 00:02:53.056 A:middle
And if you tap on
one of the cells,

00:02:53.056 --> 00:02:57.666 A:middle
we have this navigation
controllers push presentation

00:02:58.766 --> 00:03:04.286 A:middle
to show some details about that.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.766 --> 00:03:04.286 A:middle
to show some details about that.

00:03:05.236 --> 00:03:09.906 A:middle
Great. I figure it's something

00:03:09.906 --> 00:03:11.666 A:middle
that probably a lot
of you have to do.

00:03:11.666 --> 00:03:13.636 A:middle
You move around between
different applications,

00:03:13.886 --> 00:03:15.276 A:middle
and you come back and
you revisit an app

00:03:15.276 --> 00:03:17.306 A:middle
that you haven't used in a
while or you haven't programmed

00:03:17.306 --> 00:03:19.276 A:middle
in a while and you are asked
to add new features to it

00:03:19.276 --> 00:03:21.316 A:middle
or support a new
operating system, a new SDK.

00:03:22.006 --> 00:03:23.666 A:middle
So that's exactly what
we are going to do.

00:03:23.666 --> 00:03:25.396 A:middle
We are going to modernize
this Objective-C app

00:03:25.396 --> 00:03:27.526 A:middle
and we're going to
do it using Swift.

00:03:28.136 --> 00:03:31.836 A:middle
The pitch to you is this: if
you have an existing application

00:03:31.836 --> 00:03:33.866 A:middle
and you have got to
write new code for it

00:03:33.866 --> 00:03:36.456 A:middle
and that existing application
is an Objective-C app,

00:03:36.786 --> 00:03:39.466 A:middle
consider taking advantage of
Swift's features by writing

00:03:39.466 --> 00:03:42.346 A:middle
that new code in Swift,
while, at the same time,

00:03:43.216 --> 00:03:46.376 A:middle
leave your original
Objective-C code in Objective-C.

00:03:46.606 --> 00:03:47.466 A:middle
That's perfectly fine too.

00:03:48.426 --> 00:03:53.286 A:middle
In this session, we are going
to start by doing a makeover

00:03:53.286 --> 00:03:55.426 A:middle
on the application to
bring its user interface

00:03:55.556 --> 00:03:57.096 A:middle
to a more contemporary
appearance.

00:03:57.406 --> 00:03:59.186 A:middle
We are going to do
that using Swift.

00:03:59.396 --> 00:04:01.776 A:middle
Then we are also going to
take a look at, for example,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.396 --> 00:04:01.776 A:middle
Then we are also going to
take a look at, for example,

00:04:01.776 --> 00:04:05.346 A:middle
Swift's structs and its
functions like mapping

00:04:05.346 --> 00:04:06.696 A:middle
and reducing to find ways

00:04:06.696 --> 00:04:08.326 A:middle
that we can add new
features to the application.

00:04:08.846 --> 00:04:15.506 A:middle
This application has small
tiles and large tiles.

00:04:15.866 --> 00:04:17.305 A:middle
The small tile is
the table view,

00:04:17.305 --> 00:04:18.636 A:middle
the large tile is
the detail view.

00:04:19.586 --> 00:04:21.836 A:middle
And the tiles consist
of a background,

00:04:22.116 --> 00:04:24.516 A:middle
plus the text that's rendered
on top of that background.

00:04:25.556 --> 00:04:27.316 A:middle
Because this app
is an older app,

00:04:27.646 --> 00:04:30.386 A:middle
the backgrounds were originally
rendered in Photoshop,

00:04:30.386 --> 00:04:32.316 A:middle
and then they are just
embedded inside the application.

00:04:33.126 --> 00:04:35.276 A:middle
But these backgrounds
which exist

00:04:35.276 --> 00:04:38.276 A:middle
in different colors depending
on the atomic states, solid,

00:04:38.276 --> 00:04:41.316 A:middle
liquid, synthetics,
gaseous, are only rendered

00:04:41.316 --> 00:04:43.456 A:middle
for the original iPhone.

00:04:43.456 --> 00:04:45.286 A:middle
There is no Retina
artwork included.

00:04:45.656 --> 00:04:47.896 A:middle
Which means when we take
this older app and we run it

00:04:47.896 --> 00:04:52.376 A:middle
on newer hardware, we have to
scale up, and when we scale

00:04:52.376 --> 00:04:54.616 A:middle
up this older, this
older artwork,

00:04:54.616 --> 00:04:57.306 A:middle
we end up getting these
artifacts, called aliasing,

00:04:57.536 --> 00:04:59.876 A:middle
on the rounded corners because
we don't have enough pixel data

00:04:59.876 --> 00:05:01.286 A:middle
to represent those
corners smoothly.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.876 --> 00:05:01.286 A:middle
to represent those
corners smoothly.

00:05:01.286 --> 00:05:03.216 A:middle
So that's something that we
definitely are going to fix

00:05:03.216 --> 00:05:04.606 A:middle
up in this presentation.

00:05:05.116 --> 00:05:09.016 A:middle
The other thing is,
do you ever look

00:05:10.016 --> 00:05:11.576 A:middle
at your middle school yearbook,

00:05:12.046 --> 00:05:15.176 A:middle
maybe in the '80s
or '90s [applause]?

00:05:15.176 --> 00:05:15.746 A:middle
Yeah, right?

00:05:15.746 --> 00:05:16.896 A:middle
You see a picture of yourself,

00:05:17.456 --> 00:05:19.216 A:middle
and you are there
wearing a vest with, like,

00:05:19.216 --> 00:05:22.166 A:middle
this embroidered kitten on it,
and you are holding a keyboard

00:05:22.166 --> 00:05:23.506 A:middle
because it was cool at the time,

00:05:24.136 --> 00:05:25.756 A:middle
and you've got this
laser background

00:05:25.756 --> 00:05:26.766 A:middle
because that was also cool.

00:05:26.766 --> 00:05:27.616 A:middle
And now you are looking at it

00:05:27.616 --> 00:05:29.976 A:middle
and you are just thinking,
what was I thinking?

00:05:30.516 --> 00:05:34.546 A:middle
[ Laughter ]

00:05:35.046 --> 00:05:36.656 A:middle
Sometimes we look back
at our apps and we think,

00:05:37.006 --> 00:05:37.926 A:middle
what were we thinking?

00:05:38.446 --> 00:05:40.486 A:middle
With the shine and the
gloss and the reflection.

00:05:41.246 --> 00:05:43.246 A:middle
So we are going to fix that.

00:05:43.436 --> 00:05:44.196 A:middle
Fashions change.

00:05:44.196 --> 00:05:44.996 A:middle
Styles change.

00:05:45.276 --> 00:05:46.496 A:middle
And one of the ways
that we can do

00:05:46.496 --> 00:05:49.246 A:middle
that with this app is
simply removing the gloss

00:05:49.816 --> 00:05:50.626 A:middle
on the background.

00:05:50.966 --> 00:05:54.896 A:middle
We get a very contemporary,
rendered rectangle outline.

00:05:55.556 --> 00:05:57.926 A:middle
It looks good in the
small tile as well

00:05:57.926 --> 00:05:59.166 A:middle
as in the large tile
for this app.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:00.186 --> 00:06:02.086 A:middle
Now, we could rerender the
new backgrounds in Photoshop,

00:06:02.086 --> 00:06:03.366 A:middle
and embed them inside
the application,

00:06:03.816 --> 00:06:05.376 A:middle
but clearly this is
an app that we don't,

00:06:06.166 --> 00:06:07.396 A:middle
we don't get into very often.

00:06:07.396 --> 00:06:13.156 A:middle
You know, it might not be until
WWDC 2020 before we come back

00:06:13.156 --> 00:06:14.396 A:middle
to The Elements, and
I'd like to make sure

00:06:14.396 --> 00:06:16.786 A:middle
that it looks good not
just on past hardware

00:06:16.786 --> 00:06:19.516 A:middle
and current hardware, but also
on potential future hardware.

00:06:19.516 --> 00:06:23.916 A:middle
So I am going to choose to put
in some custom drawing code just

00:06:23.916 --> 00:06:25.596 A:middle
to draw the rounded
rectangle background

00:06:25.596 --> 00:06:26.636 A:middle
because it's just a
rounded rectangle.

00:06:26.686 --> 00:06:29.136 A:middle
I am going to do that
in Swift, but I am going

00:06:29.136 --> 00:06:30.286 A:middle
to call it from Objective-C.

00:06:30.286 --> 00:06:35.806 A:middle
To do that, the technique I
am going to use is called Mix

00:06:35.806 --> 00:06:38.626 A:middle
and Match, and we have
numerous sessions both last year

00:06:38.626 --> 00:06:40.746 A:middle
and this year on
interoperability between Swift

00:06:40.746 --> 00:06:43.056 A:middle
and Objective-C, the mechanics

00:06:43.056 --> 00:06:44.856 A:middle
of which can be covered
better in those sessions.

00:06:45.206 --> 00:06:46.926 A:middle
What I would like to do at
this point is just give you an

00:06:46.926 --> 00:06:48.746 A:middle
overview of how the
technology works

00:06:49.066 --> 00:06:53.996 A:middle
and then we'll actually dive
into a demo and you can see it.

00:06:54.246 --> 00:06:56.496 A:middle
Typically when we think
about classes in Objective-C,

00:06:56.496 --> 00:06:58.696 A:middle
we have a header file and
an implementation file,

00:06:58.986 --> 00:07:01.226 A:middle
and those two things together
form our class definition.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:58.986 --> 00:07:01.226 A:middle
and those two things together
form our class definition.

00:07:02.056 --> 00:07:03.386 A:middle
But it's possible
that we can have some

00:07:03.386 --> 00:07:06.006 A:middle
of our methods implemented
in a category,

00:07:06.006 --> 00:07:07.296 A:middle
and that's perfectly fine,

00:07:07.296 --> 00:07:10.596 A:middle
and then our class definition
is our base class plus

00:07:10.906 --> 00:07:12.016 A:middle
our category.

00:07:12.556 --> 00:07:13.146 A:middle
And there's nothing to say

00:07:13.146 --> 00:07:14.836 A:middle
that you can't have
multiple categories.

00:07:14.836 --> 00:07:17.046 A:middle
In fact, this is something
that we do with UI table view.

00:07:17.046 --> 00:07:19.266 A:middle
If you look at this header file
in Objective-C, you will see

00:07:19.266 --> 00:07:21.866 A:middle
that there's many
categories on UI table view.

00:07:22.946 --> 00:07:26.286 A:middle
Now, there's also
nothing to say that one

00:07:26.286 --> 00:07:28.306 A:middle
of those categories couldn't
be implemented in Swift,

00:07:28.976 --> 00:07:30.436 A:middle
in which case the
terminology changes

00:07:30.436 --> 00:07:31.526 A:middle
but the concept is the same.

00:07:31.526 --> 00:07:34.736 A:middle
We just call it a Swift
extension on the Objective-C,

00:07:34.736 --> 00:07:36.186 A:middle
in this case, base class.

00:07:36.186 --> 00:07:37.276 A:middle
And there's also nothing

00:07:37.276 --> 00:07:40.916 A:middle
to say you couldn't have
multiple Objective-C categories

00:07:40.916 --> 00:07:44.086 A:middle
mixed in with multiple Swift
extensions and the content

00:07:44.086 --> 00:07:47.366 A:middle
of all of them forms your class.

00:07:47.916 --> 00:07:50.116 A:middle
This lets us have some
of our functions written

00:07:50.116 --> 00:07:53.066 A:middle
in Objective-C, and it lets you
have newer functions be written

00:07:53.066 --> 00:07:53.476 A:middle
in Swift.

00:07:53.926 --> 00:07:57.756 A:middle
For this interoperability
technique to work, we use a set

00:07:57.756 --> 00:07:59.946 A:middle
of bridging headers -- not
a set of bridging headers --

00:07:59.946 --> 00:08:01.666 A:middle
we use a bridging header
and a generated header.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.946 --> 00:08:01.666 A:middle
we use a bridging header
and a generated header.

00:08:02.266 --> 00:08:06.176 A:middle
Now, the bridging
header is made in Xcode.

00:08:06.176 --> 00:08:07.976 A:middle
The first time that
you introduce Swift

00:08:07.976 --> 00:08:10.166 A:middle
into an existing
Objective-C project.

00:08:10.166 --> 00:08:11.806 A:middle
And then you maintain it.

00:08:11.806 --> 00:08:14.126 A:middle
You just basically go into it,
and put some import statements

00:08:14.126 --> 00:08:16.756 A:middle
so you can selectively
choose which data types

00:08:16.756 --> 00:08:17.446 A:middle
and header files

00:08:17.446 --> 00:08:19.896 A:middle
from Objective-C you are
going to expose to Swift.

00:08:21.136 --> 00:08:22.096 A:middle
Then on the reciprocal,

00:08:22.096 --> 00:08:23.916 A:middle
the Swift compiler
makes a generated header

00:08:24.126 --> 00:08:26.726 A:middle
which you can import into your
Objective-C implementation files

00:08:26.766 --> 00:08:29.776 A:middle
to expose Swift, in
this case, extensions

00:08:30.266 --> 00:08:32.976 A:middle
and other data types,
to Objective-C.

00:08:32.976 --> 00:08:34.606 A:middle
So we have these
two header files.

00:08:34.816 --> 00:08:36.226 A:middle
You are going to see them
in the demonstration,

00:08:37.135 --> 00:08:38.856 A:middle
which is coming up right now.

00:08:50.156 --> 00:08:51.296 A:middle
Okay. So in my project,

00:08:51.296 --> 00:08:53.546 A:middle
I have this class called
atomic element tile view.

00:08:53.546 --> 00:08:56.366 A:middle
That's the one that actually
draws the background.

00:08:56.366 --> 00:08:58.156 A:middle
There is a method in it.

00:08:58.156 --> 00:08:59.936 A:middle
It's actually not just
drawing the background,

00:08:59.936 --> 00:09:01.856 A:middle
it's drawing the background and
all the text that goes on top

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.936 --> 00:09:01.856 A:middle
it's drawing the background and
all the text that goes on top

00:09:01.856 --> 00:09:03.816 A:middle
of it for both the small
tile and the large tile.

00:09:03.816 --> 00:09:06.266 A:middle
So I am going to introduce the
new drawing code, but I am going

00:09:06.266 --> 00:09:08.496 A:middle
to do it in Swift, so I will go
ahead and make a new Swift file.

00:09:09.106 --> 00:09:10.266 A:middle
It's command-N in Xcode.

00:09:10.266 --> 00:09:15.696 A:middle
We will choose a
Swift file, create it,

00:09:16.106 --> 00:09:18.016 A:middle
and because it's the first
time that I've added Swift

00:09:18.016 --> 00:09:19.466 A:middle
to this project,
I have the option

00:09:19.466 --> 00:09:20.596 A:middle
to create the bridging
header now.

00:09:21.276 --> 00:09:24.056 A:middle
I want to create
it, so press Return.

00:09:24.936 --> 00:09:29.786 A:middle
And now I have my two files
that consist of the base class

00:09:29.786 --> 00:09:32.166 A:middle
in Objective-C plus
the Swift file.

00:09:32.936 --> 00:09:34.496 A:middle
I also have the bridging
header down here.

00:09:34.496 --> 00:09:36.546 A:middle
Let's just make this
a little bit wider.

00:09:36.646 --> 00:09:38.746 A:middle
There we go.

00:09:38.966 --> 00:09:41.466 A:middle
You might notice that I chose
to use the exact same file name

00:09:41.746 --> 00:09:44.156 A:middle
for my Swift file as I
did for the Objective-C.

00:09:44.156 --> 00:09:46.076 A:middle
That's not a requirement,
but it's a convenience

00:09:46.556 --> 00:09:49.746 A:middle
because it means that in
Xcode, I can use the shortcut

00:09:49.746 --> 00:09:52.946 A:middle
of control-command-up arrow and
just cycle through the Swift

00:09:52.946 --> 00:09:55.146 A:middle
and the Objective-C
header and implementation,

00:09:55.286 --> 00:09:57.336 A:middle
just quickly move back and
forth between all three.

00:09:57.806 --> 00:10:01.336 A:middle
Now, the bridging
header is where I choose

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:57.806 --> 00:10:01.336 A:middle
Now, the bridging
header is where I choose

00:10:01.336 --> 00:10:04.396 A:middle
to expose data types that
I've declared in Objective-C

00:10:04.436 --> 00:10:06.886 A:middle
to Swift, and I do that by
importing their header files.

00:10:07.586 --> 00:10:11.746 A:middle
Since I want to extend atomic
element tile view into Swift

00:10:11.746 --> 00:10:15.556 A:middle
or using Swift, I have to import
it into the bridging header.

00:10:16.336 --> 00:10:18.566 A:middle
The only one that I really
need at the moment is the one

00:10:18.566 --> 00:10:20.406 A:middle
that I've highlighted,
atomic element tile view,

00:10:20.666 --> 00:10:22.726 A:middle
but later on in the presentation
I will need the other ones,

00:10:22.726 --> 00:10:24.446 A:middle
so I am just going to go ahead
and get them all imported now.

00:10:24.446 --> 00:10:27.766 A:middle
Now we can go over
to the Swift file,

00:10:27.766 --> 00:10:32.796 A:middle
and I will write an extension
on atomic element tile view.

00:10:41.066 --> 00:10:43.716 A:middle
So now the class atomic element
tile view has this new function

00:10:43.716 --> 00:10:45.526 A:middle
called draw raw background.

00:10:45.736 --> 00:10:48.736 A:middle
And you can see I am also
using the new Xcode 7 markup

00:10:48.846 --> 00:10:51.156 A:middle
to give a document comment,
a documentation comment,

00:10:51.156 --> 00:10:53.496 A:middle
in this case, draw an atomic
elements background tile.

00:10:53.496 --> 00:10:55.346 A:middle
I will go ahead and put the code

00:10:55.346 --> 00:10:58.846 A:middle
in that actually
does the drawing.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:02.376 --> 00:11:03.796 A:middle
And that's it for
the Swift part.

00:11:03.796 --> 00:11:07.006 A:middle
But now I want to call this
Swift function from Objective-C

00:11:07.336 --> 00:11:10.496 A:middle
so that instead of having
the pre-rendered images being

00:11:10.496 --> 00:11:12.776 A:middle
loaded, I am going to
draw using this method.

00:11:14.036 --> 00:11:16.016 A:middle
So I'll switch over to
atomic element tile view.m,

00:11:16.016 --> 00:11:19.246 A:middle
and I want to make sure that it
sees the code that I just added

00:11:19.246 --> 00:11:24.916 A:middle
in Swift, so I will go ahead
and import the generated header.

00:11:24.916 --> 00:11:26.966 A:middle
Generated header uses the
same name as the product,

00:11:26.966 --> 00:11:35.136 A:middle
so the elements, then you
append hyphen Swift.h. And now,

00:11:35.256 --> 00:11:37.466 A:middle
in this method, where
I typically loaded the

00:11:37.466 --> 00:11:40.026 A:middle
pre-rendered backgrounds,
I'll comment that out.

00:11:41.226 --> 00:11:45.876 A:middle
And instead call 'self draw,'
and you can see that the method

00:11:45.876 --> 00:11:48.426 A:middle
from Swift is showing
up as a native method

00:11:48.486 --> 00:11:49.646 A:middle
with everything else
that's there.

00:11:49.926 --> 00:11:51.246 A:middle
You can even see the
comment is showing

00:11:51.246 --> 00:11:54.266 A:middle
up 'draw an atomic
elements background tile.'

00:11:54.756 --> 00:11:57.426 A:middle
So I will pass over the element.

00:11:57.426 --> 00:12:04.616 A:middle
Pass it to bounding rectangle

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:57.426 --> 00:12:04.616 A:middle
Pass it to bounding rectangle

00:12:04.616 --> 00:12:06.026 A:middle
in which it will draw
the rounded rectangle.

00:12:06.836 --> 00:12:10.746 A:middle
Run the app.

00:12:14.596 --> 00:12:15.266 A:middle
There we go.

00:12:15.266 --> 00:12:17.246 A:middle
So we are having some rounded
rectangles being drawn using

00:12:17.246 --> 00:12:18.596 A:middle
Swift code with Objective-C
[applause].

00:12:19.436 --> 00:12:19.886 A:middle
Thank you.

00:12:24.706 --> 00:12:28.436 A:middle
It's the benefit of planting
your friends in the audience.

00:12:29.516 --> 00:12:37.596 A:middle
[ Laughter ]

00:12:38.096 --> 00:12:40.456 A:middle
Now for the most part, it
looks kind of like I expected.

00:12:40.456 --> 00:12:41.336 A:middle
It's a rounded rectangle.

00:12:41.336 --> 00:12:43.166 A:middle
But the rounded rectangles
themselves,

00:12:43.166 --> 00:12:44.376 A:middle
they don't look the
way I intended.

00:12:44.896 --> 00:12:48.786 A:middle
In fact, if we zoom in on it,
you can see that it's rounded

00:12:48.786 --> 00:12:50.786 A:middle
on the inside but it's not
rounded on the outside,

00:12:51.086 --> 00:12:52.246 A:middle
and that wasn't the intent.

00:12:52.406 --> 00:12:54.696 A:middle
I wanted pure rounded,
pure roundedness

00:12:54.696 --> 00:12:55.856 A:middle
on both the inside
and the outside.

00:12:56.716 --> 00:12:59.906 A:middle
So let's explore in more
detail why that's happening

00:12:59.906 --> 00:13:02.886 A:middle
as we take a look
at Swift structures.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.906 --> 00:13:02.886 A:middle
as we take a look
at Swift structures.

00:13:03.276 --> 00:13:04.966 A:middle
And how Swift makes it easier

00:13:04.966 --> 00:13:06.316 A:middle
and more natural to
work with structs.

00:13:06.316 --> 00:13:10.086 A:middle
So we have a lot of primitive
structs, for example,

00:13:10.086 --> 00:13:12.066 A:middle
in the Core Graphics framework.

00:13:12.066 --> 00:13:17.506 A:middle
We have things like CGrects,
CGpoints, CGsize, and so forth.

00:13:17.706 --> 00:13:21.146 A:middle
And what we did when we drew
is I have a bounding rectangle,

00:13:21.146 --> 00:13:23.836 A:middle
which is a CGrect, and
I drew this bezier path.

00:13:23.836 --> 00:13:26.196 A:middle
Now, the bezier path
is the grey outline

00:13:26.536 --> 00:13:29.286 A:middle
on the screen, drew
the bezier path.

00:13:29.696 --> 00:13:31.666 A:middle
Next it was put inside of
the bounding rectangle,

00:13:31.666 --> 00:13:33.046 A:middle
and you can see the
bounding rectangle here.

00:13:34.096 --> 00:13:36.496 A:middle
Bezier paths themselves are
not something that you see.

00:13:36.496 --> 00:13:39.096 A:middle
They don't render until
you apply a line to them,

00:13:39.096 --> 00:13:40.986 A:middle
like a line stroke, and
then that's what you see,

00:13:40.986 --> 00:13:42.626 A:middle
that's what's rendered
against the bezier path.

00:13:43.736 --> 00:13:47.026 A:middle
So we draw the bezier path.

00:13:47.026 --> 00:13:48.186 A:middle
We then put a stroke on it.

00:13:48.536 --> 00:13:51.696 A:middle
The stroke is, for example, ten
units wide, ten points wide,

00:13:52.356 --> 00:13:53.866 A:middle
but it's going outside
the boundaries

00:13:53.866 --> 00:13:54.736 A:middle
of the bounding rectangle.

00:13:55.316 --> 00:13:58.016 A:middle
And that results in clipping.

00:13:58.746 --> 00:14:00.816 A:middle
So the rounded rectangle is
actually there on the outside,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.746 --> 00:14:00.816 A:middle
So the rounded rectangle is
actually there on the outside,

00:14:00.816 --> 00:14:01.916 A:middle
but this clipping
that's happening

00:14:01.916 --> 00:14:03.746 A:middle
with the bounding rectangle is
preventing it from being there.

00:14:05.046 --> 00:14:07.836 A:middle
I know some of you in the
audience might think, well,

00:14:07.836 --> 00:14:08.836 A:middle
if you have an issue
with clipping,

00:14:08.836 --> 00:14:11.386 A:middle
just turn clipping off, and
then that issue is fixed

00:14:11.386 --> 00:14:12.376 A:middle
and you go on to the next thing.

00:14:14.156 --> 00:14:15.496 A:middle
Which is, I suppose, true.

00:14:15.496 --> 00:14:19.526 A:middle
It's kind of like solving
issues with Swift, though,

00:14:19.596 --> 00:14:23.396 A:middle
in Xcode by just shuffling
around Swift's exclamation marks

00:14:23.646 --> 00:14:24.596 A:middle
until it compiles [laughter].

00:14:27.156 --> 00:14:30.116 A:middle
You can do it, but I would
never call that a best practice.

00:14:30.766 --> 00:14:33.406 A:middle
And when it comes to clipping,

00:14:33.406 --> 00:14:36.646 A:middle
there's a performance
issue with this.

00:14:36.746 --> 00:14:39.696 A:middle
With every API that you
call, with every task

00:14:39.746 --> 00:14:42.606 A:middle
that you initiate, with
every move that you make

00:14:42.606 --> 00:14:43.776 A:middle
and every breath that
you take - [laughter] --

00:14:44.026 --> 00:14:47.706 A:middle
you need to consider the impact
on power and performance.

00:14:48.246 --> 00:14:49.596 A:middle
And it's not very performant

00:14:49.596 --> 00:14:52.016 A:middle
to be constantly calculating the
intersection of two rectangles

00:14:52.016 --> 00:14:53.056 A:middle
and performing clipping on it.

00:14:53.056 --> 00:14:55.756 A:middle
It's more performant
just to set the rectangle

00:14:55.756 --> 00:14:57.336 A:middle
to be the right size
in the first place.

00:14:57.336 --> 00:14:59.856 A:middle
That's what we are going to do.

00:14:59.856 --> 00:15:02.266 A:middle
We are just going to
inset the bezier path

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.856 --> 00:15:02.266 A:middle
We are just going to
inset the bezier path

00:15:02.266 --> 00:15:03.536 A:middle
so that it doesn't clip itself.

00:15:04.146 --> 00:15:07.216 A:middle
Now, to do that, we are
going to use some methods --

00:15:07.216 --> 00:15:10.796 A:middle
and I do mean methods,
available on CGrect,

00:15:11.056 --> 00:15:12.936 A:middle
when it's being used in Swift.

00:15:14.006 --> 00:15:15.966 A:middle
Think about how these primitive
types are used normally.

00:15:15.966 --> 00:15:18.176 A:middle
We have things like CGrect
and CGpoint, and so forth,

00:15:18.176 --> 00:15:20.846 A:middle
as I said, and they
might exist over here.

00:15:20.846 --> 00:15:23.266 A:middle
And then separately
you have got the set

00:15:23.266 --> 00:15:28.126 A:middle
of global utility functions that
work on them, like CGrectZero,

00:15:28.126 --> 00:15:31.256 A:middle
CGrectMake, or GetWidth,
or some actual functions

00:15:31.256 --> 00:15:33.426 A:middle
like get the union
or the intersection.

00:15:33.926 --> 00:15:35.786 A:middle
There's this cognitive
separation between the two.

00:15:35.786 --> 00:15:37.636 A:middle
We know that this is the
type, and then we have to know

00:15:37.636 --> 00:15:40.136 A:middle
that these are the
methods -- or sorry --

00:15:40.246 --> 00:15:42.526 A:middle
the functions that act upon it.

00:15:43.056 --> 00:15:45.586 A:middle
Well, when we work in Swift,
we actually change how things

00:15:45.586 --> 00:15:49.556 A:middle
like CGrect and CGpoint
and CGsize come into Swift.

00:15:50.476 --> 00:15:52.896 A:middle
We basically use encapsulation
and take all those,

00:15:53.406 --> 00:15:56.326 A:middle
those global, formerly
global functions that can act

00:15:56.326 --> 00:15:59.096 A:middle
on that structure and build
it into the structure,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.546 --> 00:16:02.776 A:middle
which makes it much easier
to have code completion,

00:16:02.776 --> 00:16:06.846 A:middle
makes it more awesome to
predict what the API is,

00:16:06.846 --> 00:16:09.356 A:middle
because you can just
do my struct dot

00:16:09.646 --> 00:16:11.746 A:middle
and then you get code
completion for all the methods

00:16:11.826 --> 00:16:12.906 A:middle
and properties that it has.

00:16:14.006 --> 00:16:16.036 A:middle
But if we left the
names like this,

00:16:16.486 --> 00:16:17.866 A:middle
it wouldn't really feel native.

00:16:18.346 --> 00:16:22.976 A:middle
So the names are actually
remapped to have a feel

00:16:22.976 --> 00:16:25.856 A:middle
to make them first-class
methods on these data types.

00:16:26.366 --> 00:16:30.316 A:middle
The benefit of this is the way
that you work with structures

00:16:30.316 --> 00:16:34.406 A:middle
in Swift, calling functions
or calling methods really

00:16:34.406 --> 00:16:36.816 A:middle
or accessing their
properties, exactly the same way

00:16:37.046 --> 00:16:38.736 A:middle
that you work with classes.

00:16:38.736 --> 00:16:42.336 A:middle
It's exactly the same way that
you work with enums, or enums.

00:16:42.946 --> 00:16:45.186 A:middle
It's all the same
consistent style.

00:16:45.596 --> 00:16:48.196 A:middle
We also get to use
initializers that are the same

00:16:48.196 --> 00:16:49.586 A:middle
across all the different
data types.

00:16:49.886 --> 00:16:51.846 A:middle
We get to have better
code completion.

00:16:51.846 --> 00:16:56.116 A:middle
So all in all, working with
these types is much more natural

00:16:56.116 --> 00:16:57.646 A:middle
in Swift because they behave

00:16:57.646 --> 00:17:00.746 A:middle
as first-class data
types with methods.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:57.646 --> 00:17:00.746 A:middle
as first-class data
types with methods.

00:17:01.406 --> 00:17:04.386 A:middle
Okay. The other thing
that we are going to do

00:17:04.386 --> 00:17:06.836 A:middle
in the following demonstration
is, I don't know about you,

00:17:06.836 --> 00:17:07.925 A:middle
but when I work with
graphics code,

00:17:07.925 --> 00:17:09.965 A:middle
especially some Core Graphics
stuff, one of the approaches

00:17:09.965 --> 00:17:15.756 A:middle
that I would use is, I
would render the code,

00:17:15.756 --> 00:17:18.046 A:middle
and then I would run it, and
then it builds and it copies

00:17:18.046 --> 00:17:20.016 A:middle
into the simulator, then
I navigate to that part

00:17:20.016 --> 00:17:22.945 A:middle
in the simulator where the
code is actually activated,

00:17:22.945 --> 00:17:23.626 A:middle
where it's used.

00:17:23.786 --> 00:17:25.906 A:middle
Then I inspect it, and if
I don't like it, I go back

00:17:25.906 --> 00:17:27.616 A:middle
and I tweak the code and
I run the whole thing.

00:17:27.616 --> 00:17:29.516 A:middle
This is a -- this loop,

00:17:29.906 --> 00:17:32.096 A:middle
this round-trip can be
really expensive time-wise.

00:17:32.176 --> 00:17:34.406 A:middle
Just to see what it looks like
when you change a line width

00:17:34.406 --> 00:17:37.226 A:middle
from three to four or you
turn off rasterization

00:17:37.226 --> 00:17:38.906 A:middle
or you do some sort of
setting change as you try

00:17:38.906 --> 00:17:39.646 A:middle
to get things to work.

00:17:40.396 --> 00:17:42.946 A:middle
So there's a better approach

00:17:43.776 --> 00:17:45.306 A:middle
that doesn't have
this round-tripping,

00:17:45.816 --> 00:17:48.296 A:middle
and it doesn't have you
often commenting out portions

00:17:48.296 --> 00:17:50.276 A:middle
of your code just to
experiment with how it looks.

00:17:50.276 --> 00:17:51.366 A:middle
If you really want
to experiment,

00:17:51.366 --> 00:17:54.646 A:middle
and play around with some code,
and see how it, how it works,

00:17:54.996 --> 00:17:56.046 A:middle
that's what we have
playgrounds for.

00:17:56.726 --> 00:17:58.586 A:middle
With playgrounds, this
loop gets switched

00:17:58.586 --> 00:17:59.466 A:middle
to just something like this.

00:17:59.466 --> 00:18:01.716 A:middle
You just tweak the code, and
you see the change right away,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.466 --> 00:18:01.716 A:middle
You just tweak the code, and
you see the change right away,

00:18:01.716 --> 00:18:03.236 A:middle
and if you don't like it,
just change it right away.

00:18:03.616 --> 00:18:05.366 A:middle
There's none of that copying
to the simulator, navigate

00:18:05.366 --> 00:18:06.126 A:middle
and see what it looks like.

00:18:06.526 --> 00:18:07.846 A:middle
So we are going to
fix up the problem

00:18:07.846 --> 00:18:10.456 A:middle
with our rounded
rectangles, using a playground

00:18:10.456 --> 00:18:13.496 A:middle
and using the methods
that are part of CGrect

00:18:13.796 --> 00:18:15.096 A:middle
to get a better CGrect
out of it.

00:18:15.526 --> 00:18:15.966 A:middle
Let me show you.

00:18:24.086 --> 00:18:26.236 A:middle
The drawing code is over
in atomic element tile view

00:18:26.236 --> 00:18:26.786 A:middle
dot Swift.

00:18:26.786 --> 00:18:27.226 A:middle
That's here.

00:18:27.596 --> 00:18:29.116 A:middle
And this is the function
that I just copied

00:18:29.116 --> 00:18:30.406 A:middle
in the previous demonstration.

00:18:30.846 --> 00:18:32.266 A:middle
It's the one I want to play
with, so I am just going

00:18:32.266 --> 00:18:33.366 A:middle
to copy it into a playground.

00:18:33.776 --> 00:18:35.996 A:middle
So I've copied it,
I'll hit command-N

00:18:35.996 --> 00:18:36.976 A:middle
and make a new iOS playground.

00:18:47.046 --> 00:18:47.396 A:middle
Paste it in.

00:18:48.256 --> 00:18:49.586 A:middle
And now I have the
drawing function.

00:18:50.446 --> 00:18:53.086 A:middle
No developer is an island.

00:18:53.676 --> 00:18:55.846 A:middle
No drawing functions
live in isolation either.

00:18:56.286 --> 00:18:58.586 A:middle
Drawing functions have to
draw in the context of --

00:18:58.796 --> 00:19:00.526 A:middle
well, a drawing context
or graphics context.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.796 --> 00:19:00.526 A:middle
well, a drawing context
or graphics context.

00:19:00.526 --> 00:19:02.826 A:middle
And the easiest way to get
a graphics context is just

00:19:02.826 --> 00:19:04.166 A:middle
to make a subclass of UIView.

00:19:04.396 --> 00:19:05.806 A:middle
So that's exactly
what I am going to do.

00:19:05.806 --> 00:19:09.226 A:middle
I am just going to declare
a subclass of UIView here.

00:19:09.226 --> 00:19:13.966 A:middle
All it does is call
that drawing function,

00:19:13.966 --> 00:19:18.756 A:middle
and then I'll instantiate
that class here.

00:19:19.756 --> 00:19:25.326 A:middle
And then I can take the image
that's drawn as a result

00:19:25.326 --> 00:19:27.496 A:middle
of my drawing function
and just add it directly

00:19:27.496 --> 00:19:28.696 A:middle
to the storyboard here.

00:19:29.226 --> 00:19:32.396 A:middle
Make it larger so we can see it.

00:19:32.726 --> 00:19:35.296 A:middle
And then you can
experiment with it.

00:19:35.296 --> 00:19:36.716 A:middle
You can kind of figure
out what you need to do

00:19:36.716 --> 00:19:38.516 A:middle
to make it draw the way
you want it to draw.

00:19:38.516 --> 00:19:40.426 A:middle
So, for example, I
want to see if it looks

00:19:40.426 --> 00:19:42.526 A:middle
like if it has only
120 points across.

00:19:43.806 --> 00:19:44.706 A:middle
There's the result right away.

00:19:46.236 --> 00:19:47.156 A:middle
Maybe I want to see
what it looks

00:19:47.156 --> 00:19:49.766 A:middle
like if the line width
isn't 6 but is actually 60,

00:19:50.396 --> 00:19:54.766 A:middle
with a corner radius of 356.

00:19:55.106 --> 00:19:56.456 A:middle
That's what we get.

00:19:56.456 --> 00:19:58.616 A:middle
So you can keep experimenting
with it.

00:19:58.616 --> 00:20:00.556 A:middle
And then once you have the code
working the way that you like,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.616 --> 00:20:00.556 A:middle
And then once you have the code
working the way that you like,

00:20:00.886 --> 00:20:01.896 A:middle
you just copy and paste it back

00:20:01.896 --> 00:20:03.326 A:middle
into the actual file
from which it came.

00:20:04.486 --> 00:20:08.396 A:middle
So in this case, I want to have
my line width scale so that

00:20:08.396 --> 00:20:10.396 A:middle
if it's the small tile
view in the table view,

00:20:10.926 --> 00:20:13.006 A:middle
it's got thin edges, and
if it's the larger one,

00:20:13.006 --> 00:20:14.486 A:middle
it has proportionately
thicker edges.

00:20:14.696 --> 00:20:18.006 A:middle
So I am going to make
it related to the width

00:20:18.006 --> 00:20:18.846 A:middle
of the background rectangle.

00:20:19.496 --> 00:20:24.066 A:middle
So background rectangle.width
divided by, in this case, 36.

00:20:24.166 --> 00:20:26.956 A:middle
And I will do the same
thing for the corner radius.

00:20:27.846 --> 00:20:30.316 A:middle
Backgroundrectangle.width
divided

00:20:30.316 --> 00:20:32.496 A:middle
by something smaller, like 16.

00:20:33.066 --> 00:20:36.846 A:middle
So now it's starting to
look like I want it to look,

00:20:36.846 --> 00:20:38.326 A:middle
but I still have the
problem where I am clipping,

00:20:38.386 --> 00:20:39.966 A:middle
so I am not able to
see the full extent

00:20:40.406 --> 00:20:42.536 A:middle
of the stroke nor the
rounded rectangles.

00:20:42.536 --> 00:20:45.686 A:middle
So, to do that, on
background rectangle,

00:20:45.776 --> 00:20:50.596 A:middle
I will use the method
called rect by insetting,

00:20:50.596 --> 00:20:53.386 A:middle
and I will inset it to
be half the line width.

00:20:53.936 --> 00:20:58.546 A:middle
So that's line width
divided by 2 and same thing,

00:20:58.756 --> 00:21:00.526 A:middle
line width divided by 2.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.756 --> 00:21:00.526 A:middle
line width divided by 2.

00:21:01.076 --> 00:21:05.126 A:middle
And there, now I have a
perfectly rounded rectangle

00:21:05.126 --> 00:21:07.386 A:middle
exactly like I expected to
have in the first place.

00:21:08.026 --> 00:21:13.466 A:middle
I will copy this code from
here back to the extension,

00:21:13.826 --> 00:21:15.336 A:middle
replacing the file -- sorry --

00:21:15.336 --> 00:21:16.366 A:middle
replacing the method
that's there.

00:21:17.446 --> 00:21:18.776 A:middle
Rerun the app with command-R.

00:21:19.596 --> 00:21:25.186 A:middle
And that's exactly what I wanted
to have, rounded rectangles.

00:21:25.956 --> 00:21:26.506 A:middle
Yeah, please.

00:21:26.616 --> 00:21:26.776 A:middle
Yeah.

00:21:27.516 --> 00:21:33.836 A:middle
[ Applause ]

00:21:34.336 --> 00:21:36.806 A:middle
Yeah, pretty much at
WWDC, if ever you feel

00:21:36.806 --> 00:21:37.806 A:middle
like applauding, just applaud.

00:21:38.516 --> 00:21:39.976 A:middle
Nobody is going to
say stop that.

00:21:40.346 --> 00:21:40.856 A:middle
It's all good [applause].

00:21:41.536 --> 00:21:42.426 A:middle
See, thank you.

00:21:45.086 --> 00:21:46.386 A:middle
So the app is looking okay.

00:21:46.386 --> 00:21:47.476 A:middle
I've got these rounded
rectangles.

00:21:47.476 --> 00:21:48.596 A:middle
That's great, that's
what I want.

00:21:48.916 --> 00:21:49.886 A:middle
But the next thing I want

00:21:49.886 --> 00:21:51.826 A:middle
to do is make this app feel
more like a current app.

00:21:51.896 --> 00:21:55.606 A:middle
Now, I don't know about
you, but have you ever gone

00:21:55.876 --> 00:21:59.366 A:middle
to your client after
especially WWDC and said, hey,

00:21:59.366 --> 00:22:01.036 A:middle
there's this new version
of iOS coming out,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.366 --> 00:22:01.036 A:middle
there's this new version
of iOS coming out,

00:22:01.036 --> 00:22:02.606 A:middle
for example, iOS
9 is coming out.

00:22:02.696 --> 00:22:06.126 A:middle
I think we should just
not support iOS 8 anymore,

00:22:06.426 --> 00:22:09.276 A:middle
and we are only going to support
the new upcoming operating

00:22:09.276 --> 00:22:09.466 A:middle
system [applause].

00:22:10.576 --> 00:22:12.206 A:middle
Yeah. Have you done
that [applause]?

00:22:15.576 --> 00:22:16.886 A:middle
Yeah, and then you are looking
for another client [laughter].

00:22:18.046 --> 00:22:22.246 A:middle
Because they all want you to
support these old versions,

00:22:22.696 --> 00:22:26.016 A:middle
iOS 7, 8, and now 9 is
probably going to be on slate

00:22:26.016 --> 00:22:27.096 A:middle
for this fall for many of you.

00:22:27.586 --> 00:22:31.376 A:middle
So to do that, we have this new
availability feature introduced

00:22:31.376 --> 00:22:32.266 A:middle
in Swift 2.0.

00:22:32.266 --> 00:22:33.996 A:middle
So as long as you are writing
some code in Swift 2.0,

00:22:33.996 --> 00:22:37.706 A:middle
we have a great way to check
to see what SDK you are on

00:22:37.706 --> 00:22:40.326 A:middle
and if you can actually
use this feature or not.

00:22:40.646 --> 00:22:43.446 A:middle
Now, last year at WWDC,

00:22:43.446 --> 00:22:47.266 A:middle
we introduced some new view
controller presentation APIs

00:22:47.386 --> 00:22:50.396 A:middle
that allow for popover
presentations on iPhone.

00:22:51.076 --> 00:22:53.816 A:middle
So what I want to do in my
elements app is when I am

00:22:53.816 --> 00:22:57.626 A:middle
on any device that supports it
-- for example, an iOS 8 device

00:22:57.626 --> 00:23:00.016 A:middle
or newer -- I want to use
a popover presentation.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:57.626 --> 00:23:00.016 A:middle
or newer -- I want to use
a popover presentation.

00:23:00.196 --> 00:23:01.636 A:middle
But when I am on iOS 7,

00:23:01.636 --> 00:23:04.526 A:middle
I want to continue using
the navigation push

00:23:04.526 --> 00:23:05.286 A:middle
presentation style.

00:23:05.286 --> 00:23:06.626 A:middle
All right.

00:23:06.626 --> 00:23:07.766 A:middle
So how do we do this?

00:23:07.766 --> 00:23:12.756 A:middle
Well, this is the classic
way of checking to see

00:23:12.756 --> 00:23:13.786 A:middle
if you support an API.

00:23:14.026 --> 00:23:16.726 A:middle
We do whatever the type
is, we check and see

00:23:16.726 --> 00:23:17.936 A:middle
if it responds to selector.

00:23:17.936 --> 00:23:20.076 A:middle
And if so, then we
just use the selector.

00:23:20.076 --> 00:23:22.006 A:middle
If not, then we do
something else.

00:23:23.496 --> 00:23:27.216 A:middle
This is the way that we do
it in Swift, as of Swift 2.0.

00:23:27.686 --> 00:23:32.426 A:middle
We have this hashtag available,
and you specify the SDK

00:23:32.426 --> 00:23:36.466 A:middle
that you want, so iOS 8.3 in
this case, and then if so,

00:23:36.466 --> 00:23:38.736 A:middle
we use a popover, and if not,
we use the other approach.

00:23:39.236 --> 00:23:41.996 A:middle
And the benefit of this style
is that you are not waiting

00:23:41.996 --> 00:23:44.136 A:middle
to runtime to see if
it actually works.

00:23:44.186 --> 00:23:47.336 A:middle
At compilation time, the
compiler can tell you, yes,

00:23:47.586 --> 00:23:49.426 A:middle
this will work, or it
won't work depending

00:23:49.426 --> 00:23:50.856 A:middle
on your deployment target.

00:23:50.856 --> 00:23:53.806 A:middle
So if I am deploying to iOS
7, it's able to tell me,

00:23:54.016 --> 00:23:55.736 A:middle
popover isn't available.

00:23:55.736 --> 00:23:57.156 A:middle
But because I've
properly guarded it

00:23:57.456 --> 00:23:59.506 A:middle
by giving it another path,
it's able to compile.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:00.096 --> 00:24:05.056 A:middle
In this case, if I hadn't put
that guard in, if I hadn't said,

00:24:05.356 --> 00:24:09.476 A:middle
here's the check and I tried to
compile this and it was trying

00:24:09.476 --> 00:24:12.886 A:middle
to deploy back to
iOS 7, it would say,

00:24:13.066 --> 00:24:15.016 A:middle
popover presentation
controller is not available.

00:24:15.136 --> 00:24:16.236 A:middle
It's only available
on 8 or newer.

00:24:17.036 --> 00:24:18.276 A:middle
And then it gives
you some fixes.

00:24:18.396 --> 00:24:19.826 A:middle
But instead of just showing
you some more slides,

00:24:19.826 --> 00:24:21.016 A:middle
let me actually show
it to you in code.

00:24:22.006 --> 00:24:22.826 A:middle
Alright. So first of all,

00:24:22.826 --> 00:24:25.666 A:middle
the code that presents the
second view controller is kept

00:24:25.666 --> 00:24:28.496 A:middle
over in
elementsviewcontroller.m. It's

00:24:28.496 --> 00:24:32.466 A:middle
just an implementation of table
view accessory but in tapped

00:24:32.466 --> 00:24:33.566 A:middle
for row with index path.

00:24:34.756 --> 00:24:36.326 A:middle
And because I want to use
availability checking,

00:24:36.326 --> 00:24:38.896 A:middle
I have to have this implemented
in Swift, not Objective-C.

00:24:38.896 --> 00:24:40.176 A:middle
So I am just going
to comment it out.

00:24:40.176 --> 00:24:43.746 A:middle
And then I am going to
create a class extension much

00:24:43.746 --> 00:24:46.706 A:middle
like the original demo
from 20 minutes or so ago,

00:24:46.706 --> 00:24:50.946 A:middle
so that I can extend elements
view controller and have some

00:24:50.946 --> 00:24:52.636 A:middle
of its functionality
implemented in Swift.

00:24:52.636 --> 00:24:56.006 A:middle
So I will hit command-N to make
a new file, it's a Swift file.

00:24:56.776 --> 00:24:59.676 A:middle
It's elements view
controller dot Swift.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:01.086 --> 00:25:03.616 A:middle
Then I will write a class
extension on it here.

00:25:05.276 --> 00:25:08.256 A:middle
Extension, elements
view controller,

00:25:09.966 --> 00:25:14.286 A:middle
and inside of there I will
just take the equivalent

00:25:14.436 --> 00:25:15.166 A:middle
Swift function.

00:25:15.246 --> 00:25:16.866 A:middle
So this is essentially
the same code

00:25:16.866 --> 00:25:17.846 A:middle
that I already had
there in Swift.

00:25:17.846 --> 00:25:19.286 A:middle
There's nothing new
at this point.

00:25:19.286 --> 00:25:21.136 A:middle
It's just the same thing
now implemented in Swift,

00:25:21.676 --> 00:25:23.516 A:middle
but this lets me bring up
the availability checking.

00:25:24.126 --> 00:25:29.766 A:middle
This particular application
is targeting iOS 7.1,

00:25:30.756 --> 00:25:34.216 A:middle
and I want to use this new
popover presentation controller

00:25:34.796 --> 00:25:40.346 A:middle
technique in it, so I am going
to comment out this line and put

00:25:40.346 --> 00:25:42.846 A:middle
in code that tries to directly
call the popover presentation.

00:25:47.316 --> 00:25:48.646 A:middle
So I am getting some errors.

00:25:49.036 --> 00:25:50.406 A:middle
One of the errors it's
complaining about is

00:25:50.406 --> 00:25:52.906 A:middle
that I don't actually conform
to the delegate protocol

00:25:52.906 --> 00:25:54.366 A:middle
that I need to for popovers.

00:25:55.106 --> 00:25:58.896 A:middle
Well, just on the aside, it's
okay to take an extension

00:25:58.896 --> 00:26:00.786 A:middle
in Swift and use it
to add conformance

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.896 --> 00:26:00.786 A:middle
in Swift and use it
to add conformance

00:26:01.226 --> 00:26:02.626 A:middle
to additional protocols.

00:26:02.756 --> 00:26:06.066 A:middle
So I'll just add UI popover
presentation controller

00:26:06.066 --> 00:26:06.716 A:middle
delegate there.

00:26:07.416 --> 00:26:11.166 A:middle
That clears up that error,
but I still have the problem

00:26:11.896 --> 00:26:15.766 A:middle
about trying to use an API
that doesn't exist on iOS 7.1,

00:26:16.196 --> 00:26:18.076 A:middle
which is exactly
what I wanted --

00:26:18.076 --> 00:26:19.106 A:middle
well, in the demonstration
anyway.

00:26:19.796 --> 00:26:21.916 A:middle
So I have a couple
of ways to fix it.

00:26:23.126 --> 00:26:25.356 A:middle
I have it pre-baked
for you here.

00:26:26.356 --> 00:26:30.686 A:middle
To say if I am running on
-- in this case, iOS 8.3 --

00:26:31.016 --> 00:26:32.376 A:middle
go ahead and display
as a popover.

00:26:32.376 --> 00:26:34.076 A:middle
Otherwise, use navigation
controller.

00:26:34.686 --> 00:26:43.006 A:middle
Now, if I run it and I tap
on the i -- let's see here.

00:26:44.056 --> 00:26:45.736 A:middle
We get a popover.

00:26:46.916 --> 00:26:49.786 A:middle
It's been 15 years and we
are still getting Carbon

00:26:50.346 --> 00:26:51.826 A:middle
at WWDC [applause].

00:26:52.646 --> 00:26:52.836 A:middle
Alright.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:05.076 --> 00:27:06.586 A:middle
For more information about
availability checking,

00:27:06.746 --> 00:27:08.536 A:middle
please check out Thursday's
session called Swift

00:27:08.536 --> 00:27:09.146 A:middle
in Practice.

00:27:09.146 --> 00:27:13.806 A:middle
There's a whole big
talk about it.

00:27:14.076 --> 00:27:15.896 A:middle
Next up, the previous
demonstrations were

00:27:15.896 --> 00:27:19.066 A:middle
about improving and modernizing
the look of the application.

00:27:19.066 --> 00:27:21.566 A:middle
You know, we changed the
drawing to get rid of the gloss.

00:27:21.566 --> 00:27:23.136 A:middle
We now have a popover
and so forth.

00:27:23.136 --> 00:27:25.256 A:middle
But let's actually add
some functionality to it.

00:27:25.486 --> 00:27:28.456 A:middle
So we are going to
implement live searching.

00:27:28.826 --> 00:27:29.926 A:middle
And to do that, we are
going to take a look

00:27:29.926 --> 00:27:32.366 A:middle
at Swift's filter method,
which is now available

00:27:32.366 --> 00:27:34.876 A:middle
on all collections,
including sets and arrays.

00:27:35.696 --> 00:27:39.056 A:middle
Filtering can be used to
drive a live search function

00:27:39.056 --> 00:27:40.086 A:middle
where only atomic elements

00:27:40.116 --> 00:27:43.136 A:middle
that match the search string
are displayed in the table view.

00:27:43.466 --> 00:27:47.036 A:middle
A standard setup for this would
be, well, something like this.

00:27:47.036 --> 00:27:47.856 A:middle
We've got a TableView.

00:27:47.856 --> 00:27:50.206 A:middle
The TableView is paired
with a view controller

00:27:50.206 --> 00:27:51.556 A:middle
that acts as its data source.

00:27:51.986 --> 00:27:53.856 A:middle
That view controller
has an array of content.

00:27:54.566 --> 00:27:59.216 A:middle
And when I type something
into the search field,

00:27:59.286 --> 00:28:01.396 A:middle
I have a delegate
method that's called,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.286 --> 00:28:01.396 A:middle
I have a delegate
method that's called,

00:28:01.736 --> 00:28:03.876 A:middle
on the view controller called
searchbar:textDidChange.

00:28:03.876 --> 00:28:07.556 A:middle
I figure out the string
that's been passed.

00:28:07.846 --> 00:28:08.566 A:middle
It's just an argument.

00:28:09.026 --> 00:28:10.586 A:middle
I filter the array of content.

00:28:10.666 --> 00:28:12.206 A:middle
And then I tell the
TableView to update

00:28:12.206 --> 00:28:17.126 A:middle
with this now filtered
array of content.

00:28:17.956 --> 00:28:21.136 A:middle
Search bar:textDidChange
looks something like this.

00:28:22.206 --> 00:28:24.116 A:middle
In actuality, it looks
exactly like this

00:28:24.116 --> 00:28:25.316 A:middle
because that's the
code that I am using.

00:28:25.826 --> 00:28:26.986 A:middle
Now I want to draw
your attention

00:28:27.526 --> 00:28:29.886 A:middle
to the highlighted
section, which is a closure.

00:28:30.426 --> 00:28:32.646 A:middle
So I am running a
filter, and in the filter,

00:28:32.956 --> 00:28:34.796 A:middle
it's going to be applied
to every one of the items

00:28:34.796 --> 00:28:37.386 A:middle
in the array, and that item in
the array, I have a placeholder,

00:28:37.386 --> 00:28:39.896 A:middle
which the dollar sign zero,
I am getting its name,

00:28:39.896 --> 00:28:41.616 A:middle
and then I'm asking
if it has the prefix,

00:28:41.616 --> 00:28:42.726 A:middle
and whatever the
search string is.

00:28:43.236 --> 00:28:46.856 A:middle
It kind of works like this.

00:28:46.916 --> 00:28:49.026 A:middle
Here I have my original
array up at the top.

00:28:49.026 --> 00:28:51.106 A:middle
And I have a closure for filter.

00:28:51.686 --> 00:28:52.616 A:middle
And it just cycles through,

00:28:52.616 --> 00:28:55.636 A:middle
passing in the element each
time, and if it has the name

00:28:55.856 --> 00:28:57.386 A:middle
that begins with the
letter, in this case N,

00:28:57.836 --> 00:28:59.736 A:middle
it's passed through to the
returning filtered array.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:00.806 --> 00:29:02.476 A:middle
And if not, it's not.

00:29:02.716 --> 00:29:03.776 A:middle
Let me show you this in code.

00:29:04.346 --> 00:29:06.226 A:middle
But just to speed things
along, I've already gone

00:29:06.926 --> 00:29:08.146 A:middle
and put a search
bar up at the top.

00:29:08.886 --> 00:29:09.836 A:middle
But I haven't rigged it up yet,

00:29:09.836 --> 00:29:11.246 A:middle
so if I try to do
anything inside of it,

00:29:11.246 --> 00:29:14.216 A:middle
it just doesn't work because I
haven't put the delegate method

00:29:14.216 --> 00:29:15.166 A:middle
in yet.

00:29:16.296 --> 00:29:18.986 A:middle
The delegate method is this.

00:29:22.756 --> 00:29:24.666 A:middle
We are saying, if the
search text is empty,

00:29:24.696 --> 00:29:25.986 A:middle
show all the atomic elements.

00:29:26.566 --> 00:29:27.116 A:middle
That's here.

00:29:28.156 --> 00:29:30.476 A:middle
If it's not empty, I
want to do a filter,

00:29:30.476 --> 00:29:31.876 A:middle
and that part is
left to be done.

00:29:31.876 --> 00:29:32.596 A:middle
Let's do it right now.

00:29:38.136 --> 00:29:39.206 A:middle
So I am going to
bring up a filter.

00:29:39.286 --> 00:29:41.506 A:middle
And if it's the first time
that you've seen closures,

00:29:41.946 --> 00:29:43.626 A:middle
great, welcome to closures.

00:29:43.816 --> 00:29:44.896 A:middle
Let me show you a
little bit about it.

00:29:44.896 --> 00:29:46.926 A:middle
And if not, maybe it's
a bit of a review.

00:29:47.296 --> 00:29:49.966 A:middle
When Xcode shows you these blue
kind of tokenized backgrounds

00:29:49.966 --> 00:29:52.086 A:middle
that are all singular items,
you can double-click them,

00:29:52.086 --> 00:29:54.316 A:middle
and they expand out, and
you just fill in the blanks.

00:29:54.696 --> 00:29:57.436 A:middle
So I'll take this closure,
double-click it, it expands out.

00:29:57.436 --> 00:30:01.926 A:middle
And I know that I have an
array of atomic elements.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:57.436 --> 00:30:01.926 A:middle
And I know that I have an
array of atomic elements.

00:30:01.926 --> 00:30:03.556 A:middle
The data type is
called atomic element.

00:30:04.056 --> 00:30:07.286 A:middle
So the parameter that's being
passed in is one atomic element.

00:30:07.286 --> 00:30:10.106 A:middle
So I am just going to
specify that in this closure,

00:30:10.606 --> 00:30:11.786 A:middle
the parameters that
are being passed

00:30:11.786 --> 00:30:14.356 A:middle
in is one atomic element -- I am
going to give it a local name,

00:30:14.356 --> 00:30:17.366 A:middle
so atomic element
is its local name,

00:30:17.366 --> 00:30:19.776 A:middle
and its data type
is atomic element.

00:30:21.256 --> 00:30:23.836 A:middle
Inside the closure, I need
to check to see if I want

00:30:23.836 --> 00:30:26.696 A:middle
to include it in the
filtered results or not

00:30:27.046 --> 00:30:29.706 A:middle
because I promised to give a
return value that's a Boolean.

00:30:30.876 --> 00:30:35.626 A:middle
So I'll say my return value
is whether the atomic element,

00:30:36.246 --> 00:30:42.056 A:middle
name, has prefix, and then
the search text that's passed

00:30:42.056 --> 00:30:42.816 A:middle
in from the search bar.

00:30:43.406 --> 00:30:48.346 A:middle
Like that.

00:30:49.476 --> 00:30:58.036 A:middle
Now, when I run it, we'll
do a search for everything

00:30:58.036 --> 00:30:59.016 A:middle
that begins with letter N.

00:30:59.416 --> 00:30:59.796 A:middle
There we go.

00:30:59.796 --> 00:31:01.766 A:middle
We get it filtered
using Swift's filter.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.796 --> 00:31:01.766 A:middle
We get it filtered
using Swift's filter.

00:31:02.876 --> 00:31:04.706 A:middle
But there's two things
I want to show you.

00:31:04.706 --> 00:31:06.766 A:middle
One, there's really
two different ways

00:31:06.766 --> 00:31:07.846 A:middle
to take a look at closures.

00:31:07.846 --> 00:31:09.996 A:middle
There's this expanded syntax.

00:31:11.476 --> 00:31:13.316 A:middle
There's also a condensed syntax.

00:31:13.546 --> 00:31:16.946 A:middle
Let me show you the
condensed syntax.

00:31:16.946 --> 00:31:19.176 A:middle
Swift has a very strong
type inference system.

00:31:19.176 --> 00:31:22.056 A:middle
We can infer a lot of things
based on context and the kind

00:31:22.056 --> 00:31:23.056 A:middle
of data types that
you are using.

00:31:23.536 --> 00:31:26.576 A:middle
So for example, if you have
a single line in a closure,

00:31:26.576 --> 00:31:29.376 A:middle
it's assumed that it's going to
return a value, so I don't have

00:31:29.376 --> 00:31:30.366 A:middle
to put the return in there.

00:31:30.796 --> 00:31:35.196 A:middle
And in fact, has prefix gives
a return type of Boolean

00:31:35.196 --> 00:31:36.966 A:middle
so Swift can infer
that the return type

00:31:36.966 --> 00:31:39.076 A:middle
for this closure is Boolean,
so I don't really need

00:31:39.076 --> 00:31:41.236 A:middle
to have this here, which
means I don't have to have

00:31:41.236 --> 00:31:43.996 A:middle
that there either, and since
atomic elements is an array

00:31:43.996 --> 00:31:46.656 A:middle
of atomic elements, I
don't have to specify

00:31:46.656 --> 00:31:48.566 A:middle
that an atomic element
is being passed in,

00:31:48.566 --> 00:31:49.476 A:middle
so I can get rid of that.

00:31:49.476 --> 00:31:51.676 A:middle
And since I don't have any
parameters, I don't have

00:31:51.676 --> 00:31:53.916 A:middle
to separate the parameters from
the code, so I don't need the

00:31:53.916 --> 00:31:57.336 A:middle
in keyword, which means I can
get rid of that and just tidy

00:31:57.336 --> 00:32:00.656 A:middle
up the spacing a bit, and I end

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:57.336 --> 00:32:00.656 A:middle
up the spacing a bit, and I end

00:32:00.656 --> 00:32:04.926 A:middle
up getting something
that looks like this.

00:32:05.126 --> 00:32:10.726 A:middle
And because the last argument to
the filter method is a closure

00:32:10.726 --> 00:32:13.496 A:middle
in itself, we can make it
into a trailing closure

00:32:13.496 --> 00:32:14.806 A:middle
and just get rid
of the parentheses,

00:32:15.666 --> 00:32:17.866 A:middle
so we get that looking
more like this.

00:32:18.436 --> 00:32:19.676 A:middle
Now the only trouble is

00:32:19.676 --> 00:32:22.006 A:middle
that there's no symbol
declared called atomic element

00:32:22.546 --> 00:32:23.506 A:middle
because I removed it.

00:32:24.246 --> 00:32:28.296 A:middle
But I'm passing in one item into
this filter closure every time,

00:32:28.296 --> 00:32:32.056 A:middle
and I can reference
that argument like that.

00:32:33.176 --> 00:32:34.176 A:middle
That's exactly the same code.

00:32:34.176 --> 00:32:36.916 A:middle
If you were missing Perl,
well, now we have this.

00:32:37.516 --> 00:32:43.946 A:middle
[ Applause ]

00:32:44.446 --> 00:32:45.626 A:middle
So now we can do a check.

00:32:45.626 --> 00:32:48.126 A:middle
Let's just put in a
letter N, and great.

00:32:48.846 --> 00:32:50.726 A:middle
Now I have the elements, but
they are not actually sorting

00:32:50.726 --> 00:32:51.456 A:middle
in the right direction.

00:32:51.736 --> 00:32:53.096 A:middle
Actually, they are
not sorting at all.

00:32:53.096 --> 00:32:55.326 A:middle
So, let's just quickly
go ahead and add a sort.

00:32:55.326 --> 00:32:56.766 A:middle
I am just going to
chain it to the end

00:32:56.766 --> 00:32:57.756 A:middle
of this existing closure.

00:32:58.376 --> 00:33:01.716 A:middle
Dot sort. Now, in this case,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.376 --> 00:33:01.716 A:middle
Dot sort. Now, in this case,

00:33:01.716 --> 00:33:04.786 A:middle
I could double-click this blue
token, have it expand out,

00:33:04.786 --> 00:33:08.076 A:middle
and there's many ways we can
compare strings, like case

00:33:08.076 --> 00:33:10.316 A:middle
and sensitive compare, localized
compare, so forth and so on.

00:33:10.856 --> 00:33:14.796 A:middle
But because I know that in
a sort I am given one atomic

00:33:14.796 --> 00:33:16.956 A:middle
element, and then I'm given
the other atomic element,

00:33:16.956 --> 00:33:20.156 A:middle
and I only have to specify which
one comes before the other,

00:33:20.386 --> 00:33:23.006 A:middle
or if the first one comes before
the other, I can just write

00:33:23.006 --> 00:33:26.056 A:middle
out a closure myself, first of
all recognizing that I am going

00:33:26.056 --> 00:33:27.806 A:middle
to have two atomic
elements passed in.

00:33:28.696 --> 00:33:31.816 A:middle
So I have the first one, I
am going to check its name,

00:33:31.816 --> 00:33:32.836 A:middle
and I have the second one.

00:33:32.836 --> 00:33:33.816 A:middle
I am going to check its name.

00:33:34.426 --> 00:33:38.116 A:middle
That in itself is
not a comparison.

00:33:38.966 --> 00:33:41.626 A:middle
However, in Swift,
we've overloaded many

00:33:41.626 --> 00:33:43.826 A:middle
of the standard operators, like
greater than and less than,

00:33:43.826 --> 00:33:45.906 A:middle
so they actually work on types
that you might not expect them

00:33:45.906 --> 00:33:47.276 A:middle
to work on, like strings.

00:33:47.826 --> 00:33:51.016 A:middle
That's a string comparison.

00:33:51.656 --> 00:33:57.256 A:middle
I'll run it again.

00:33:57.476 --> 00:34:01.296 A:middle
Search on letter N, and now
it's being properly sorted.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:57.476 --> 00:34:01.296 A:middle
Search on letter N, and now
it's being properly sorted.

00:34:01.296 --> 00:34:03.476 A:middle
It's filtered and sorted
all in just one line.

00:34:03.476 --> 00:34:04.646 A:middle
I can check again.

00:34:04.646 --> 00:34:05.986 A:middle
Let's search on S.

00:34:06.656 --> 00:34:07.986 A:middle
We have some really
important elements,

00:34:08.696 --> 00:34:09.426 A:middle
like Swiftonium [laughter].

00:34:11.045 --> 00:34:11.926 A:middle
Very important.

00:34:13.585 --> 00:34:17.616 A:middle
Okay. Let's come back.

00:34:17.616 --> 00:34:20.126 A:middle
So in this section, we
implemented filtering

00:34:20.746 --> 00:34:23.096 A:middle
of our table view by using
Swift's filter method.

00:34:23.806 --> 00:34:27.166 A:middle
And then we sorted
it using sort and got

00:34:27.166 --> 00:34:28.676 A:middle
to see an overloaded operator,

00:34:28.676 --> 00:34:29.936 A:middle
that being the less
than/greater than.

00:34:30.536 --> 00:34:33.116 A:middle
The next feature and final
feature that I want to add

00:34:33.116 --> 00:34:36.466 A:middle
to this app is simply one that
lets me select multiple rows

00:34:36.466 --> 00:34:39.076 A:middle
and then it adds them up to give
me the sum of the atomic weights

00:34:39.076 --> 00:34:40.045 A:middle
for the selected elements.

00:34:40.275 --> 00:34:41.286 A:middle
It looks kinds of like this.

00:34:41.656 --> 00:34:44.036 A:middle
We start off with
the table view.

00:34:44.735 --> 00:34:47.226 A:middle
The nav bar at the top is
saying select two or more items.

00:34:48.166 --> 00:34:50.416 A:middle
You select two or more
items, and then the nav bar

00:34:50.416 --> 00:34:52.366 A:middle
at the top specifies the
sum of their weights.

00:34:52.936 --> 00:34:56.826 A:middle
To do this, I start off
with my content array.

00:34:56.826 --> 00:34:58.556 A:middle
That's all the atomic
elements that I have,

00:34:58.596 --> 00:35:00.456 A:middle
those are all the ones that are
displayed in the table view.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:58.596 --> 00:35:00.456 A:middle
those are all the ones that are
displayed in the table view.

00:35:00.876 --> 00:35:05.256 A:middle
But what I want is just the
selected atomic elements.

00:35:06.286 --> 00:35:08.936 A:middle
So to get that, I can't
go to the table view

00:35:08.936 --> 00:35:12.506 A:middle
and ask the table view for
the array of selected items.

00:35:12.676 --> 00:35:16.486 A:middle
I can only ask it for the
index paths for selected items.

00:35:16.726 --> 00:35:21.126 A:middle
So the table view will give
me an array of the index paths

00:35:21.126 --> 00:35:22.116 A:middle
for the selected items.

00:35:22.336 --> 00:35:24.166 A:middle
I can query those index
paths to get the row.

00:35:24.166 --> 00:35:27.236 A:middle
I can correlate that with the
backing array, the content.

00:35:27.606 --> 00:35:30.536 A:middle
And from that, produce
the selected elements.

00:35:31.216 --> 00:35:32.346 A:middle
Basically, it's this.

00:35:32.926 --> 00:35:33.986 A:middle
We make a new array.

00:35:34.276 --> 00:35:35.926 A:middle
We loop through the index paths.

00:35:36.116 --> 00:35:38.156 A:middle
And then we go back
to content and we pull

00:35:38.156 --> 00:35:40.766 A:middle
out the corresponding
atomic element

00:35:40.766 --> 00:35:42.946 A:middle
for the current index
paths' row.

00:35:43.386 --> 00:35:45.676 A:middle
If you've been accustomed
to writing code like this,

00:35:45.676 --> 00:35:48.306 A:middle
you can do the same
thing in Swift with this.

00:35:49.256 --> 00:35:50.026 A:middle
It's the map function.

00:35:50.986 --> 00:35:53.206 A:middle
The important part is still
there, it's the part in orange.

00:35:53.506 --> 00:35:55.086 A:middle
Just all the the extra
infrastructure that's

00:35:55.086 --> 00:35:56.346 A:middle
around it has been removed.

00:35:56.716 --> 00:36:02.326 A:middle
Next, once I have an array
of all the selected items,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:56.716 --> 00:36:02.326 A:middle
Next, once I have an array
of all the selected items,

00:36:02.726 --> 00:36:05.616 A:middle
I want to add up
their atomic weights.

00:36:06.086 --> 00:36:09.716 A:middle
So to do that, I might
traditionally use a foreign loop

00:36:09.906 --> 00:36:12.116 A:middle
where I first declare a
variable that's set to zero,

00:36:12.116 --> 00:36:15.206 A:middle
then I just iterate through the
selected objects and just add

00:36:15.206 --> 00:36:18.196 A:middle
to that, in this
case, D, their weight.

00:36:18.726 --> 00:36:20.256 A:middle
If you are accustomed to
doing this kind of thing

00:36:20.256 --> 00:36:22.496 A:middle
with a for-in loop, you can
do the same thing in Swift,

00:36:23.136 --> 00:36:26.156 A:middle
with a reduce, where we set
the initial value as zero,

00:36:26.156 --> 00:36:27.496 A:middle
and then we just
patch in a closure

00:36:27.496 --> 00:36:30.376 A:middle
that takes the initial value,
that's zero, and then appends

00:36:30.376 --> 00:36:32.946 A:middle
to it the next item being
passed in, adds them all up.

00:36:33.856 --> 00:36:36.516 A:middle
Let me just show you the code,
though I will give you a preview

00:36:36.956 --> 00:36:37.896 A:middle
that we can do the whole thing

00:36:37.896 --> 00:36:39.636 A:middle
with just a single
line of code like this.

00:36:40.826 --> 00:36:42.496 A:middle
One of the graphic
designers was asking me

00:36:42.496 --> 00:36:43.376 A:middle
when he saw the presentation,

00:36:43.376 --> 00:36:44.476 A:middle
can you make that
fit on one line?

00:36:45.466 --> 00:36:46.576 A:middle
It's like, not really, no,

00:36:46.656 --> 00:36:47.906 A:middle
I don't think you
could see it then.

00:36:48.476 --> 00:36:52.786 A:middle
Let's switch over to
the demo computer.

00:36:57.216 --> 00:37:04.956 A:middle
Alright. So here's the
function that does all the work.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.216 --> 00:37:04.956 A:middle
Alright. So here's the
function that does all the work.

00:37:04.956 --> 00:37:07.776 A:middle
I start off by ensuring
that I have more

00:37:07.776 --> 00:37:08.766 A:middle
than two items selected.

00:37:09.126 --> 00:37:11.836 A:middle
So you can see I am using a
where clause on an if to say

00:37:11.836 --> 00:37:13.946 A:middle
that as long as the selected
items count as greater or equal

00:37:13.946 --> 00:37:15.796 A:middle
to two, continue
executing this code.

00:37:17.116 --> 00:37:19.166 A:middle
Then I use map so I can
actually get the objects

00:37:19.166 --> 00:37:21.756 A:middle
that are selected by the table
view, not the index paths.

00:37:22.656 --> 00:37:24.976 A:middle
And then use reduce
to add it all up.

00:37:24.976 --> 00:37:27.616 A:middle
And then in the end just passed
it through a number formatter

00:37:27.616 --> 00:37:28.556 A:middle
and stick it up in the title.

00:37:29.106 --> 00:37:30.816 A:middle
If you wanted to see the
same thing on a single line,

00:37:30.816 --> 00:37:34.046 A:middle
it would look like that.

00:37:34.266 --> 00:37:40.256 A:middle
When I run the program,
it adds them all

00:37:40.256 --> 00:37:40.996 A:middle
up and puts them up top.

00:37:42.086 --> 00:37:45.426 A:middle
That's showing map and reduce
to make it easier to work

00:37:45.426 --> 00:37:56.136 A:middle
with items that back
a table view.

00:37:56.376 --> 00:38:01.196 A:middle
Alright. In summary, I'm hoping
you will see that there's a lot

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:56.376 --> 00:38:01.196 A:middle
Alright. In summary, I'm hoping
you will see that there's a lot

00:38:01.196 --> 00:38:03.376 A:middle
of advantages to
incorporating Swift,

00:38:03.376 --> 00:38:05.496 A:middle
even with your existing
Objective-C projects.

00:38:05.976 --> 00:38:08.866 A:middle
It's not hard to do, and
there's a lot of benefits to it.

00:38:08.866 --> 00:38:10.946 A:middle
You don't have to throw
away any existing code,

00:38:11.046 --> 00:38:13.986 A:middle
and you get to use these
modern and powerful techniques,

00:38:14.096 --> 00:38:17.226 A:middle
like reducing and maps and these
powerful structs, so forth.

00:38:18.466 --> 00:38:20.206 A:middle
For more information,
come see us in the labs,

00:38:20.296 --> 00:38:22.626 A:middle
check out our documentation,
check out the Developer Forums,

00:38:22.936 --> 00:38:24.166 A:middle
or send Stefan an email.

00:38:24.226 --> 00:38:25.136 A:middle
He loves to get mail.

00:38:25.136 --> 00:38:26.526 A:middle
You can just tell him the
conference is going well,

00:38:26.526 --> 00:38:27.086 A:middle
that would be fine.

00:38:27.716 --> 00:38:28.856 A:middle
And with that, I'd
like to thank you,

00:38:28.856 --> 00:38:29.756 A:middle
and have a great conference.

00:38:31.516 --> 00:38:45.430 A:middle
[ Applause ]

