1
00:00:19,016 --> 00:00:20,046
[Applause]


2
00:00:20,046 --> 00:00:20,796
>> NAT HILLARD: Good
morning, everyone.


3
00:00:24,076 --> 00:00:26,596
Now, good morning, or
should I say, zao an,


4
00:00:27,046 --> 00:00:28,916
dobry den, buenas dias.


5
00:00:29,156 --> 00:00:30,276
My name is Nat Hillard.


6
00:00:30,666 --> 00:00:33,486
Today I will be going over what
is new in internationalization.


7
00:00:34,026 --> 00:00:36,176
I will be going over new
APIs that we have introduced,


8
00:00:36,286 --> 00:00:39,156
as well as improvements to
existing APIs that you can use


9
00:00:39,156 --> 00:00:41,796
in your apps to make them ready
for use all around the world.


10
00:00:42,896 --> 00:00:45,276
To begin with, this
is the Earth.


11
00:00:46,146 --> 00:00:48,506
There are over 7 billion
people on this Earth.


12
00:00:49,126 --> 00:00:51,496
To these 7 billion
people, Apple has sold


13
00:00:51,496 --> 00:00:54,486
over 1 billion iOS devices.


14
00:00:54,976 --> 00:00:56,256
Additionally, our install base


15
00:00:56,256 --> 00:00:58,516
for Mac OS X is 80
million devices.


16
00:00:59,126 --> 00:01:02,956
We have over 450 physical stores
located all around the world


17
00:01:03,526 --> 00:01:06,756
and your apps, numbering
1.4 million or more,


18
00:01:07,236 --> 00:01:09,096
have gone from developers
just like you,


19
00:01:09,516 --> 00:01:11,106
have gone to users
all around the world.


20
00:01:12,096 --> 00:01:16,126
So, that's a lot of numbers, but
if you only take away one number


21
00:01:16,126 --> 00:01:18,046
from today's presentation,
let it be this.


22
00:01:19,246 --> 00:01:23,416
69%. 69% of Apple's
current revenue comes


23
00:01:23,416 --> 00:01:24,526
from international markets.


24
00:01:24,836 --> 00:01:25,716
Now this is huge.


25
00:01:25,716 --> 00:01:27,856
To see this in perspective,
let's look at a graph.


26
00:01:28,806 --> 00:01:31,866
Over two-thirds of Apple's
revenue is coming from places


27
00:01:31,866 --> 00:01:33,026
that are not the United States.


28
00:01:33,676 --> 00:01:35,826
Users in these areas have
different expectations


29
00:01:35,826 --> 00:01:37,556
about how they'll
interact with your app.


30
00:01:37,756 --> 00:01:39,596
These include linguistic
differences,


31
00:01:39,676 --> 00:01:41,576
regional differences,
and cultural differences


32
00:01:41,576 --> 00:01:42,606
that you will have
to keep in mind.


33
00:01:42,606 --> 00:01:44,596
Now let's break this
down even more.


34
00:01:46,226 --> 00:01:49,456
Interestingly, here,
is that a combined 41%


35
00:01:49,456 --> 00:01:51,466
of your users are coming
from China and Japan.


36
00:01:52,346 --> 00:01:53,796
Now, I think it's a
common misconception


37
00:01:53,796 --> 00:01:56,606
that internationalizing your app
means making it work in Europe.


38
00:01:56,996 --> 00:02:00,096
Now, indeed, this is important,
but additionally you have


39
00:02:00,146 --> 00:02:01,616
to keep in mind that
users in China


40
00:02:02,326 --> 00:02:04,216
and Japan present
additional challenges.


41
00:02:04,956 --> 00:02:07,756
That is to say, they don't
use an alphabetic script.


42
00:02:07,946 --> 00:02:09,636
There are no spaces
to separate words.


43
00:02:09,636 --> 00:02:11,196
And, additionally, what may work


44
00:02:11,196 --> 00:02:14,686
in your UI will be often a lot
terser in Chinese and Japanese.


45
00:02:15,446 --> 00:02:16,486
So, the good news, here,


46
00:02:16,486 --> 00:02:18,706
is if you use our
APIs we will help you


47
00:02:19,606 --> 00:02:21,796
to internationalize your
app easily and effortlessly.


48
00:02:22,796 --> 00:02:25,166
So, today we will be going
over four major areas


49
00:02:25,166 --> 00:02:28,596
that you'll have to think
about: localization, formatting,


50
00:02:29,056 --> 00:02:30,376
handling text, and layout.


51
00:02:31,306 --> 00:02:35,616
So, to begin with, let's
discuss localization.


52
00:02:36,746 --> 00:02:37,956
Now, by localization, I mean


53
00:02:37,956 --> 00:02:40,776
to say making your app speak
your customer's language.


54
00:02:41,356 --> 00:02:42,866
I mean this both
literally, in the sense


55
00:02:42,866 --> 00:02:44,626
of translating the words
that appear on the screen,


56
00:02:44,916 --> 00:02:46,116
as well as more metaphorically,


57
00:02:46,536 --> 00:02:49,016
translating linguistic concepts
behind the things you wish


58
00:02:49,016 --> 00:02:49,506
to translate.


59
00:02:50,546 --> 00:02:52,886
So, it might be helpful
actually to begin this section


60
00:02:52,886 --> 00:02:55,486
with taking a look at how users
interact with these settings


61
00:02:55,526 --> 00:02:58,306
on our operating systems.


62
00:02:58,306 --> 00:03:01,146
On the left, we have OS
X, on the right, iOS.


63
00:03:01,406 --> 00:03:03,036
These are the language and
region preference panes.


64
00:03:03,626 --> 00:03:06,296
So, on the left-hand side
here, on the OS X screenshot,


65
00:03:06,296 --> 00:03:07,786
you will see the
preferred languages list.


66
00:03:08,396 --> 00:03:09,446
Now, in fact, it's
important here


67
00:03:09,446 --> 00:03:11,126
that this is an ordered
list of languages.


68
00:03:11,596 --> 00:03:13,596
Users can add multiple
languages and,


69
00:03:13,596 --> 00:03:15,626
if a given language is not
available for the display


70
00:03:15,626 --> 00:03:18,006
of your UI, it will
actually fall back


71
00:03:18,056 --> 00:03:18,856
to the language below it.


72
00:03:19,706 --> 00:03:22,246
Here, for instance, the
user has chosen Swiss German


73
00:03:22,246 --> 00:03:23,236
as their primary language.


74
00:03:23,666 --> 00:03:25,196
But Swiss German is,
in fact, not a language


75
00:03:25,196 --> 00:03:26,126
that we localize into.


76
00:03:26,576 --> 00:03:28,686
Therefore, for this UI, we
have fallen back to English.


77
00:03:29,266 --> 00:03:30,996
Now, these fall backs are,
in fact, somewhat common,


78
00:03:31,046 --> 00:03:32,026
so you will have
to think about this


79
00:03:32,026 --> 00:03:34,136
from a developer
perspective as well.


80
00:03:34,296 --> 00:03:35,596
So, in addition, though,


81
00:03:35,596 --> 00:03:37,496
to the language your
app is displayed in,


82
00:03:37,866 --> 00:03:39,566
we have additional
regional preferences.


83
00:03:40,476 --> 00:03:42,226
These are off to the
right-hand side of OS X


84
00:03:42,226 --> 00:03:44,536
and a little further down
on the iOS screenshot.


85
00:03:45,526 --> 00:03:48,366
Now, these actually inform
the way the given units,


86
00:03:48,756 --> 00:03:51,216
as well as times
and calendar dates,


87
00:03:51,246 --> 00:03:52,656
display in a given locale.


88
00:03:53,556 --> 00:03:58,406
So, that is to say that
it's not simply the language


89
00:03:58,406 --> 00:03:59,416
that you are translating into,


90
00:03:59,686 --> 00:04:02,126
but often the concepts
behind the things you wish


91
00:04:02,126 --> 00:04:02,576
to translate.


92
00:04:03,586 --> 00:04:05,576
Now, for a lot more information
about the differences


93
00:04:05,576 --> 00:04:07,906
between the preferred language
and the locale settings,


94
00:04:08,536 --> 00:04:10,506
do check out last year's
talk, "Advanced Topics


95
00:04:10,506 --> 00:04:11,996
in Internationalization,"
which goes


96
00:04:11,996 --> 00:04:13,136
into a lot more detail
about this.


97
00:04:14,176 --> 00:04:16,846
So, we provide a lot of
settings out of the box,


98
00:04:16,846 --> 00:04:19,236
but we additionally allow users
to customize these settings


99
00:04:19,346 --> 00:04:21,026
if they have individual
preferences.


100
00:04:21,685 --> 00:04:24,896
So, new in iOS 9 and El
Capitan, we have the ability


101
00:04:24,896 --> 00:04:28,516
to customize your number
system, as you can see here.


102
00:04:29,226 --> 00:04:31,796
So let's say we have a user
who is an Urdu speaker.


103
00:04:32,396 --> 00:04:34,486
They have chosen as their
primary language, Urdu,


104
00:04:34,556 --> 00:04:36,406
and it has therefore
fallen back to English


105
00:04:37,356 --> 00:04:40,486
in our operating
system display language.


106
00:04:41,216 --> 00:04:45,116
By default this user would
receive the standard Arabic


107
00:04:45,116 --> 00:04:45,796
style numerals.


108
00:04:47,466 --> 00:04:52,986
We allow, though, in iOS 9
and OS X, El Capitan, to go in


109
00:04:52,986 --> 00:04:54,146
and customize these settings


110
00:04:54,196 --> 00:04:56,086
to override the existing
numeric system.


111
00:04:56,376 --> 00:04:57,916
A lot of people don't
realize, in fact,


112
00:04:57,916 --> 00:04:59,836
there are multiple numeric
systems in use around the world.


113
00:05:00,436 --> 00:05:02,026
On the top we have
the Arabic system


114
00:05:02,086 --> 00:05:04,846
and below we have the so-called
Perso-Arabic numeral system,


115
00:05:04,846 --> 00:05:06,046
commonly in use in
the Middle East.


116
00:05:06,646 --> 00:05:08,066
So a user can choose
this setting,


117
00:05:08,486 --> 00:05:10,236
and it has interesting
repercussions throughout the


118
00:05:10,236 --> 00:05:10,816
operating system.


119
00:05:11,766 --> 00:05:13,516
Here, for instance, we
have the Weather app.


120
00:05:13,796 --> 00:05:16,266
Now, without any additional
changes on the part


121
00:05:16,266 --> 00:05:19,306
of the developer, all they have
called is 'localized string


122
00:05:19,306 --> 00:05:22,816
with format' or the NS
number formatter APIs;


123
00:05:22,816 --> 00:05:25,006
they have gotten these
numeric changes for free.


124
00:05:25,626 --> 00:05:27,896
On the left, we have a user
using the Arabic numeral system,


125
00:05:28,186 --> 00:05:29,946
and on the right, the
Perso-Arabic numerals.


126
00:05:30,786 --> 00:05:32,466
We noticed that every,
every instance


127
00:05:32,466 --> 00:05:36,556
of Arabic numerals have changed
in this UI, including, in fact,


128
00:05:36,646 --> 00:05:38,106
the timestamp at the
top of the screen.


129
00:05:39,456 --> 00:05:41,906
So, this is interesting,
as a developer,


130
00:05:42,176 --> 00:05:43,266
simply calling 'localized string


131
00:05:43,266 --> 00:05:44,876
of format' you will get
this behavior for free.


132
00:05:45,866 --> 00:05:48,986
Now, in addition to the
language that the user is seeing


133
00:05:48,986 --> 00:05:51,636
on the screen, the user
is also inputting text


134
00:05:51,636 --> 00:05:52,536
into your application.


135
00:05:54,056 --> 00:05:57,996
New in iOS 9 we add five new
keyboards for Indic languages.


136
00:05:59,016 --> 00:06:01,106
On the right, here, you
see the Telugu keyboard.


137
00:06:02,016 --> 00:06:04,626
Now, additionally, we've
added predictive typing


138
00:06:04,626 --> 00:06:06,716
for four existing
languages: Korean,


139
00:06:06,836 --> 00:06:08,586
Mexican Spanish,
Russian, and Turkish.


140
00:06:09,596 --> 00:06:11,926
Now, from a developer
perspective, it's interesting


141
00:06:12,206 --> 00:06:13,086
to realize that, in fact,


142
00:06:13,086 --> 00:06:15,736
often these characters are not
what we would typically call


143
00:06:15,736 --> 00:06:16,166
a character.


144
00:06:16,726 --> 00:06:19,166
Here in the Telugu keyboard we
have combining mark characters,


145
00:06:19,456 --> 00:06:21,276
that, in fact, will combine
with other characters


146
00:06:21,276 --> 00:06:22,696
to represent a single
visible unit.


147
00:06:23,596 --> 00:06:24,746
So, we'll get into that
a little bit later.


148
00:06:26,226 --> 00:06:29,746
Now, so, we have seen how
users can change the settings


149
00:06:29,746 --> 00:06:30,576
on your operating system.


150
00:06:31,096 --> 00:06:33,846
But, how then do localizers
translate the strings


151
00:06:33,916 --> 00:06:34,936
that users are seeing?


152
00:06:35,816 --> 00:06:39,526
The primary interface for
localizers is the .strings file.


153
00:06:40,236 --> 00:06:42,016
The .strings file
has this format.


154
00:06:42,186 --> 00:06:45,406
First you have a comment,
in C-style comment syntax,


155
00:06:45,756 --> 00:06:49,006
followed by the development
language on the left-hand side,


156
00:06:49,006 --> 00:06:50,476
and the target language
on the right.


157
00:06:51,056 --> 00:06:54,906
Here we have a German.strings
file.


158
00:06:54,906 --> 00:06:57,116
Now, .strings files are
stored in lproj directories


159
00:06:57,116 --> 00:06:59,546
of your bundle, within
the resources directory.


160
00:07:00,176 --> 00:07:03,596
English has its own .strings
files, as, here, does German.


161
00:07:04,416 --> 00:07:07,486
Now, additionally, we allow
you, and we have allowed you


162
00:07:07,486 --> 00:07:09,976
since XCode 6, to
export localizations


163
00:07:09,976 --> 00:07:12,136
in the commonly used
XLIFF file format.


164
00:07:12,586 --> 00:07:15,536
You can then re-import those as
strings files into your project.


165
00:07:16,036 --> 00:07:17,616
But for a lot more
information about this,


166
00:07:17,616 --> 00:07:19,456
I would encourage you to
check out last year's talk,


167
00:07:19,516 --> 00:07:21,106
"Localizing with XCode 6."


168
00:07:22,206 --> 00:07:24,956
So, we have seen how users
are changing these settings.


169
00:07:25,526 --> 00:07:28,576
We have seen how localizers
can then translate the strings


170
00:07:28,576 --> 00:07:30,196
that you see on your
screen, but, then,


171
00:07:30,356 --> 00:07:32,356
how do you as a developer
make use of these settings?


172
00:07:34,066 --> 00:07:36,136
Here's where NSLocalizedString
comes into play.


173
00:07:37,016 --> 00:07:38,836
In Objective-C, this is a macro.


174
00:07:39,506 --> 00:07:41,936
In Swift, we promoted this
to a first class function.


175
00:07:42,636 --> 00:07:45,246
It takes five parameters, three
of which have default values.


176
00:07:45,776 --> 00:07:47,296
Interestingly, in
Swift, we've made it


177
00:07:47,296 --> 00:07:49,836
such that the comment
argument is non-optional.


178
00:07:50,606 --> 00:07:53,096
This is really emphasizing
this is a critical argument.


179
00:07:53,136 --> 00:07:54,986
It provides context
for your translators.


180
00:07:55,676 --> 00:07:58,486
A given word may be
ambiguous in certain contexts


181
00:07:58,486 --> 00:08:01,736
and this comment parameter will
allow you to customize that.


182
00:08:02,616 --> 00:08:04,866
So, the key is the string
you wish to translate,


183
00:08:05,256 --> 00:08:07,266
and the comment is the
comment explaining it.


184
00:08:07,876 --> 00:08:10,046
Now, this works for simple
localized strings, but,


185
00:08:10,046 --> 00:08:12,006
additionally, we allow
you to get a localized,


186
00:08:12,076 --> 00:08:13,976
formatted string,
that is to say,


187
00:08:13,976 --> 00:08:16,116
a string with variable
arguments to be populated.


188
00:08:16,966 --> 00:08:19,326
So for that, you call
'localized string with format,


189
00:08:19,716 --> 00:08:24,276
passing in a format string with
certain format arguments as well


190
00:08:24,276 --> 00:08:26,576
as the arguments to populate the
variables within that string.


191
00:08:26,576 --> 00:08:29,936
And in fact, it's actually very
common to use these together.


192
00:08:30,456 --> 00:08:32,566
You call 'localized string
with format' on the result


193
00:08:32,566 --> 00:08:34,456
of having called
NSLocalizedString.


194
00:08:36,046 --> 00:08:37,525
Now, to see what this
looks like in action,


195
00:08:37,525 --> 00:08:42,196
it might be helpful
to give a brief demo.


196
00:08:42,905 --> 00:08:46,446
So, let's say we wish to
translate the string location:X.


197
00:08:47,056 --> 00:08:49,406
Now, let's also say that
we have a variable location


198
00:08:49,406 --> 00:08:50,966
which has been populated
by our translators


199
00:08:51,206 --> 00:08:52,766
to be the user's
physical location.


200
00:08:54,086 --> 00:08:55,506
Here is what our strings
files may look like.


201
00:08:56,056 --> 00:08:58,506
On the left-hand side is
the string to be translated,


202
00:08:58,506 --> 00:09:00,036
and on the right is
the translated variant.


203
00:09:01,146 --> 00:09:03,316
We see here that in fact the
translated variant still has a


204
00:09:03,316 --> 00:09:04,006
variable string.


205
00:09:04,496 --> 00:09:06,536
Percent add is meant to be
filled with a string variable.


206
00:09:07,766 --> 00:09:11,296
So, this works in English -- we
have location, San Francisco --


207
00:09:11,806 --> 00:09:12,756
as well as in Japanese.


208
00:09:13,196 --> 00:09:14,186
This is the equivalent string.


209
00:09:15,446 --> 00:09:17,416
So, now that you know this,


210
00:09:18,236 --> 00:09:19,706
you may have some
certain assumptions


211
00:09:19,706 --> 00:09:20,336
that come into your head.


212
00:09:21,196 --> 00:09:24,216
One being that the arguments as
presented to 'localized string


213
00:09:24,216 --> 00:09:27,076
with format' will be in the same
order that they are in English.


214
00:09:27,926 --> 00:09:29,286
Now, we will see
why this is wrong.


215
00:09:29,726 --> 00:09:32,356
We call 'localized
string with format' here


216
00:09:32,356 --> 00:09:33,896
on the result of
NSLocalizedString.


217
00:09:34,026 --> 00:09:36,826
We wish to translate
the string 'copy X is Y'


218
00:09:37,196 --> 00:09:39,656
where X is the user name and Y
is the thing we wish to copy.


219
00:09:40,436 --> 00:09:41,926
Here, we're passing
"hairForce1,"


220
00:09:42,546 --> 00:09:44,786
which is Craig Federighi's
chosen InstaMessage handle,


221
00:09:45,316 --> 00:09:46,066
and "photos."


222
00:09:46,616 --> 00:09:49,196
In our lproj, in
our .strings files


223
00:09:49,196 --> 00:09:52,136
within our different lprojs,
a developer may assume


224
00:09:52,136 --> 00:09:53,926
that the arguments will
appear in the same order.


225
00:09:54,756 --> 00:09:55,896
While this may work for English,


226
00:09:56,596 --> 00:09:57,926
in fact it doesn't
work for German.


227
00:09:59,176 --> 00:10:01,236
These arguments need
to be reversed


228
00:10:01,276 --> 00:10:02,176
to make sense in German.


229
00:10:02,916 --> 00:10:05,006
So, here is where a
localizer can actually go in


230
00:10:05,416 --> 00:10:07,476
and add these positional
formatting arguments.


231
00:10:07,756 --> 00:10:09,636
This allows what was
formerly the second argument


232
00:10:09,716 --> 00:10:11,236
to become the first,
and vice versa.


233
00:10:12,136 --> 00:10:17,046
So, here, then, a developer
doesn't have to do anything.


234
00:10:17,276 --> 00:10:19,696
They call 'localized string with
format' and NSLocalizedString.


235
00:10:20,326 --> 00:10:22,066
But, it's important
to keep in mind


236
00:10:22,066 --> 00:10:23,566
from a developer perspective


237
00:10:23,596 --> 00:10:26,676
that what you think may be the
first character may not be.


238
00:10:27,206 --> 00:10:29,766
So if you have an operation
that operates on the assumption


239
00:10:29,766 --> 00:10:32,076
that the arguments will come in
in the same order, you may want


240
00:10:32,156 --> 00:10:33,266
to rethink that assumption.


241
00:10:34,906 --> 00:10:38,836
So, now we know how the
.strings files are stored and in


242
00:10:38,836 --> 00:10:39,906
which directories
they're stored.


243
00:10:40,616 --> 00:10:43,466
But at this point
you may be tempted


244
00:10:43,466 --> 00:10:45,356
to do something like this.


245
00:10:45,656 --> 00:10:47,776
You set the language
variable to the first object


246
00:10:47,776 --> 00:10:49,006
in your preferred
language's array.


247
00:10:49,526 --> 00:10:51,576
This corresponds to the
UI element we saw before,


248
00:10:51,576 --> 00:10:52,746
the preferredLanguages list.


249
00:10:53,446 --> 00:10:56,986
Additionally, you append
the suffix lproj to this,


250
00:10:57,316 --> 00:10:58,726
and you call a 'path
for resource.'


251
00:10:58,966 --> 00:11:02,856
Let's say we wish to
localize a stop sign graphic.


252
00:11:03,726 --> 00:11:05,776
So, here, let's say, though,


253
00:11:05,776 --> 00:11:09,456
that our individual bundle
only has an es.lproj,


254
00:11:09,456 --> 00:11:10,376
corresponding to Spanish.


255
00:11:11,006 --> 00:11:12,826
But let's say our user's
preferred language is


256
00:11:12,826 --> 00:11:13,646
Mexican Spanish.


257
00:11:14,296 --> 00:11:18,056
Using this particular technique,
the user will get nothing back.


258
00:11:18,576 --> 00:11:19,646
Now, why is this?


259
00:11:20,126 --> 00:11:22,286
Well, it's because we are
not using the standard


260
00:11:22,286 --> 00:11:23,346
NSBundle APIs.


261
00:11:23,846 --> 00:11:26,376
NSBundle will intelligently
fall back


262
00:11:26,746 --> 00:11:29,946
to an available localization if
one is not currently available.


263
00:11:30,256 --> 00:11:32,496
So es-MX will fall back to es.


264
00:11:33,186 --> 00:11:35,706
Additionally, we have other
smart, fall back logics,


265
00:11:35,706 --> 00:11:39,026
such as en-IN, Indian
English, falling back to en-GB,


266
00:11:39,076 --> 00:11:42,216
the English as used
in the United Kingdom.


267
00:11:42,986 --> 00:11:46,996
So if you call, if
you call these APIs,


268
00:11:47,516 --> 00:11:49,776
you will get back the
appropriate resource


269
00:11:50,166 --> 00:11:51,336
with the appropriate fall backs.


270
00:11:51,646 --> 00:11:53,196
'Image for resource'
will give you the image.


271
00:11:53,666 --> 00:11:55,816
'Path for sound resource' will
give you the sound resource.


272
00:11:55,816 --> 00:11:57,416
And 'URL for resource,'
the most generic,


273
00:11:57,846 --> 00:12:00,196
will give you back any
given other file format.


274
00:12:01,526 --> 00:12:05,116
So, we are seeing, here, using
NSBundle APIs makes it easy


275
00:12:05,116 --> 00:12:06,606
to find the resources
you are interested in.


276
00:12:07,426 --> 00:12:10,056
And, additionally,
however, you may think


277
00:12:10,056 --> 00:12:12,496
that there are certain things
that can only be done in code.


278
00:12:13,586 --> 00:12:15,216
Now, how many of you have
written code like this?


279
00:12:15,716 --> 00:12:16,876
You wish to say, you wish


280
00:12:16,876 --> 00:12:19,176
to translate the string
'X days remaining.'


281
00:12:19,816 --> 00:12:22,146
We know that in English, if
there is only a single day,


282
00:12:22,436 --> 00:12:24,656
we use 'X day remaining,'
and if there are two


283
00:12:24,656 --> 00:12:26,586
or more we say 'blank
days remaining.'


284
00:12:27,356 --> 00:12:28,746
Now, this may work in English.


285
00:12:28,866 --> 00:12:30,546
It works for one
day and five days.


286
00:12:31,046 --> 00:12:33,736
But other languages
don't have the same logic


287
00:12:34,106 --> 00:12:37,046
about how things are pluralized,
given a given numeric component.


288
00:12:37,766 --> 00:12:41,026
Here in Russian, for instance,
we only have, we have one form


289
00:12:41,026 --> 00:12:44,246
for one, we also have
a form for few, many,


290
00:12:44,246 --> 00:12:45,316
and even more than many.


291
00:12:46,236 --> 00:12:48,726
So this simply doesn't
work for languages


292
00:12:48,726 --> 00:12:50,236
that have different
pluralization rules.


293
00:12:50,986 --> 00:12:51,846
Now, to help you with this,


294
00:12:52,446 --> 00:12:53,946
we provide the string
stick mechanism.


295
00:12:54,146 --> 00:12:55,726
This has been around
for a few releases


296
00:12:56,126 --> 00:12:57,466
but it's important
to emphasize here.


297
00:12:58,576 --> 00:13:01,826
A string stick file is
essentially a plist file


298
00:13:01,886 --> 00:13:03,046
that you store within
your project.


299
00:13:03,486 --> 00:13:04,746
It's a localized resource,


300
00:13:04,746 --> 00:13:06,556
so it falls within
your lproj directory


301
00:13:06,866 --> 00:13:08,336
for a given localization.


302
00:13:09,026 --> 00:13:10,696
As well, you have a given key.


303
00:13:10,916 --> 00:13:12,936
That key, in conjunction
with a numeric argument,


304
00:13:13,296 --> 00:13:15,696
will then have different
realizations, depending on what


305
00:13:15,696 --> 00:13:16,806
that numeric argument is.


306
00:13:17,506 --> 00:13:18,856
I realize this is a lot of text,


307
00:13:18,896 --> 00:13:21,536
especially when you add
the Russian component here.


308
00:13:23,546 --> 00:13:27,216
But, that is to say, you know
English has one form for one


309
00:13:27,356 --> 00:13:29,936
and a different form for
other, whereas Russian


310
00:13:29,986 --> 00:13:31,466
as one, few, many, and other.


311
00:13:32,256 --> 00:13:34,806
Now, to format string stick
files I would really encourage


312
00:13:34,806 --> 00:13:36,236
you to check out the
"Internationalization


313
00:13:36,236 --> 00:13:37,186
and Localization Guide."


314
00:13:37,596 --> 00:13:39,506
This goes into a lot more
detail than we can provide here


315
00:13:40,206 --> 00:13:42,316
as to how to format and create
these files on your own.


316
00:13:43,436 --> 00:13:46,026
So, using this is
in fact super easy


317
00:13:46,026 --> 00:13:47,046
from a developer perspective.


318
00:13:47,976 --> 00:13:50,046
Again, all you call is a
'localized string with format'


319
00:13:50,136 --> 00:13:51,636
on the result of
NSLocalizedString.


320
00:13:52,336 --> 00:13:54,036
The string that you are
passing in is the key


321
00:13:54,036 --> 00:13:55,126
to the string stick dictionary.


322
00:13:56,116 --> 00:13:59,366
Then you pass a numeric argument
which will fill in the variable,


323
00:13:59,366 --> 00:14:04,746
from the formatted string
which has been returned to you.


324
00:14:05,116 --> 00:14:07,786
Therefore, it will do the right
thing for English, for one, two,


325
00:14:07,786 --> 00:14:09,816
and five days, as
well as for Russian.


326
00:14:10,186 --> 00:14:11,646
We note here that
the form for two


327
00:14:11,646 --> 00:14:12,986
and five is different
in Russian.


328
00:14:14,726 --> 00:14:16,866
So, more on the topic
of string stick.


329
00:14:17,696 --> 00:14:21,806
We have a new mechanism in
iOS 9 to allow you to make use


330
00:14:21,806 --> 00:14:24,006
of string stick for formatting
strings on the screen.


331
00:14:24,906 --> 00:14:27,726
It's also in El Capitan,
I should say.


332
00:14:27,726 --> 00:14:31,176
So, to begin that, let's say,
this is a common problem,


333
00:14:31,176 --> 00:14:34,236
and in your InterfaceBuilder you
have set up a string to appear


334
00:14:34,236 --> 00:14:36,506
in the center of your screen:
"Welcome to the store!"


335
00:14:37,386 --> 00:14:42,226
This may work on an iPad Air,
but it may not work as well


336
00:14:42,226 --> 00:14:45,546
on an iPhone 6, and it may work
even worse on an iPod Touch.


337
00:14:45,886 --> 00:14:48,406
Now, one way to solve this
is in fact using auto layout


338
00:14:48,446 --> 00:14:49,426
and certain constraints.


339
00:14:49,426 --> 00:14:51,026
And, often, that's the
solution to this problem.


340
00:14:51,026 --> 00:14:51,776
We'll get into that later.


341
00:14:52,336 --> 00:14:54,946
But in fact, another
way to solve this is


342
00:14:54,946 --> 00:14:58,456
by using a new mechanism,
'variable width rule type.'


343
00:14:59,116 --> 00:15:01,006
This is an entry you can
add within your string stick


344
00:15:01,006 --> 00:15:03,146
which will provide different
realizations depending


345
00:15:03,146 --> 00:15:05,316
on the amount of space
available to you.


346
00:15:06,126 --> 00:15:09,746
On iOS, this refers to the M
width available on the screen,


347
00:15:10,146 --> 00:15:12,806
that is to say, the
visible width of a capital M


348
00:15:12,806 --> 00:15:13,906
in the standard system font.


349
00:15:14,716 --> 00:15:16,576
We have three different
goal posts here.


350
00:15:17,076 --> 00:15:19,106
We define if there
are 20Ms available,


351
00:15:19,566 --> 00:15:21,606
we present the string "Hi."


352
00:15:21,606 --> 00:15:23,566
If they are 25, we
give "Welcome."


353
00:15:23,566 --> 00:15:25,396
And if there are 50, we
say, "Welcome to the store!"


354
00:15:26,396 --> 00:15:28,836
To use this, again as the
developer, super easy.


355
00:15:29,266 --> 00:15:32,986
You call NSLocalizedString
on the key


356
00:15:32,986 --> 00:15:34,116
within your string stick file.


357
00:15:34,576 --> 00:15:36,376
Then you set it to
a UI label object.


358
00:15:37,946 --> 00:15:42,086
This works on iPad Air,
iPhone 6, and iPod Touch,


359
00:15:42,376 --> 00:15:43,736
and the realization
is different.


360
00:15:44,256 --> 00:15:46,656
Now, interestingly, we have
used English for these examples


361
00:15:47,056 --> 00:15:49,106
but in fact this has
important repercussions


362
00:15:49,106 --> 00:15:50,696
for international users as well.


363
00:15:51,236 --> 00:15:53,926
Often a translation into another
language will be much longer


364
00:15:54,026 --> 00:15:54,746
than that in English.


365
00:15:55,246 --> 00:15:56,786
So this allows you
to flexibly choose


366
00:15:56,786 --> 00:15:58,826
from among different
translations for a given string


367
00:15:59,126 --> 00:16:01,876
in a different language as well,
so this is a super useful tool.


368
00:16:03,536 --> 00:16:08,806
On OS X, things are a
little bit different.


369
00:16:08,806 --> 00:16:13,526
So, on OS X, likewise, you call
NSLocalizedString and you pass


370
00:16:13,526 --> 00:16:15,026
in the key to your
string stick dictionary.


371
00:16:15,716 --> 00:16:18,086
Then you call 'variant
fitting presentation width.'


372
00:16:18,696 --> 00:16:21,856
Now, on OS X, this
integer variable is


373
00:16:21,856 --> 00:16:24,626
in fact an arbitrary quantity.


374
00:16:25,036 --> 00:16:27,076
This can be anything, as
long as it's defined relative


375
00:16:27,076 --> 00:16:29,696
to other quantities
within the string stick.


376
00:16:29,696 --> 00:16:36,226
So calling this with an integer
value of 20 will yield "Hi," 25,


377
00:16:36,256 --> 00:16:38,306
"Welcome," and 50,
"Welcome to the store!"


378
00:16:39,096 --> 00:16:42,206
So, in general then we have
made it a lot easier for you


379
00:16:42,206 --> 00:16:44,346
to translate strings as
they appear on the screen


380
00:16:44,696 --> 00:16:46,196
in a flexible manner
that works for all


381
00:16:46,196 --> 00:16:46,886
of the world's languages.


382
00:16:48,496 --> 00:16:50,736
Next up, let's discuss
formatting.


383
00:16:51,516 --> 00:16:53,656
It's often not enough to
simply translate the strings


384
00:16:53,656 --> 00:16:54,566
that appear on your screen.


385
00:16:55,116 --> 00:16:57,326
Additionally, you will have
to think about the way dates,


386
00:16:57,556 --> 00:17:01,726
numbers, times, and, new in
iOS 9 and El Capitan, names.


387
00:17:02,756 --> 00:17:05,266
So, to begin with,
there is a right way


388
00:17:05,266 --> 00:17:06,826
and a wrong way to
format numbers.


389
00:17:07,276 --> 00:17:09,435
Let's say we wish to present
the constant pi to our users.


390
00:17:10,496 --> 00:17:11,766
One naive way to
do this would be


391
00:17:11,766 --> 00:17:13,415
to initialize a string variable


392
00:17:13,536 --> 00:17:17,606
with a format argument
percent.3F, that is to say,


393
00:17:17,606 --> 00:17:20,386
a 3 precision float argument.


394
00:17:20,796 --> 00:17:22,866
This works in English, 3.142.


395
00:17:24,286 --> 00:17:26,566
If you translate, if
your user is running


396
00:17:26,566 --> 00:17:27,906
in a German localization,
however,


397
00:17:28,455 --> 00:17:30,536
they get back this string.


398
00:17:30,536 --> 00:17:32,366
This may appear correct
at first glance,


399
00:17:32,836 --> 00:17:36,296
but in fact a German user
would read this 3,142,


400
00:17:36,726 --> 00:17:39,696
because in German, the
decimals digit and the, sorry,


401
00:17:40,226 --> 00:17:42,346
the thousands digit and the
decimals digit are, in fact,


402
00:17:42,346 --> 00:17:44,736
switched, so that is to say,
where we would use a period


403
00:17:45,026 --> 00:17:47,306
in U.S. English, they use
a comma, and vice versa.


404
00:17:48,186 --> 00:17:49,606
So, to take advantage
of this fact,


405
00:17:50,036 --> 00:17:52,096
you can call 'localized
string with format,


406
00:17:52,366 --> 00:17:54,406
passing in the same format
argument you used before.


407
00:17:55,226 --> 00:17:57,066
Now this will have different
realizations depending


408
00:17:57,066 --> 00:17:57,916
on a user's locale.


409
00:17:58,526 --> 00:18:00,386
And this means now
the same thing


410
00:18:00,386 --> 00:18:02,046
for an English user
and a German user.


411
00:18:02,916 --> 00:18:04,576
Now, under the hood,
'localized string


412
00:18:04,576 --> 00:18:06,536
with format' is using
NS number formatter.


413
00:18:06,586 --> 00:18:10,796
And we have some improvements
to NS number formatter we would


414
00:18:10,796 --> 00:18:11,766
like to discuss as well.


415
00:18:12,576 --> 00:18:16,986
New in iOS 9 and El Capitan
are different number styles


416
00:18:16,986 --> 00:18:18,076
for the NS number formatter.


417
00:18:18,526 --> 00:18:20,466
In addition to the already
existing 'currency style,


418
00:18:20,826 --> 00:18:22,586
we now have 'currency
ISO code style,


419
00:18:23,116 --> 00:18:26,546
as well 'currency plural style'
and 'currency accounting style.'


420
00:18:27,296 --> 00:18:29,126
Interestingly here for
'currency accounting style,


421
00:18:29,206 --> 00:18:31,106
if you pass it a
negative number,


422
00:18:31,596 --> 00:18:33,716
it presents it surrounded
by parentheses.


423
00:18:34,076 --> 00:18:35,416
This is common in
accounting circles.


424
00:18:36,736 --> 00:18:39,766
As well, we added an 'ordinal
style,' that is to say,


425
00:18:39,766 --> 00:18:41,696
how the number would
appear in an ordered list.


426
00:18:42,136 --> 00:18:44,236
So from 42, you get back 42nd.


427
00:18:45,456 --> 00:18:49,446
So, in addition to formatting
numbers, another thing


428
00:18:49,446 --> 00:18:51,856
that commonly goes wrong
is formatting dates.


429
00:18:51,856 --> 00:18:54,146
Now here is a very naive
way to format a date.


430
00:18:54,756 --> 00:18:57,246
We initialize an NS String
with this format argument.


431
00:18:57,726 --> 00:19:01,606
That is to say, this
represents today's date at 9:00


432
00:19:01,606 --> 00:19:03,706
in the morning to a
U.S. English speaker.


433
00:19:04,976 --> 00:19:07,266
So in U.S. English we
would get back this string,


434
00:19:07,266 --> 00:19:08,836
which looks appropriate
and correct.


435
00:19:09,286 --> 00:19:12,276
But for an Italian user we
get back the same string.


436
00:19:12,846 --> 00:19:14,336
Now this means something
very different in Italy.


437
00:19:14,486 --> 00:19:18,996
This is in fact the 6th day of
the 12th month, and furthermore,


438
00:19:18,996 --> 00:19:20,906
the time itself could be
a little more clarified.


439
00:19:20,946 --> 00:19:21,796
We'll get to that in a second.


440
00:19:22,166 --> 00:19:25,786
So, one way you could
attempt to solve this is


441
00:19:25,786 --> 00:19:27,176
by creating an NS
date formatter.


442
00:19:27,506 --> 00:19:29,466
Indeed, NS date formatter
is the correct solution,


443
00:19:29,466 --> 00:19:30,926
but this is the incorrect
way to use it.


444
00:19:31,566 --> 00:19:33,306
Here, we're setting a
date format argument.


445
00:19:33,426 --> 00:19:37,316
Now, the date format implies an
explicit ordering of strings.


446
00:19:37,736 --> 00:19:40,536
The exact variables that you
provided here will then be


447
00:19:40,536 --> 00:19:45,156
expanded in whatever locale you
are using, to the exact sequence


448
00:19:45,156 --> 00:19:45,956
of characters you see.


449
00:19:46,546 --> 00:19:49,306
So, again, we are getting back
the incorrect string in Italy.


450
00:19:50,226 --> 00:19:52,006
Now, the easiest way
to fix this is in fact


451
00:19:52,006 --> 00:19:54,026
by setting a date
style and a time style


452
00:19:54,026 --> 00:19:55,216
on your NS date formatter.


453
00:19:55,896 --> 00:19:58,456
We provide certain out of the
box styles for NS date formatter


454
00:19:58,456 --> 00:20:02,376
that allow you to specify
the amount of space available


455
00:20:02,376 --> 00:20:04,386
to you relative to the
width of the string.


456
00:20:05,176 --> 00:20:07,566
So here we call, here
we set ShortStyle


457
00:20:07,846 --> 00:20:09,086
for both date and time style.


458
00:20:09,786 --> 00:20:12,926
What we get back in Italy,
therefore, is the same string


459
00:20:13,296 --> 00:20:15,736
but with the variables flipped.


460
00:20:16,226 --> 00:20:19,406
So that is to say, this
now reads the 12th day


461
00:20:19,406 --> 00:20:21,456
of the 6th month
to a user in Italy,


462
00:20:21,926 --> 00:20:24,166
which is the same thing would
read as an English-US user.


463
00:20:25,136 --> 00:20:26,896
Now, sometimes, though,
these date styles


464
00:20:26,896 --> 00:20:28,466
and time styles aren't
as specific


465
00:20:28,466 --> 00:20:29,456
as you may need them to be.


466
00:20:30,086 --> 00:20:33,256
For that, new in iOS 9 and
El Capitan, we allow you


467
00:20:33,296 --> 00:20:35,686
to set 'localized date
format from template.'


468
00:20:36,596 --> 00:20:40,266
Here you provide a template and
the variables are rearranged


469
00:20:40,406 --> 00:20:41,986
as appropriate for
your given locale.


470
00:20:43,036 --> 00:20:45,086
Now this is when the
individual styles


471
00:20:45,086 --> 00:20:46,756
out of the box don't
provide enough information.


472
00:20:47,116 --> 00:20:48,436
Here, for instance,
the user wishes


473
00:20:48,476 --> 00:20:50,686
to present the second
string as well,


474
00:20:51,086 --> 00:20:53,266
which doesn't typically
come with a short style.


475
00:20:54,406 --> 00:20:57,546
So using this template, we
have allowed for 24-hour time


476
00:20:57,546 --> 00:21:03,636
as well, as well as rearranging
the month and day arguments.


477
00:21:04,796 --> 00:21:07,076
So, we have looked at how
you can format numbers,


478
00:21:07,156 --> 00:21:08,096
how you can format dates,


479
00:21:08,486 --> 00:21:10,426
but also important is
how you format units.


480
00:21:12,186 --> 00:21:15,476
Now, this is in fact a
very naive example but one


481
00:21:15,476 --> 00:21:17,586
which is very real and we
have seen in the real world.


482
00:21:18,216 --> 00:21:19,716
Let's say you wish to
translate the quantity


483
00:21:19,716 --> 00:21:21,866
"6 pounds" to another language.


484
00:21:22,586 --> 00:21:24,616
One very naive way to
solve this would be in fact


485
00:21:24,616 --> 00:21:26,166
to literally translate
the string.


486
00:21:26,646 --> 00:21:28,616
You have on the left-hand
side, "X pounds.'


487
00:21:28,976 --> 00:21:31,666
We have translated this for an
Italian user to "X chilogrammi,"


488
00:21:31,666 --> 00:21:34,926
that is to say the Italian
word for the word 'kilogram.'


489
00:21:35,636 --> 00:21:37,856
Now, this may be
obviously very wrong.


490
00:21:37,856 --> 00:21:38,956
In English we have 6 pounds.


491
00:21:38,956 --> 00:21:39,796
In Italian we have 6 kilograms.


492
00:21:39,796 --> 00:21:40,456
These quantities are not equal.


493
00:21:40,456 --> 00:21:41,996
6 pounds is not equal
to 6 kilograms.


494
00:21:41,996 --> 00:21:43,956
These quantities are
not, in fact, equal.


495
00:21:43,956 --> 00:21:47,016
6 pounds as a unit is
not equal to 6 kilograms.


496
00:21:47,016 --> 00:21:48,916
So this is a very
wrong way to do this.


497
00:21:49,686 --> 00:21:52,236
An easier way is to
use NSMassFormatter.


498
00:21:52,696 --> 00:21:55,486
Now, NSMassFormatter, as
well as NSEnergyFormatter


499
00:21:55,796 --> 00:21:57,836
and LengthFormatter, assume


500
00:21:57,836 --> 00:22:00,116
that under the hood you are
working in metric units.


501
00:22:00,546 --> 00:22:03,606
So when you assign a float
here to the variable weight,


502
00:22:03,606 --> 00:22:05,536
it assumes that you are
working with kilograms.


503
00:22:06,196 --> 00:22:08,156
So you initialize
an NSMassFormatter,


504
00:22:08,566 --> 00:22:11,016
you set its unitStyle to
long, and then, furthermore,


505
00:22:11,016 --> 00:22:14,846
you call 'string from kilograms'
on the weight in kilograms.


506
00:22:15,506 --> 00:22:18,406
This will return back
in English 44.092,


507
00:22:19,306 --> 00:22:21,056
which is in fact a
conversion of the units


508
00:22:21,346 --> 00:22:22,776
into those used in
the United States.


509
00:22:23,676 --> 00:22:26,046
Furthermore, in Italian you
will get back 20 chilogrammi


510
00:22:26,366 --> 00:22:28,946
which is both the
correct unit as well


511
00:22:28,946 --> 00:22:31,026
as the correct translated
term for the amount of weight


512
00:22:31,026 --> 00:22:31,576
that you are providing.


513
00:22:32,346 --> 00:22:35,236
So using NSMassFormatter
makes it super easy to present


514
00:22:35,236 --> 00:22:36,296
in units for your user.


515
00:22:37,236 --> 00:22:40,336
Now, new in iOS 9, we allow you


516
00:22:40,336 --> 00:22:43,706
to format names --
iOS 9 and El Capitan.


517
00:22:44,396 --> 00:22:46,916
Now, to see why this is
useful, let's take a look


518
00:22:46,916 --> 00:22:47,926
at two names side by side.


519
00:22:48,346 --> 00:22:50,636
The first is "Grace
Murray Hopper."


520
00:22:51,066 --> 00:22:52,376
This is a famous
computer scientist


521
00:22:52,376 --> 00:22:52,986
from the United States.


522
00:22:52,986 --> 00:22:56,726
She coined the term "bug" and
invented the first compiler.


523
00:22:57,496 --> 00:23:00,426
Additionally, let's look at a
Chinese name, "Wang Dongling."


524
00:23:01,096 --> 00:23:02,606
Now, this is a famous
calligrapher,


525
00:23:02,726 --> 00:23:04,816
who does the calligraphy outside
of the Hangzhou Apple Store.


526
00:23:05,526 --> 00:23:07,426
So, both of these have
three parts to them.


527
00:23:08,016 --> 00:23:10,486
But the way we interpret them
is important and different.


528
00:23:11,886 --> 00:23:14,746
In English we would
typically call this the first,


529
00:23:14,916 --> 00:23:16,326
the middle, and the last name.


530
00:23:16,546 --> 00:23:18,466
We will see what
happens when we attempt


531
00:23:18,466 --> 00:23:20,996
to apply this concept
for a Chinese user.


532
00:23:21,076 --> 00:23:25,876
What was formerly the last name
is now, spatially speaking,


533
00:23:25,876 --> 00:23:26,836
first from left to right.


534
00:23:27,556 --> 00:23:29,706
The middle name itself
doesn't exist at all.


535
00:23:29,706 --> 00:23:32,976
And what's formerly the first
name is now, spatially speaking


536
00:23:33,066 --> 00:23:37,786
from left to right,
the last name.


537
00:23:38,366 --> 00:23:41,716
So, we can see here that
terminology is important as well


538
00:23:41,716 --> 00:23:44,026
as the labels we choose to
apply to these concepts.


539
00:23:44,826 --> 00:23:48,406
So we are introducing NS
Person Name Components


540
00:23:48,606 --> 00:23:50,326
and NS Person Name
Components Formatter.


541
00:23:50,706 --> 00:23:51,806
We have already gotten the joke


542
00:23:51,806 --> 00:23:53,236
that people can't
fit this into Tweets.


543
00:23:53,346 --> 00:23:55,726
But it's a little long and it's
a little difficult to work with,


544
00:23:55,756 --> 00:23:58,036
but, that is to say, it's very
precise as to what it does.


545
00:23:58,096 --> 00:23:59,366
It formats person names.


546
00:24:00,456 --> 00:24:01,926
So here is how you would use it.


547
00:24:02,626 --> 00:24:05,486
You initialize an NS Person
Name Components object.


548
00:24:06,006 --> 00:24:07,806
You populate the given
name, the middle name,


549
00:24:07,806 --> 00:24:08,846
and the family name fields.


550
00:24:08,956 --> 00:24:10,606
Here is how you would do
this for an English-US user.


551
00:24:11,406 --> 00:24:13,316
For a Russian user,
then, you would populate


552
00:24:13,606 --> 00:24:16,336
"Fyodor Mikhailovich
Dostoyevsky."


553
00:24:17,056 --> 00:24:18,906
Likewise, you are
populating the same fields.


554
00:24:19,776 --> 00:24:22,756
Here is then how
you would format it.


555
00:24:22,946 --> 00:24:25,776
You initialize as NS Person Name
Components Formatter object.


556
00:24:26,306 --> 00:24:27,886
As we've seen with
other NS formatters,


557
00:24:27,936 --> 00:24:28,986
it has a style component.


558
00:24:29,376 --> 00:24:30,706
Here we specify short style.


559
00:24:31,416 --> 00:24:33,376
Then you call 'string from
person name components'


560
00:24:33,376 --> 00:24:34,926
on your Person Name
Components object.


561
00:24:35,886 --> 00:24:37,736
The result of this
call is the following,


562
00:24:38,066 --> 00:24:42,166
for our five available styles:
default, short, medium, long,


563
00:24:42,166 --> 00:24:43,966
and abbreviated, we have
done the right thing


564
00:24:43,966 --> 00:24:44,656
for each language.


565
00:24:44,656 --> 00:24:46,246
A couple of things to note here,


566
00:24:46,386 --> 00:24:49,386
that in fact the short style
differs depending on, one,


567
00:24:49,386 --> 00:24:51,656
the user's locale,
and depending as well


568
00:24:51,656 --> 00:24:53,726
on the individual
user's override settings


569
00:24:53,726 --> 00:24:55,676
within the mail, contacts,
and calendar settings.


570
00:24:56,446 --> 00:24:59,266
As well, for Russian
names, we have determined


571
00:24:59,266 --> 00:25:02,026
that abbreviated names in
this form with first, middle,


572
00:25:02,026 --> 00:25:02,946
and last all shortened


573
00:25:02,946 --> 00:25:05,396
to the first character doesn't
really exist and so, therefore,


574
00:25:05,396 --> 00:25:07,046
we have fallen back
to the short style.


575
00:25:07,926 --> 00:25:10,476
So it's really easy
out of the box


576
00:25:10,476 --> 00:25:12,166
to format names for your users.


577
00:25:14,016 --> 00:25:17,446
So that's numbers, dates,
times, units, and names.


578
00:25:18,076 --> 00:25:20,346
We have looked at how
you can translate now,


579
00:25:20,886 --> 00:25:22,166
translate the strings
in your UI,


580
00:25:22,466 --> 00:25:24,786
how you can format the
units the users are seeing.


581
00:25:25,366 --> 00:25:27,706
Additionally important is
how you handle text received


582
00:25:27,876 --> 00:25:28,456
from the user.


583
00:25:31,036 --> 00:25:33,516
Now, this involves looking
at what a character is,


584
00:25:33,956 --> 00:25:37,406
how it changes based on
casing, how you search


585
00:25:37,406 --> 00:25:39,616
for that character, and,
as well, how you transform


586
00:25:39,616 --> 00:25:42,136
that into another
script, for instance.


587
00:25:43,186 --> 00:25:44,306
To begin with, with
this section,


588
00:25:44,306 --> 00:25:45,636
let's ask a philosophical
question.


589
00:25:45,916 --> 00:25:46,896
What is a character?


590
00:25:47,746 --> 00:25:49,306
To begin with, let's ask,


591
00:25:49,386 --> 00:25:51,216
how many characters
is this emoticon?


592
00:25:51,856 --> 00:25:54,636
This was introduced recently
on iOS and it's possible


593
00:25:54,636 --> 00:25:56,266
to type this on our keyboards.


594
00:25:57,886 --> 00:25:59,706
The answer here is not
immediately straightforward,


595
00:25:59,706 --> 00:26:01,636
although visually it
constitutes a single unit.


596
00:26:02,136 --> 00:26:05,276
Under the hood it's represented
by one, two, three, four, five,


597
00:26:05,656 --> 00:26:09,926
six, seven, eight
individual characters.


598
00:26:10,726 --> 00:26:14,336
Now, actually these are Unicode
code points and depending


599
00:26:14,336 --> 00:26:16,496
on the encoding you are using
it may in fact be more than 8.


600
00:26:16,496 --> 00:26:18,666
It may be 11, for instance, but,


601
00:26:18,766 --> 00:26:21,586
that is to say you shouldn't
have to think about this.


602
00:26:23,236 --> 00:26:28,026
Now, one place where this
becomes really obvious is


603
00:26:28,026 --> 00:26:29,336
in enumerating over a string.


604
00:26:29,896 --> 00:26:31,396
Let's say you have a
string test followed


605
00:26:31,396 --> 00:26:33,956
by the emoji character
we just discussed.


606
00:26:34,676 --> 00:26:38,426
Now you wish to enumerate over
each character within the string


607
00:26:38,426 --> 00:26:39,916
and call 'character at index.'


608
00:26:40,826 --> 00:26:42,996
This will return the
unichars constituting the


609
00:26:42,996 --> 00:26:43,736
individual string.


610
00:26:44,336 --> 00:26:45,376
But this isn't what you want.


611
00:26:45,376 --> 00:26:49,026
In fact, this presents
question mark characters


612
00:26:49,026 --> 00:26:51,556
and sometimes three unprintable
characters, and there is a heart


613
00:26:51,556 --> 00:26:53,586
in the middle for some
reason, so it's not,


614
00:26:54,506 --> 00:26:56,366
this is definitely the
incorrect way to do this.


615
00:26:57,026 --> 00:26:58,586
The correct way to
enumerate over a string is


616
00:26:58,586 --> 00:27:00,566
to call 'enumerate
substrings in range.'


617
00:27:01,106 --> 00:27:04,006
Additionally, you pass the 'by
composed character sequences.'


618
00:27:04,406 --> 00:27:06,206
This makes it such that the


619
00:27:06,206 --> 00:27:08,726
under the hood representation
matches the user's visual


620
00:27:08,726 --> 00:27:09,876
representation of the character.


621
00:27:10,476 --> 00:27:11,866
Therefore, when we
call it on this string,


622
00:27:11,866 --> 00:27:13,656
we get back exactly
six characters.


623
00:27:14,756 --> 00:27:17,816
So this is how you would
enumerate over a string.


624
00:27:18,506 --> 00:27:20,656
But sometimes you wish
to transform that string


625
00:27:20,656 --> 00:27:21,436
into a different form.


626
00:27:22,786 --> 00:27:26,236
New in iOS 9 we are
providing the ability,


627
00:27:26,236 --> 00:27:28,886
iOS 9 and El Capitan, we
are providing the ability


628
00:27:28,886 --> 00:27:29,946
to transform that string.


629
00:27:30,896 --> 00:27:32,766
So let's say your
string is "istanbul."


630
00:27:33,566 --> 00:27:35,086
A nave way to capitalize
the string would be


631
00:27:35,086 --> 00:27:39,156
to simply call the
'capitalize string' property.


632
00:27:39,956 --> 00:27:41,796
For English-US users
this may look correct.


633
00:27:41,966 --> 00:27:43,696
Indeed, this is,
for English users,


634
00:27:43,696 --> 00:27:44,856
the correct way to
capitalize this.


635
00:27:45,226 --> 00:27:47,826
But for a speaker of Turkish,
the dotted lower case i


636
00:27:47,826 --> 00:27:49,696
in fact becomes a
dotted upper case I.


637
00:27:50,746 --> 00:27:53,156
To immediately gain
the benefit of this,


638
00:27:53,476 --> 00:27:55,796
you can simply call
'localized capitalized string'


639
00:27:56,586 --> 00:27:57,516
on that string.


640
00:27:57,756 --> 00:27:59,586
And, therefore, you will get
the appropriate capitalized


641
00:27:59,586 --> 00:28:01,386
representation of the
string, that is to say,


642
00:28:01,476 --> 00:28:03,916
the string with the first
character upper cased.


643
00:28:04,796 --> 00:28:08,186
Now, in addition to
'localized capitalized string,


644
00:28:08,186 --> 00:28:10,496
we are also providing
'localized uppercase string'


645
00:28:10,496 --> 00:28:11,706
and 'localized lowercase
string.'


646
00:28:11,796 --> 00:28:13,476
Here is what these look like.


647
00:28:14,706 --> 00:28:17,166
So you can out of the box
make use of these characters


648
00:28:17,166 --> 00:28:18,796
by simply using the
localized variants


649
00:28:19,096 --> 00:28:20,416
of the already existing APIs.


650
00:28:21,446 --> 00:28:24,606
So, that's how you transform
the case of your string,


651
00:28:24,606 --> 00:28:26,966
but let's say you wish to search
for a string within another.


652
00:28:27,836 --> 00:28:28,856
Here is also where we get back


653
00:28:28,856 --> 00:28:30,416
to our question,
what is a character?


654
00:28:31,676 --> 00:28:35,066
And what are our users
expecting when they expect


655
00:28:35,066 --> 00:28:36,116
to search for a given string?


656
00:28:36,846 --> 00:28:39,616
So, let's say we have the
variable here representing the


657
00:28:39,616 --> 00:28:40,516
German word "uber."


658
00:28:41,236 --> 00:28:42,336
Now this has a capital U,


659
00:28:42,736 --> 00:28:44,356
and happens to use
an umlaut over the U.


660
00:28:45,186 --> 00:28:48,546
A user might expect, given the
way we typically write this word


661
00:28:48,546 --> 00:28:51,896
in English, that lower case
"uber" will find the string.


662
00:28:52,776 --> 00:28:56,566
As a developer you may call
'range of string' to find it,


663
00:28:57,106 --> 00:28:58,516
when in fact this
will return nil.


664
00:28:59,646 --> 00:29:02,106
The correct way to search
for this, and new in iOS 9


665
00:29:02,106 --> 00:29:05,156
and El Capitan, is 'localized
standard range of string.'


666
00:29:05,926 --> 00:29:07,836
This will allow you to
search for this string


667
00:29:07,836 --> 00:29:11,466
within the other using
diacritic insensitivity as well


668
00:29:11,466 --> 00:29:13,636
as capitalization insensitivity.


669
00:29:14,476 --> 00:29:16,376
Additionally, it
provides allowances


670
00:29:16,376 --> 00:29:17,606
for a given user's locale.


671
00:29:18,346 --> 00:29:20,866
So, here, we've found the
lowercase string "uber"


672
00:29:20,956 --> 00:29:25,886
within 'capital U-umlaut-ber' by
simply calling these new APIs.


673
00:29:27,276 --> 00:29:29,976
So, in addition to
searching through the string,


674
00:29:30,366 --> 00:29:32,666
sometimes you may wish to
transform the entire string.


675
00:29:33,846 --> 00:29:35,486
Now, this is where
transforms come in.


676
00:29:36,246 --> 00:29:38,436
Transforms allow you to
translate between an uppercase


677
00:29:38,436 --> 00:29:40,156
and a lowercase variant
of an entire string.


678
00:29:40,736 --> 00:29:43,656
Additionally they allow you
to do Unicode normalization.


679
00:29:43,656 --> 00:29:45,956
That is to say, they take
out the diacritic characters


680
00:29:45,956 --> 00:29:47,176
and separate them
out, such that A


681
00:29:47,176 --> 00:29:50,186
with an umlaut becomes
A plus umlaut character.


682
00:29:51,096 --> 00:29:52,006
Additionally, we allow you


683
00:29:52,006 --> 00:29:54,566
to script-to-script
conversion, or transliteration.


684
00:29:54,566 --> 00:29:57,126
That is to say, going from
Chinese Han characters


685
00:29:57,426 --> 00:29:58,626
to their Latin representation.


686
00:29:59,366 --> 00:30:00,886
Now, formerly this was
available to you only


687
00:30:00,886 --> 00:30:02,106
at the Core Foundation level.


688
00:30:03,256 --> 00:30:06,876
New in iOS 9 and El Capitan,
we allow you to access this


689
00:30:06,876 --> 00:30:07,756
at the Foundation level.


690
00:30:09,206 --> 00:30:11,176
You simply call a 'string
by applying transform.'


691
00:30:12,216 --> 00:30:14,406
Then you provide a
string or here a constant,


692
00:30:15,376 --> 00:30:18,836
representing how you wish
to transform the string.


693
00:30:19,446 --> 00:30:22,206
Here, we wish to translate
the emoji character or, sorry,


694
00:30:22,206 --> 00:30:25,376
transliterate the emoji
character "thumbs up"


695
00:30:25,456 --> 00:30:27,056
into an XML representation.


696
00:30:28,606 --> 00:30:31,426
To do this, it's as
simple as calling 'string


697
00:30:31,426 --> 00:30:32,346
by applying transform'


698
00:30:32,566 --> 00:30:35,176
and provide 'NS String
Transform to XML Hex.'


699
00:30:35,906 --> 00:30:39,406
We additionally provide such
transforms as Han characters


700
00:30:39,406 --> 00:30:43,796
to Latin, and between different
European scripts as well.


701
00:30:44,536 --> 00:30:47,286
So it's super easy,
then, to translate,


702
00:30:47,286 --> 00:30:49,926
transliterate your string
from one script to another,


703
00:30:49,926 --> 00:30:53,096
and provide transforms from
your individual characters


704
00:30:53,256 --> 00:30:54,356
to different representations.


705
00:30:55,346 --> 00:30:58,916
So, that's how you handle text
within our operating system


706
00:30:59,366 --> 00:31:00,596
as received from the user.


707
00:31:01,546 --> 00:31:03,086
Additionally important
is the way you lay


708
00:31:03,086 --> 00:31:04,726
out visual elements
on the screen.


709
00:31:06,446 --> 00:31:10,236
Now, here is where
auto layout comes in.


710
00:31:11,226 --> 00:31:12,976
Auto layout was released
several releases ago


711
00:31:13,416 --> 00:31:14,726
and the original intention was


712
00:31:14,986 --> 00:31:18,706
to format given UI
differently based on the amount


713
00:31:18,706 --> 00:31:20,206
of screen real estate
available to you.


714
00:31:20,506 --> 00:31:22,306
This has become increasingly
important


715
00:31:22,306 --> 00:31:23,806
as we've released
different form factors


716
00:31:23,806 --> 00:31:28,156
for our devices both
on iOS and OS X.


717
00:31:28,236 --> 00:31:32,156
But I should say an additional
benefit of auto layout is


718
00:31:32,156 --> 00:31:34,566
in localizing the UI
of your application.


719
00:31:36,596 --> 00:31:39,156
Here is what a UI
would look like.


720
00:31:39,156 --> 00:31:40,086
So, let's say, for instance,


721
00:31:40,086 --> 00:31:42,076
we wish to add a new
calendar to iCloud.


722
00:31:42,646 --> 00:31:44,336
Here is what a sample UI
may look like in English.


723
00:31:44,886 --> 00:31:47,606
This UI may have been worked
on meticulously and may work


724
00:31:47,606 --> 00:31:50,526
when you test it in
different orientations


725
00:31:50,796 --> 00:31:53,806
and may work even dynamically
with content added at runtime.


726
00:31:54,916 --> 00:31:58,496
But if you haven't taken
allowances for how this works


727
00:31:58,496 --> 00:32:00,466
in other UIs or in
other languages,


728
00:32:00,816 --> 00:32:03,366
in fact it may break
these assumptions


729
00:32:03,366 --> 00:32:04,426
that you've had up until now.


730
00:32:05,596 --> 00:32:09,996
So here is the same UI in Greek,
and this may work, this may seem


731
00:32:09,996 --> 00:32:11,156
to work on first glance.


732
00:32:11,776 --> 00:32:13,616
When you take a little closer
look, we realize, in fact,


733
00:32:13,616 --> 00:32:16,286
this character is now
3.5 characters long.


734
00:32:16,286 --> 00:32:18,036
There are additional
sections of the UI


735
00:32:18,036 --> 00:32:19,046
that have this problem as well.


736
00:32:19,816 --> 00:32:22,016
Now, I should say that it's not
necessary to localize your app


737
00:32:22,066 --> 00:32:23,706
to test it in a different
localization.


738
00:32:24,216 --> 00:32:27,686
Thanks to XCode's Skin menu
you can test your app using a


739
00:32:27,686 --> 00:32:29,096
double-width pseudo-language,


740
00:32:29,096 --> 00:32:30,836
as well as a right-to-left
pseudo-language,


741
00:32:31,426 --> 00:32:33,836
that doesn't require you to
have a translation on hand


742
00:32:34,186 --> 00:32:36,456
to see how your UI would
operate in different contexts.


743
00:32:37,566 --> 00:32:39,916
So, assuming then you
are using auto layout


744
00:32:40,366 --> 00:32:42,706
and you have set your
hugging priorities


745
00:32:43,146 --> 00:32:45,106
and your compression
resistance priorities correctly,


746
00:32:45,576 --> 00:32:47,606
here is what your
UI would look like.


747
00:32:47,656 --> 00:32:52,576
We have seen what was formerly
3.5 characters is now 12.


748
00:32:53,176 --> 00:32:55,186
This is a huge difference.


749
00:32:55,556 --> 00:32:58,026
We have allowed our label to
expand the available space given


750
00:32:58,026 --> 00:33:01,766
to us by specifying
not static constraints


751
00:33:01,766 --> 00:33:02,996
but rather those that can grow.


752
00:33:03,366 --> 00:33:06,196
We say that the constraint is
less than or equal to the width


753
00:33:06,256 --> 00:33:06,996
to the edge of the screen.


754
00:33:07,736 --> 00:33:09,346
So, for a lot more
information about this,


755
00:33:09,346 --> 00:33:11,636
I would really encourage you
to check out yesterday's talk,


756
00:33:12,186 --> 00:33:14,226
"Mysteries of Auto
Layout, Part 1 and 2."


757
00:33:14,976 --> 00:33:16,096
Those go into a lot more detail


758
00:33:16,446 --> 00:33:18,646
about how you can use auto
layout to make your app work


759
00:33:18,646 --> 00:33:22,256
around the world, as well as for
different device orientations.


760
00:33:23,586 --> 00:33:28,696
So, also a thing to keep in
mind in laying out your UI is


761
00:33:28,696 --> 00:33:30,986
that table cells
themselves may change size.


762
00:33:31,896 --> 00:33:33,166
This relates to dynamic type.


763
00:33:33,496 --> 00:33:35,676
On the left, we have
an English-US UI,


764
00:33:35,676 --> 00:33:36,976
on the right, we have Hindi.


765
00:33:37,716 --> 00:33:38,736
Now, notice that, actually,


766
00:33:38,736 --> 00:33:41,516
individual cells are
different heights here.


767
00:33:41,966 --> 00:33:43,976
This is because the
cells are auto resizing.


768
00:33:43,976 --> 00:33:46,396
We have allowed the cells
to take up the amount


769
00:33:46,396 --> 00:33:49,366
of space dictated by the
line height of that language.


770
00:33:50,186 --> 00:33:53,246
So if you use standard
UI controls and UI views,


771
00:33:53,246 --> 00:33:55,856
you will see, you will get
this behavior for free.


772
00:33:56,606 --> 00:33:59,026
But important to keep in mind
from a developer perspective is


773
00:33:59,026 --> 00:33:59,926
that you shouldn't assume


774
00:33:59,926 --> 00:34:01,696
that a given table cell
will be a certain height.


775
00:34:02,186 --> 00:34:05,146
It may expand in
different locales to take


776
00:34:05,146 --> 00:34:06,536
up a different amount of space.


777
00:34:08,516 --> 00:34:11,876
So additionally important
and critical in iOS 9 is


778
00:34:11,876 --> 00:34:13,806
that we have now
provided full support


779
00:34:13,806 --> 00:34:15,025
for right-to-left languages.


780
00:34:15,335 --> 00:34:18,346
On the left, we have an English
UI, and on the right, an Arabic.


781
00:34:19,116 --> 00:34:20,826
Now, the changes here are deep.


782
00:34:21,376 --> 00:34:23,346
We have gone through the
standard controls and views,


783
00:34:23,636 --> 00:34:26,216
and switched the
overall control flow.


784
00:34:26,826 --> 00:34:30,216
In English, you would go from
one menu into a detail menu


785
00:34:30,216 --> 00:34:31,246
by going left to right.


786
00:34:31,846 --> 00:34:34,735
Now, in right-to-left languages
you go to right to left.


787
00:34:35,246 --> 00:34:37,156
Note that the chevrons
themselves have shifted.


788
00:34:37,446 --> 00:34:40,446
The accessory views are
on the other side and much


789
00:34:40,446 --> 00:34:42,016
of the text itself
has been flipped.


790
00:34:43,016 --> 00:34:45,025
Important to keep in mind,
though, is not everything


791
00:34:45,025 --> 00:34:50,985
in the UI may shift, and may
not automatically shift for you.


792
00:34:50,985 --> 00:34:53,126
Sometimes you may wish to
customize the behavior.


793
00:34:53,926 --> 00:34:57,796
As we see here in the 'do not
disturb' icon which is, in fact,


794
00:34:57,796 --> 00:35:00,756
still left to right, as
well as the Latin text


795
00:35:00,756 --> 00:35:02,546
which is still left
to right as well.


796
00:35:03,086 --> 00:35:05,186
Now, for a lot more
information about this,


797
00:35:05,186 --> 00:35:07,386
I would really encourage you
to check out "New UIKit Support


798
00:35:07,386 --> 00:35:09,436
for International Interfaces"
which happened yesterday.


799
00:35:10,246 --> 00:35:13,166
This goes through how you
can use standard controls


800
00:35:13,446 --> 00:35:15,416
to make use of and
gain the benefit


801
00:35:15,416 --> 00:35:17,846
of the full right-to-left
support in iOS 9,


802
00:35:18,456 --> 00:35:20,376
additionally how you may
wish to customize this


803
00:35:20,656 --> 00:35:21,806
for your individual app needs.


804
00:35:23,146 --> 00:35:28,256
So, overall, it's important
to remember to keep in mind


805
00:35:28,706 --> 00:35:32,056
in internationalizing your app,
first the localization aspect,


806
00:35:32,546 --> 00:35:34,166
how it is that your
strings are translated,


807
00:35:34,456 --> 00:35:36,666
how it is that the concepts
behind the translations are


808
00:35:36,666 --> 00:35:38,286
themselves translated
to your users.


809
00:35:38,916 --> 00:35:42,426
Additionally, formatting, how it
is that units, dates, numbers,


810
00:35:42,426 --> 00:35:44,916
times, and now names are
formatted to your user.


811
00:35:46,166 --> 00:35:48,746
Handling text, how is it that
you take the text from the user


812
00:35:49,126 --> 00:35:50,586
and perform operations on it.


813
00:35:51,116 --> 00:35:53,596
This brings back the eternal
question, what is a character?


814
00:35:53,916 --> 00:35:55,956
Something you should always
keep in mind in processing text.


815
00:35:56,266 --> 00:35:59,906
Finally we have layout, how it
is that your UI elements appear


816
00:35:59,906 --> 00:36:01,386
on the screen to
international users.


817
00:36:02,276 --> 00:36:04,336
Now, luckily if you're
using the localized variants


818
00:36:04,336 --> 00:36:07,546
of existing APIs, as well as
standard views and controls,


819
00:36:07,786 --> 00:36:09,326
you should get all of
this behavior for free.


820
00:36:10,136 --> 00:36:11,266
Now, if you keep all
of this in in mind,


821
00:36:11,266 --> 00:36:13,646
you will find
internationalization opens the


822
00:36:13,646 --> 00:36:15,026
world to your application.


823
00:36:16,576 --> 00:36:18,836
For more information, do
check out these slides here,


824
00:36:19,016 --> 00:36:20,896
or do check out the
documentation here.


825
00:36:21,336 --> 00:36:26,616
Contact our developer forums or
our App Frameworks Evangelist,


826
00:36:26,616 --> 00:36:31,216
Paul Marcos, and also check
out these related sessions.


827
00:36:31,596 --> 00:36:33,436
These have in fact already
happened, so check them


828
00:36:33,436 --> 00:36:35,026
out in your app or online.


829
00:36:35,026 --> 00:36:38,176
Also, however, we will be
offering an internationalization


830
00:36:38,176 --> 00:36:41,596
lab today from 11:00 to 1:10
p.m. So do come check us out.


831
00:36:41,596 --> 00:36:43,206
I will be there as
well as my team


832
00:36:43,206 --> 00:36:45,536
to answer questions you have
about internationalizing


833
00:36:45,536 --> 00:36:46,466
and localizing your apps.


834
00:36:47,326 --> 00:36:48,596
So, thank you.


835
00:36:49,516 --> 00:36:52,500
[Applause]

