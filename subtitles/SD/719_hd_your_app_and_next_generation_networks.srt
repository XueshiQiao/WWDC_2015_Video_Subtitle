
00:00:23.516 --> 00:00:29.486 A:middle
[Applause]

00:00:29.986 --> 00:00:31.616 A:middle
&gt;&gt; PRABHAKAR LAKHERA:
Thank you and good morning.

00:00:32.656 --> 00:00:36.046 A:middle
Welcome to Your App and Next
Generation Network session.

00:00:36.996 --> 00:00:40.306 A:middle
I am Prabhakar Lakhera and
with me I have my colleague

00:00:40.406 --> 00:00:41.036 A:middle
Stuart Cheshire.

00:00:42.746 --> 00:00:44.896 A:middle
And this session
is in two parts.

00:00:44.896 --> 00:00:49.936 A:middle
For the first topic I
will talk about IPv6,

00:00:50.436 --> 00:00:53.556 A:middle
and for the second topic
Stuart will talk about how

00:00:53.556 --> 00:00:55.866 A:middle
to make your applications
run faster.

00:00:57.476 --> 00:01:02.586 A:middle
We will start off
with IPv6 first.



00:00:57.476 --> 00:01:02.586 A:middle
We will start off
with IPv6 first.

00:01:02.776 --> 00:01:04.426 A:middle
Now, what's new in IPv6?

00:01:05.796 --> 00:01:09.826 A:middle
IPv6 RFC was published
almost 17 years back.

00:01:11.086 --> 00:01:15.836 A:middle
So you must be wondering, why
are we talking about IPv6 now?

00:01:17.596 --> 00:01:23.236 A:middle
We are seeing more and more of
IPv6 deployment in enterprise

00:01:23.366 --> 00:01:25.196 A:middle
and cellular networks.

00:01:26.056 --> 00:01:27.806 A:middle
And you want to make sure

00:01:27.866 --> 00:01:30.986 A:middle
that your applications
work in those networks.

00:01:31.286 --> 00:01:36.776 A:middle
That is the reason we will also
be mandating your applications

00:01:36.776 --> 00:01:38.206 A:middle
to be IPv6 compliant.

00:01:38.876 --> 00:01:41.896 A:middle
Now, we will talk more about
that and what it means to you

00:01:41.896 --> 00:01:44.376 A:middle
as developers, but
before we do that,

00:01:44.966 --> 00:01:46.936 A:middle
let's begin with
a bit of history.

00:01:47.436 --> 00:01:53.386 A:middle
Now, a long, long time ago,
client devices had real

00:01:53.446 --> 00:01:57.946 A:middle
and unique IPv4 addresses;
these were the good olden days

00:01:57.946 --> 00:02:00.226 A:middle
and you had end-to-end
network connectivity.



00:01:57.946 --> 00:02:00.226 A:middle
and you had end-to-end
network connectivity.

00:02:01.536 --> 00:02:04.056 A:middle
However, we soon realized
that we were running

00:02:04.056 --> 00:02:06.406 A:middle
out of IPv4 addresses
way too fast.

00:02:07.276 --> 00:02:09.496 A:middle
So we added a NAT in the middle.

00:02:10.946 --> 00:02:15.226 A:middle
Now, this works, but the
larger scale NAT device is both

00:02:15.226 --> 00:02:17.146 A:middle
expensive and fragile.

00:02:18.606 --> 00:02:21.796 A:middle
So carriers are now deploying
IPv6 in their network.

00:02:21.796 --> 00:02:29.266 A:middle
Now, with this, they again have
end-to-end network connectivity

00:02:29.326 --> 00:02:33.236 A:middle
and there's no translation
needed in the data path.

00:02:33.406 --> 00:02:35.976 A:middle
I will now show you how
IPv6 deployment looks

00:02:36.276 --> 00:02:39.236 A:middle
for three major cellular
carriers in the USA.

00:02:39.636 --> 00:02:43.546 A:middle
Now, two things are
obvious here.

00:02:44.266 --> 00:02:47.826 A:middle
One, all the lines are going up.

00:02:48.436 --> 00:02:51.296 A:middle
And second, more than half

00:02:51.296 --> 00:02:53.246 A:middle
of the subscribers
are now connecting

00:02:53.246 --> 00:02:55.756 A:middle
to cellular data
networks over IPv6.

00:02:57.116 --> 00:02:58.376 A:middle
So that's great, right?

00:02:59.316 --> 00:03:01.206 A:middle
Turns out it's actually worse



00:02:59.316 --> 00:03:01.206 A:middle
Turns out it's actually worse

00:03:01.206 --> 00:03:03.336 A:middle
for cellular carriers
than it was before.

00:03:04.286 --> 00:03:09.636 A:middle
And the reason is now they are
having to support both IPv4

00:03:10.036 --> 00:03:12.156 A:middle
as well as IPv6 in
their network.

00:03:13.416 --> 00:03:16.816 A:middle
So what they really want
to do is to drop IPv4

00:03:17.116 --> 00:03:18.286 A:middle
from their access network.

00:03:19.246 --> 00:03:21.726 A:middle
Now, when you do that,
you lose connectivity

00:03:21.726 --> 00:03:23.896 A:middle
to the IPv4-only
part of the Internet,

00:03:24.376 --> 00:03:25.616 A:middle
which is still in majority.

00:03:27.676 --> 00:03:31.806 A:middle
So now they have deployed DNS64
and NAT64 in their network,

00:03:32.306 --> 00:03:35.246 A:middle
and the way it works
is when the application

00:03:35.246 --> 00:03:37.906 A:middle
on the client device
makes a hostname query

00:03:38.206 --> 00:03:41.836 A:middle
to get the IPv6 address
for an IPv4-only server,

00:03:42.616 --> 00:03:47.186 A:middle
DNS64 and the network
synthesizes an IPv6 address

00:03:47.186 --> 00:03:48.826 A:middle
and gives it back to
the client device.

00:03:49.106 --> 00:03:53.956 A:middle
Now that the client device has
this IPv6 address to work with,

00:03:54.236 --> 00:03:56.316 A:middle
it can start writing
traffic to the network.

00:03:57.636 --> 00:03:59.986 A:middle
The network itself is
configured in a way



00:04:00.046 --> 00:04:03.696 A:middle
that search packets get
shorted to the NAT64 engine,

00:04:04.226 --> 00:04:08.376 A:middle
which then translates
IPv6 traffic to IPv4

00:04:08.646 --> 00:04:09.906 A:middle
and vice versa on the way back.

00:04:10.436 --> 00:04:14.366 A:middle
Now, the important
thing to note here is

00:04:14.366 --> 00:04:17.676 A:middle
that to the applications
running on the client device,

00:04:18.546 --> 00:04:23.716 A:middle
your IPv4-only server looks
like an IPv6-only server.

00:04:24.556 --> 00:04:27.396 A:middle
And this is important
because till now,

00:04:27.396 --> 00:04:29.076 A:middle
some of you in the room
may have been thinking

00:04:29.076 --> 00:04:32.466 A:middle
that my server is only
configured for IPv4,

00:04:32.786 --> 00:04:34.336 A:middle
so I do not need to test

00:04:34.336 --> 00:04:37.596 A:middle
for a client accessing
it over an IPv6 network.

00:04:39.046 --> 00:04:40.746 A:middle
Your assumption just got broken.

00:04:41.246 --> 00:04:43.626 A:middle
Now the transition to this type

00:04:43.626 --> 00:04:46.756 A:middle
of network will happen very
soon, and when it happens,

00:04:47.756 --> 00:04:50.606 A:middle
we want it to be an
absolutely seamless experience

00:04:50.606 --> 00:04:51.336 A:middle
for our consumers.

00:04:52.286 --> 00:04:58.896 A:middle
And that is the reason your
app has to be IPv6 compliant,



00:05:00.206 --> 00:05:02.686 A:middle
and this will be an app
submission requirement.

00:05:04.176 --> 00:05:06.506 A:middle
So great, we have a new app
submission requirement, right?

00:05:06.506 --> 00:05:09.686 A:middle
And you must be wondering
how do I test my application

00:05:09.686 --> 00:05:10.356 A:middle
for this network?

00:05:11.016 --> 00:05:13.296 A:middle
Where will I find this
NAT64 type of network?

00:05:14.336 --> 00:05:16.686 A:middle
I have a great news
for all of you.

00:05:18.776 --> 00:05:22.736 A:middle
Starting today, with just
your Mac devices on top

00:05:22.736 --> 00:05:27.066 A:middle
of IPv4 connectivity, you can
create your very own NAT64

00:05:27.066 --> 00:05:29.576 A:middle
networks and start
testing your applications.

00:05:29.786 --> 00:05:33.566 A:middle
Now, this feature is meant
to be used by the developers,

00:05:33.776 --> 00:05:37.396 A:middle
so it's somewhat hidden, and to
make it visible, all you have

00:05:37.396 --> 00:05:44.366 A:middle
to do is to Option-click on
Sharing, then Option-click

00:05:44.366 --> 00:05:48.006 A:middle
on Internet Sharing, and now you
will see everything looks just

00:05:48.006 --> 00:05:48.536 A:middle
the same.

00:05:49.446 --> 00:05:51.436 A:middle
But there's a new
checkbox here that says

00:05:51.846 --> 00:05:53.616 A:middle
"Create NAT64 Network."

00:05:53.616 --> 00:05:58.206 A:middle
So you check that, you
choose your interfaces

00:05:58.206 --> 00:06:02.146 A:middle
for Internet sharing, and now
you can host this NAT64 network



00:05:58.206 --> 00:06:02.146 A:middle
for Internet sharing, and now
you can host this NAT64 network

00:06:03.236 --> 00:06:04.886 A:middle
and start testing
your applications.

00:06:05.776 --> 00:06:09.936 A:middle
Now, for the example here,
I have my IPv4 connectivity

00:06:10.066 --> 00:06:12.436 A:middle
on the Internet and
I'm sharing this

00:06:12.436 --> 00:06:17.566 A:middle
as an IPv6-only access
network with NAT64/DNS64

00:06:17.676 --> 00:06:18.766 A:middle
on my Wi-Fi interface.

00:06:19.826 --> 00:06:25.286 A:middle
So when I start it, I see that
the Wi-Fi icon has grayed out

00:06:25.286 --> 00:06:27.806 A:middle
and it has an arrow pointing up.

00:06:29.056 --> 00:06:31.796 A:middle
That means now the
Wi-Fi interface is

00:06:31.796 --> 00:06:33.836 A:middle
in access point mode.

00:06:34.536 --> 00:06:37.916 A:middle
What that really means is now
it's hosting a Wi-Fi hotspot,

00:06:37.916 --> 00:06:40.056 A:middle
and you can connect your
other client devices

00:06:40.206 --> 00:06:41.606 A:middle
and start testing
your applications.

00:06:42.486 --> 00:06:46.456 A:middle
Now, a typical test bed
will look like this.

00:06:46.676 --> 00:06:49.856 A:middle
Now, here I have my IPv4
Internet connectivity

00:06:50.066 --> 00:06:54.136 A:middle
on the WAN side, my iMac has
the DNS64/NAT64 engine running

00:06:54.136 --> 00:06:58.836 A:middle
on it, and it is hosting an IPv6
network on the Wi-Fi interface.



00:07:00.096 --> 00:07:03.246 A:middle
Now the application that you
want to test is either installed

00:07:03.246 --> 00:07:04.666 A:middle
in one of the client machines,

00:07:05.196 --> 00:07:07.076 A:middle
or you could very
well be testing it

00:07:07.076 --> 00:07:08.726 A:middle
on a simulator that's running

00:07:08.726 --> 00:07:11.236 A:middle
on another Mac device
that's a client

00:07:11.236 --> 00:07:12.776 A:middle
of this Internet
sharing environment.

00:07:13.196 --> 00:07:18.516 A:middle
So now that we have made testing
easy for you, for this type

00:07:18.516 --> 00:07:21.816 A:middle
of network, what we
really want you to do is

00:07:21.856 --> 00:07:25.356 A:middle
to make sure it is part of
your development process.

00:07:26.166 --> 00:07:28.826 A:middle
That is, any time you are
writing a new application,

00:07:29.126 --> 00:07:31.396 A:middle
or you are writing an
update for your application,

00:07:31.786 --> 00:07:33.126 A:middle
make sure you are testing

00:07:33.126 --> 00:07:36.906 A:middle
for NAT64 network
environment before you submit

00:07:36.906 --> 00:07:37.686 A:middle
your applications.

00:07:37.976 --> 00:07:44.036 A:middle
Now, the good news is for
almost 70% of you, you will see

00:07:44.036 --> 00:07:46.496 A:middle
that your applications
are working just fine.

00:07:46.776 --> 00:07:47.956 A:middle
And that's great, right?

00:07:48.736 --> 00:07:50.436 A:middle
Just keep testing
your applications,

00:07:50.726 --> 00:07:54.066 A:middle
release after release and make
sure there's no regression.

00:07:54.616 --> 00:07:58.576 A:middle
But for almost a third
of you, you will see

00:07:58.576 --> 00:08:01.846 A:middle
that either your application
is severely limited



00:07:58.576 --> 00:08:01.846 A:middle
that either your application
is severely limited

00:08:01.846 --> 00:08:05.746 A:middle
in a NAT64 network environment
or it does not work at all.

00:08:07.206 --> 00:08:09.966 A:middle
Now, fortunately, most of
the issues are simple to fix,

00:08:10.716 --> 00:08:18.746 A:middle
and here's a sample list.

00:08:18.926 --> 00:08:23.346 A:middle
Now, if you are using only
IPv4-only data structures

00:08:23.346 --> 00:08:28.196 A:middle
or IPv4-only APIs, or
you are using an API

00:08:28.196 --> 00:08:30.706 A:middle
that supports both
IPv4 and IPv6,

00:08:31.346 --> 00:08:34.416 A:middle
but maybe you're passing
an argument that says

00:08:34.885 --> 00:08:38.586 A:middle
that only get me
results for IPv4,

00:08:38.586 --> 00:08:43.655 A:middle
all of these things will make
your application IPv4 only.

00:08:44.216 --> 00:08:46.486 A:middle
And what that means
is it will not work

00:08:46.486 --> 00:08:48.906 A:middle
in an IPv6-only access
network environment.

00:08:49.426 --> 00:08:53.496 A:middle
Now, there's another interesting
thing that we have seen

00:08:53.496 --> 00:08:56.256 A:middle
with some of these
applications that do not work,

00:08:57.786 --> 00:09:00.216 A:middle
that sometimes there's a
preflight check that checks



00:08:57.786 --> 00:09:00.216 A:middle
that sometimes there's a
preflight check that checks

00:09:00.216 --> 00:09:03.886 A:middle
for IPv4 connectivity even
before attempting a connection.

00:09:05.046 --> 00:09:09.566 A:middle
And that is the reason sometimes
you get errors like this.

00:09:10.516 --> 00:09:14.716 A:middle
So in this case, my iPhone
was actually connected

00:09:14.716 --> 00:09:17.736 A:middle
to the NAT64 network I had
just created on my Mac device,

00:09:18.476 --> 00:09:20.726 A:middle
and I could browse
Internet with Safari,

00:09:20.726 --> 00:09:22.856 A:middle
I could stream videos, music...

00:09:23.666 --> 00:09:25.226 A:middle
I had my Internet connectivity,

00:09:25.666 --> 00:09:29.156 A:middle
but for some reason this
application thinks I have no

00:09:29.156 --> 00:09:30.576 A:middle
Internet connectivity
whatsoever.

00:09:31.296 --> 00:09:34.366 A:middle
And if you read the
error message it says

00:09:34.366 --> 00:09:37.886 A:middle
that my device is in
airplane mode, but if you look

00:09:37.886 --> 00:09:40.636 A:middle
at the top bar, that's
not the case, right?

00:09:42.066 --> 00:09:43.956 A:middle
So what's going on here?

00:09:44.416 --> 00:09:47.346 A:middle
It's precisely the application
making a preflight check

00:09:47.376 --> 00:09:50.816 A:middle
to check for IPv4 connectivity,
and if you remember,

00:09:51.276 --> 00:09:54.426 A:middle
in IPv6-only access
network like NAT64 network,

00:09:55.066 --> 00:09:57.596 A:middle
you do not have IPv4
connectivity;

00:09:57.656 --> 00:10:01.156 A:middle
the entire world looks like
an IPv6-only world to you.



00:09:57.656 --> 00:10:01.156 A:middle
the entire world looks like
an IPv6-only world to you.

00:10:01.546 --> 00:10:05.286 A:middle
Even the IPv4-only server
looks like an IPv6-only server.

00:10:05.666 --> 00:10:07.446 A:middle
So if you do this
check, it will fail.

00:10:08.386 --> 00:10:11.056 A:middle
Now, in this case,
application is saying retry.

00:10:11.056 --> 00:10:14.006 A:middle
So I retried and it gave
me the same error message,

00:10:14.366 --> 00:10:16.606 A:middle
and then I retried again,
and the same error message.

00:10:17.236 --> 00:10:19.406 A:middle
And it never went off,
and I was just stuck

00:10:19.406 --> 00:10:20.296 A:middle
with this application.

00:10:21.226 --> 00:10:22.836 A:middle
So, what are the
recommendations?

00:10:23.226 --> 00:10:26.596 A:middle
Well, just attempt a connection.

00:10:27.966 --> 00:10:30.156 A:middle
Right? If it connects,
that's great.

00:10:30.156 --> 00:10:33.416 A:middle
If it does not, then
handle that case gracefully.

00:10:34.656 --> 00:10:36.606 A:middle
The second recommendation
would be

00:10:36.606 --> 00:10:40.466 A:middle
to use higher networking
frameworks like NSURLSession

00:10:41.036 --> 00:10:47.076 A:middle
or CFNetwork API, and
the reason is networking

00:10:48.016 --> 00:10:50.456 A:middle
with multihome devices
like iPhone

00:10:51.346 --> 00:10:54.456 A:middle
and Mac devices can
be somewhat complex.

00:10:54.956 --> 00:10:57.836 A:middle
Like for iPhone, you
have Wi-Fi interface

00:10:57.836 --> 00:10:59.396 A:middle
and you have cellular interface.

00:10:59.586 --> 00:11:02.176 A:middle
And with Mac devices, you
may have multiple Ethernet



00:10:59.586 --> 00:11:02.176 A:middle
And with Mac devices, you
may have multiple Ethernet

00:11:02.176 --> 00:11:04.726 A:middle
interfaces, and you have
a Wi-Fi interface also,

00:11:05.186 --> 00:11:07.466 A:middle
and at a given time, you
may have different kinds

00:11:07.466 --> 00:11:09.886 A:middle
of connectivity to
all these interfaces.

00:11:11.366 --> 00:11:16.126 A:middle
Now, which interface you use
and how to connect which type

00:11:16.126 --> 00:11:18.326 A:middle
of connectivity do you use
for a given destination,

00:11:18.886 --> 00:11:22.096 A:middle
writing that code yourself
can be a lot tedious.

00:11:22.726 --> 00:11:25.566 A:middle
So please use higher
networking frameworks.

00:11:25.896 --> 00:11:29.276 A:middle
It will make your application
code a lot cleaner and simpler.

00:11:29.276 --> 00:11:34.426 A:middle
Now if for some reason you
cannot use a higher networking

00:11:34.426 --> 00:11:37.186 A:middle
framework and if you are
having to work with sockets,

00:11:37.346 --> 00:11:42.786 A:middle
we will definitely recommend you
to read RFC 4038, and it talks

00:11:42.786 --> 00:11:45.776 A:middle
about in great length how
to write your applications

00:11:46.026 --> 00:11:47.916 A:middle
in a way that's address-family
agnostic.

00:11:50.296 --> 00:11:54.366 A:middle
Now, our final recommendation
would be to use hostnames

00:11:54.366 --> 00:11:57.106 A:middle
when possible and not to
use IP address literals,

00:11:57.286 --> 00:11:58.676 A:middle
whether IPv4 or IPv6.

00:11:58.676 --> 00:12:02.266 A:middle
When you are writing
your very own protocol,



00:11:58.676 --> 00:12:02.266 A:middle
When you are writing
your very own protocol,

00:12:02.266 --> 00:12:04.506 A:middle
a proprietary protocol, or
when you are writing your

00:12:04.506 --> 00:12:08.156 A:middle
application, make sure you are
not using IP address literals

00:12:08.556 --> 00:12:09.746 A:middle
but preferring hostnames.

00:12:10.216 --> 00:12:11.626 A:middle
And the reason is, remember,

00:12:11.986 --> 00:12:14.376 A:middle
in a NAT64/DNS64
network environment,

00:12:15.466 --> 00:12:18.106 A:middle
the client device first has
to make a DNS query, right?

00:12:18.406 --> 00:12:20.526 A:middle
To get the IPv6 address
for the IPv4 server.

00:12:20.656 --> 00:12:22.936 A:middle
So you have to work
with the hostname.

00:12:23.246 --> 00:12:25.526 A:middle
If you are working with
an IPv4 address literal,

00:12:26.116 --> 00:12:28.426 A:middle
the client device will
not make that DNS query,

00:12:28.726 --> 00:12:32.546 A:middle
and the DNS64 network will not
synthesize the IPv6 address

00:12:32.546 --> 00:12:32.856 A:middle
for you.

00:12:33.416 --> 00:12:39.266 A:middle
So, given that, we do understand
that sometimes there's no way

00:12:39.266 --> 00:12:44.416 A:middle
to avoid working with an
IPv4 address, and an example

00:12:44.416 --> 00:12:45.506 A:middle
of that would be Safari.

00:12:46.096 --> 00:12:48.676 A:middle
So you go to a web page,
it loads up just fine.

00:12:49.266 --> 00:12:52.356 A:middle
But within the web page,
there may be some other links,

00:12:52.906 --> 00:12:57.326 A:middle
and some of those links may
have IPv4 addresses embedded.

00:12:59.166 --> 00:13:02.276 A:middle
Now, before today, on
Safari if you clicked on one



00:12:59.166 --> 00:13:02.276 A:middle
Now, before today, on
Safari if you clicked on one

00:13:02.276 --> 00:13:04.726 A:middle
such link, it would not load up.

00:13:05.696 --> 00:13:13.236 A:middle
Starting iOS 9 and OS X 10.11,
not only Safari but any user

00:13:13.236 --> 00:13:18.956 A:middle
of NSURLSession or CFNetwork
API will be able to work even

00:13:18.956 --> 00:13:23.266 A:middle
with IPv4 address literals
in a NAT64/DNS64 network.

00:13:24.596 --> 00:13:26.746 A:middle
The way it works is when
you are using hostnames,

00:13:27.536 --> 00:13:30.816 A:middle
the DNS64 in the network is
synthesizing IPv6 addresses

00:13:30.816 --> 00:13:31.396 A:middle
for you.

00:13:32.546 --> 00:13:35.866 A:middle
But when you are working
with an IPv4 address literal

00:13:35.866 --> 00:13:38.126 A:middle
and using one of the
higher networking API,

00:13:39.016 --> 00:13:42.826 A:middle
the OS is discovering what
the network would have done

00:13:42.896 --> 00:13:45.526 A:middle
and how it would have
synthesized an IPv6 address

00:13:45.526 --> 00:13:47.696 A:middle
for you, and it will
do that locally.

00:13:48.276 --> 00:13:51.586 A:middle
So this is another reason
why you should be working

00:13:51.586 --> 00:13:53.016 A:middle
with higher network frameworks.

00:13:53.016 --> 00:13:56.446 A:middle
So please do that.

00:13:56.656 --> 00:14:00.936 A:middle
Now, with these data points
and with the new tool,



00:13:56.656 --> 00:14:00.936 A:middle
Now, with these data points
and with the new tool,

00:14:01.276 --> 00:14:04.396 A:middle
we really hope that you will
be able to find and fix issues

00:14:04.396 --> 00:14:05.496 A:middle
with your applications.

00:14:07.406 --> 00:14:12.036 A:middle
Now, what we want you to do
is after this session is over,

00:14:12.426 --> 00:14:14.826 A:middle
install the seed build
on your Mac devices

00:14:15.226 --> 00:14:17.916 A:middle
and start creating your
very own NAT64 networks,

00:14:18.156 --> 00:14:20.306 A:middle
and then use them to
test your applications.

00:14:21.496 --> 00:14:24.786 A:middle
Now, remember this will be an
app submission requirement.

00:14:25.716 --> 00:14:29.246 A:middle
So please take this message to
other developers who are not

00:14:29.246 --> 00:14:31.676 A:middle
in this session and also
take this message back

00:14:31.676 --> 00:14:34.696 A:middle
to your company and make sure
you are doing NAT64 testing

00:14:35.016 --> 00:14:35.896 A:middle
for your applications.

00:14:36.336 --> 00:14:43.036 A:middle
Now, with that, I now invite
Stuart Cheshire to talk

00:14:43.036 --> 00:14:45.346 A:middle
about other networking
features we have for you

00:14:45.746 --> 00:14:48.106 A:middle
that make your applications
faster

00:14:48.446 --> 00:14:50.486 A:middle
and be more responsive
to the users.

00:14:51.256 --> 00:14:51.856 A:middle
Stuart?

00:14:52.516 --> 00:14:58.636 A:middle
[Applause]

00:14:59.136 --> 00:14:59.916 A:middle
&gt;&gt; STUART CHESHIRE:
Thank you, Prabhakar.



00:15:02.546 --> 00:15:06.406 A:middle
What I want to talk about now
is making your applications

00:15:06.406 --> 00:15:07.076 A:middle
run faster.

00:15:09.116 --> 00:15:10.536 A:middle
In the last couple of decades,

00:15:10.606 --> 00:15:14.076 A:middle
we have seen a phenomenal
increase in network throughput.

00:15:15.036 --> 00:15:19.056 A:middle
I remember a time when the
56-kilobit modem was the latest

00:15:19.056 --> 00:15:21.366 A:middle
technology; now we
live in a world

00:15:21.366 --> 00:15:24.676 A:middle
where 50 megabits per
second is quite commonplace.

00:15:25.596 --> 00:15:27.776 A:middle
But things don't feel a
thousand times faster.

00:15:28.616 --> 00:15:31.056 A:middle
We still spend a lot
of time sitting waiting

00:15:31.056 --> 00:15:32.136 A:middle
for a web page to load.

00:15:32.426 --> 00:15:33.146 A:middle
And why is that?

00:15:34.716 --> 00:15:38.296 A:middle
It's because our industry
has put a huge focus

00:15:38.396 --> 00:15:39.956 A:middle
on increasing throughput

00:15:41.166 --> 00:15:44.986 A:middle
and it has sorely neglected
the other sources of delay.

00:15:46.156 --> 00:15:48.016 A:middle
The speed of light
hasn't gotten any faster

00:15:48.916 --> 00:15:52.006 A:middle
and we can't do anything about
that, but there are other areas

00:15:52.006 --> 00:15:54.286 A:middle
of delay that we can
fix and it's time

00:15:54.286 --> 00:15:55.346 A:middle
for us to start doing that.

00:15:56.176 --> 00:15:58.486 A:middle
So that's what I'm going
to talk about today.

00:15:59.316 --> 00:16:03.286 A:middle
I'm going to talk about
four sources of delay



00:15:59.316 --> 00:16:03.286 A:middle
I'm going to talk about
four sources of delay

00:16:03.906 --> 00:16:05.806 A:middle
when users are using
your applications.

00:16:06.976 --> 00:16:09.776 A:middle
The first one is the
delay that happens

00:16:10.056 --> 00:16:12.936 A:middle
when you have weak
Wi-Fi connectivity,

00:16:13.306 --> 00:16:14.986 A:middle
and connection attempts
are not succeeding.

00:16:15.976 --> 00:16:19.896 A:middle
The second area is a technique
called Explicit Congestion

00:16:19.896 --> 00:16:21.936 A:middle
Notification, which along

00:16:21.936 --> 00:16:25.916 A:middle
with smart queuing reduces
delays in the network.

00:16:27.036 --> 00:16:32.096 A:middle
The TCP NOTSENT Low-Water
Mark option reduces delays

00:16:32.516 --> 00:16:35.556 A:middle
in the sending machine, and
then we are going to finish

00:16:35.556 --> 00:16:36.976 A:middle
up with a sneak peek

00:16:37.096 --> 00:16:39.916 A:middle
of an exciting new technology
called TCP Fast Open.

00:16:40.746 --> 00:16:44.226 A:middle
So let's start off with
reliable network fallback.

00:16:45.406 --> 00:16:48.706 A:middle
I'm sure everybody in this
room has had the experience

00:16:48.986 --> 00:16:52.276 A:middle
at the end of the
day: They leave work.

00:16:52.576 --> 00:16:53.976 A:middle
They go out to their car.

00:16:54.096 --> 00:16:55.046 A:middle
They pull out their phone.

00:16:55.736 --> 00:17:01.856 A:middle
You want to check maps, weather
forecast, email, whatever,



00:16:55.736 --> 00:17:01.856 A:middle
You want to check maps, weather
forecast, email, whatever,

00:17:02.046 --> 00:17:04.496 A:middle
and you are staring at the
phone and it's not loading

00:17:04.576 --> 00:17:06.695 A:middle
and it's not loading and
you are walking to your car,

00:17:06.695 --> 00:17:08.786 A:middle
and it's still not loading
and you get frustrated,

00:17:08.786 --> 00:17:11.356 A:middle
you go into Settings,
you turn Wi-Fi off.

00:17:11.556 --> 00:17:12.756 A:middle
Now you're on LTE and bam!

00:17:12.756 --> 00:17:13.846 A:middle
The page loads.

00:17:15.076 --> 00:17:17.165 A:middle
And then you forget
to turn Wi-Fi back on,

00:17:17.165 --> 00:17:19.536 A:middle
and a week later you've got
a huge cellular data bill

00:17:19.536 --> 00:17:20.205 A:middle
that you didn't want.

00:17:20.386 --> 00:17:22.715 A:middle
Well, that's not a
good user experience.

00:17:23.366 --> 00:17:28.156 A:middle
What we are doing now is we
have some intelligent logic

00:17:28.465 --> 00:17:30.166 A:middle
about doing parallel
connections.

00:17:31.016 --> 00:17:33.346 A:middle
So if your iPhone
thinks it's on Wi-Fi,

00:17:34.806 --> 00:17:38.326 A:middle
but the TCP connection setup
attempt is not succeeding,

00:17:38.906 --> 00:17:44.636 A:middle
then very rapidly, it will
initiate a second parallel

00:17:44.666 --> 00:17:47.356 A:middle
connection over cellular data.

00:17:47.426 --> 00:17:49.996 A:middle
Now, it won't kill
the Wi-Fi connection.

00:17:49.996 --> 00:17:50.976 A:middle
It won't give up on it.

00:17:50.976 --> 00:17:54.186 A:middle
It will let that one continue
to run in parallel and if

00:17:54.186 --> 00:17:56.496 A:middle
that one completes
first, that's great.

00:17:56.706 --> 00:17:58.126 A:middle
You have a connection
over Wi-Fi.

00:17:58.126 --> 00:18:02.396 A:middle
But if it doesn't, and the
cellular connection completes



00:17:58.126 --> 00:18:02.396 A:middle
But if it doesn't, and the
cellular connection completes

00:18:02.396 --> 00:18:05.536 A:middle
first, then that's the
connection your application will

00:18:05.536 --> 00:18:10.186 A:middle
get with a delay so short, the
user won't notice anything odd.

00:18:10.186 --> 00:18:13.636 A:middle
Of course, we only
use this for apps

00:18:13.676 --> 00:18:15.456 A:middle
that are allowed to
use cellular data.

00:18:15.966 --> 00:18:17.676 A:middle
If the user has gone
into the settings

00:18:17.676 --> 00:18:19.796 A:middle
and turned off mobile
data for that app,

00:18:19.846 --> 00:18:20.886 A:middle
we won't do the fallback.

00:18:22.056 --> 00:18:25.166 A:middle
And if we do fall back, then
we hide the Wi-Fi indicator,

00:18:25.606 --> 00:18:28.506 A:middle
so now the user knows they
are not on Wi-Fi anymore.

00:18:29.026 --> 00:18:32.936 A:middle
This is something
that you get for free,

00:18:33.346 --> 00:18:36.636 A:middle
as long as you are using
the higher layer APIs,

00:18:37.306 --> 00:18:40.966 A:middle
and you should see no difference
in your applications apart

00:18:40.966 --> 00:18:42.646 A:middle
from a better user experience.

00:18:44.016 --> 00:18:45.896 A:middle
There's one additional
thing you can do,

00:18:46.816 --> 00:18:50.616 A:middle
and that is when you are
running over cellular,

00:18:52.106 --> 00:18:54.686 A:middle
whether you started on cellular
or whether you fell back

00:18:54.686 --> 00:18:56.356 A:middle
to cellular, doesn't matter.

00:18:56.356 --> 00:19:01.056 A:middle
The user can walk back in range
of Wi-Fi and at that point,



00:18:56.356 --> 00:19:01.056 A:middle
The user can walk back in range
of Wi-Fi and at that point,

00:19:01.286 --> 00:19:04.046 A:middle
if you pay attention to the
Better Route notification,

00:19:04.626 --> 00:19:06.676 A:middle
you can then decide
what to do about that.

00:19:07.356 --> 00:19:09.976 A:middle
You may want to tear down
the connections you have

00:19:09.976 --> 00:19:15.066 A:middle
and reconnect over Wi-Fi,
or if you are 99% of the way

00:19:15.116 --> 00:19:17.436 A:middle
through sending an email,
you may want to just let

00:19:17.436 --> 00:19:19.636 A:middle
that complete, but
by paying attention

00:19:19.636 --> 00:19:21.176 A:middle
to the Better Route
notification,

00:19:21.466 --> 00:19:23.116 A:middle
you can make an intelligent
decision

00:19:23.426 --> 00:19:26.336 A:middle
that minimizes the
user's cellular data bill.

00:19:27.316 --> 00:19:33.476 A:middle
My next topic is
delays in the network.

00:19:35.006 --> 00:19:39.646 A:middle
And this is something that came
out of work I did on Apple TV.

00:19:39.646 --> 00:19:43.376 A:middle
We are working on trying to
make Apple TV more responsive

00:19:43.726 --> 00:19:45.676 A:middle
and understanding where
the delays came from.

00:19:46.406 --> 00:19:49.196 A:middle
And I expect everybody
in this room has heard

00:19:49.196 --> 00:19:50.226 A:middle
about bufferbloat.

00:19:51.376 --> 00:19:54.756 A:middle
I did some experiments, and
I want to share the results

00:19:54.756 --> 00:19:56.116 A:middle
of those experiments with you

00:19:56.406 --> 00:20:00.366 A:middle
so you can understand too how
critically important it is



00:19:56.406 --> 00:20:00.366 A:middle
so you can understand too how
critically important it is

00:20:00.366 --> 00:20:02.316 A:middle
for all of our applications
and products

00:20:02.626 --> 00:20:04.356 A:middle
that we fix bufferbloat
in the network.

00:20:05.696 --> 00:20:09.206 A:middle
I tested a simulated
network environment

00:20:09.676 --> 00:20:14.516 A:middle
with a 10-megabit downstream
connection, which is plenty

00:20:14.516 --> 00:20:18.506 A:middle
for watching streaming
video, and first I'm going

00:20:18.506 --> 00:20:24.656 A:middle
to show you the results using
a representative network setup,

00:20:25.186 --> 00:20:28.046 A:middle
a simpleminded first-in,
first-out queue

00:20:28.416 --> 00:20:30.586 A:middle
where packets are buffered
until the queue is full

00:20:30.586 --> 00:20:34.236 A:middle
and can't hold anymore, and then
the new arrivals get dropped.

00:20:35.016 --> 00:20:38.416 A:middle
This is very typical of
consumer home gateways today.

00:20:38.446 --> 00:20:42.326 A:middle
And then I will show you a
comparison using smarter queuing

00:20:42.326 --> 00:20:42.866 A:middle
and ECN.

00:20:44.536 --> 00:20:48.086 A:middle
I'm going to show you some
plots generated using tcptrace.

00:20:49.026 --> 00:20:52.486 A:middle
I expect many people in this
room have used tcptrace,

00:20:52.826 --> 00:20:56.346 A:middle
but if you haven't, I
strongly urge you to go

00:20:56.346 --> 00:20:58.896 A:middle
to TCPtrace.org and download it.

00:20:59.786 --> 00:21:02.846 A:middle
If you are working
on networking code,



00:20:59.786 --> 00:21:02.846 A:middle
If you are working
on networking code,

00:21:03.366 --> 00:21:06.226 A:middle
and you are not using tcptrace
to look at your packets,

00:21:06.566 --> 00:21:10.676 A:middle
then you have no way to
really know what is going on

00:21:10.916 --> 00:21:13.116 A:middle
or understand the
performance characteristics

00:21:13.326 --> 00:21:15.376 A:middle
of your app and your protocol.

00:21:16.086 --> 00:21:19.766 A:middle
When we write apps, we pay
attention to the memory usage.

00:21:20.496 --> 00:21:24.196 A:middle
We profile the code to find
out what's taking the CPU

00:21:24.616 --> 00:21:26.586 A:middle
and then we optimize
the code that needs it

00:21:26.726 --> 00:21:29.746 A:middle
to improve CPU efficiency
and improve battery life.

00:21:31.176 --> 00:21:36.246 A:middle
To do those things, to care
that much about CPU and memory,

00:21:36.756 --> 00:21:39.756 A:middle
but neglect the networking
part doesn't make any sense.

00:21:39.886 --> 00:21:43.596 A:middle
And tcptrace is the tool
that lets you do similar kind

00:21:43.596 --> 00:21:45.936 A:middle
of profiling and analysis
of your network traffic.

00:21:45.936 --> 00:21:51.836 A:middle
Here's a TCP trace of
the first 10 seconds

00:21:52.126 --> 00:21:53.496 A:middle
of some streaming video.

00:21:53.956 --> 00:21:56.246 A:middle
For those of you who haven't
looked at tcptrace before,

00:21:56.246 --> 00:21:58.256 A:middle
I will give a quick overview.

00:21:58.966 --> 00:22:01.766 A:middle
The little white lines
represent data packets.



00:21:58.966 --> 00:22:01.766 A:middle
The little white lines
represent data packets.

00:22:02.816 --> 00:22:07.396 A:middle
The horizontal position of that
white line tells you the moment

00:22:07.396 --> 00:22:08.926 A:middle
in time where the
packet was captured.

00:22:10.016 --> 00:22:15.076 A:middle
The height of the white line
tells you how many bytes

00:22:15.076 --> 00:22:18.346 A:middle
of payload are in the packets,
and the vertical position

00:22:18.346 --> 00:22:21.816 A:middle
of where that line appears
tells you where those bytes fall

00:22:22.186 --> 00:22:25.936 A:middle
within the overall logical
TCP sequence number space.

00:22:26.996 --> 00:22:30.256 A:middle
So here we can see a stream of
packets being sent out in order,

00:22:30.966 --> 00:22:33.276 A:middle
spaced a few microseconds apart.

00:22:34.656 --> 00:22:37.426 A:middle
One round trip later, we
get the acknowledgment back

00:22:37.426 --> 00:22:39.166 A:middle
from the receiver
saying it was received.

00:22:40.346 --> 00:22:44.036 A:middle
And that green line is the
cumulative acknowledgment line.

00:22:44.496 --> 00:22:47.516 A:middle
Everything up to and including
the green line has been

00:22:47.516 --> 00:22:48.806 A:middle
acknowledged by the receiver.

00:22:49.626 --> 00:22:53.786 A:middle
So we should never see any white
packets below the green line.

00:22:54.416 --> 00:22:55.556 A:middle
That would indicate a bug,

00:22:56.356 --> 00:22:59.106 A:middle
and we don't see any white
packets below the line,

00:22:59.106 --> 00:22:59.696 A:middle
so that's good.

00:22:59.736 --> 00:23:04.596 A:middle
The yellow line indicates
the receive window.



00:22:59.736 --> 00:23:04.596 A:middle
The yellow line indicates
the receive window.

00:23:05.286 --> 00:23:06.906 A:middle
When you open up
a TCP connection,

00:23:06.906 --> 00:23:10.406 A:middle
the receiver indicates how
much RAM it has put aside

00:23:11.586 --> 00:23:16.526 A:middle
for your data, and you should
not exceed the amount of RAM

00:23:16.526 --> 00:23:17.886 A:middle
that you have been allocated.

00:23:18.546 --> 00:23:22.036 A:middle
If we see any white packets
above the yellow line,

00:23:22.346 --> 00:23:24.156 A:middle
then that would be
a bug, and we don't.

00:23:24.376 --> 00:23:27.046 A:middle
So that's good.

00:23:27.716 --> 00:23:30.906 A:middle
This looks look a
relatively nice,

00:23:30.986 --> 00:23:33.486 A:middle
straight line data transfer.

00:23:33.486 --> 00:23:37.086 A:middle
The slope of that curve is
exactly 10 megabits per second,

00:23:37.816 --> 00:23:41.996 A:middle
which is what we expect,
but every few seconds,

00:23:42.086 --> 00:23:43.706 A:middle
we see something
like this going on.

00:23:44.236 --> 00:23:48.576 A:middle
So let's zoom in and
take a closer look

00:23:48.806 --> 00:23:51.016 A:middle
at what's going on down there.

00:23:52.616 --> 00:23:56.216 A:middle
There is so much information
on these TCP trace plots,

00:23:56.736 --> 00:23:59.636 A:middle
I could spend an hour just
talking about this one slide.

00:23:59.986 --> 00:24:01.686 A:middle
But we don't have time for that,



00:23:59.986 --> 00:24:01.686 A:middle
But we don't have time for that,

00:24:02.056 --> 00:24:06.216 A:middle
so I will just cover some
highlights that jump out just

00:24:06.216 --> 00:24:07.786 A:middle
with a glance at this plot.

00:24:09.296 --> 00:24:14.426 A:middle
One is the white packet
line is kind of pulling away

00:24:15.246 --> 00:24:16.986 A:middle
from the green ack line.

00:24:17.726 --> 00:24:20.906 A:middle
What that means is the rate
that we are injecting data

00:24:20.906 --> 00:24:25.696 A:middle
into the network is faster
than the rate data is coming

00:24:25.786 --> 00:24:27.606 A:middle
out of the other side
and being acknowledged.

00:24:28.066 --> 00:24:30.836 A:middle
Well, if we are putting
it in faster

00:24:30.836 --> 00:24:33.976 A:middle
than we are pulling it
out, something has got

00:24:33.976 --> 00:24:34.866 A:middle
to be going somewhere.

00:24:35.396 --> 00:24:40.526 A:middle
It's sitting in buffers and
we can see that the amount

00:24:40.686 --> 00:24:44.606 A:middle
of stale data sitting in buffers
in the network is growing.

00:24:45.246 --> 00:24:47.426 A:middle
And because the amount
of buffering is growing,

00:24:47.856 --> 00:24:51.676 A:middle
that means the round trip delay
between when a packet is sent

00:24:51.756 --> 00:24:54.456 A:middle
and when it's acknowledged
is getting longer.

00:24:55.226 --> 00:24:58.296 A:middle
When we have so much buffered

00:24:58.336 --> 00:25:01.096 A:middle
that the gateway
can't buffer anymore,



00:24:58.336 --> 00:25:01.096 A:middle
that the gateway
can't buffer anymore,

00:25:01.316 --> 00:25:02.666 A:middle
we start losing packets.

00:25:03.236 --> 00:25:08.126 A:middle
And then this mess happens, and
it really is quite a big mess,

00:25:08.436 --> 00:25:13.176 A:middle
because packets are coming into
the tail of the queue faster

00:25:13.256 --> 00:25:18.206 A:middle
than the queue is draining, and
we get a packet, we lose it,

00:25:18.726 --> 00:25:20.116 A:middle
we get another one, we lose it.

00:25:20.396 --> 00:25:22.936 A:middle
The queue drains a bit, we
get a packet, we accept it.

00:25:23.486 --> 00:25:27.286 A:middle
So, at the tail end of
the queue, it's carnage.

00:25:27.346 --> 00:25:29.066 A:middle
It's get a packet,
lose one, lose one,

00:25:29.066 --> 00:25:30.676 A:middle
lose one, get one, lose one.

00:25:31.846 --> 00:25:33.226 A:middle
But over at the front
of the queue,

00:25:33.716 --> 00:25:38.046 A:middle
we've got 200 packets queued up,
in order, they are neatly going

00:25:38.046 --> 00:25:40.206 A:middle
out over that 10-megabit
bottleneck link,

00:25:40.326 --> 00:25:42.776 A:middle
in order, no gaps, no problem.

00:25:43.176 --> 00:25:45.936 A:middle
It's only after that
entire queue has drained

00:25:46.396 --> 00:25:48.396 A:middle
that we actually
witness the results

00:25:48.396 --> 00:25:50.876 A:middle
of that packet loss
carnage at the receiver;

00:25:51.796 --> 00:25:54.986 A:middle
that gets reflected back to the
sender in the selective acks

00:25:55.336 --> 00:25:56.616 A:middle
and the recovery starts.

00:25:57.066 --> 00:25:59.766 A:middle
So this is a big mess.



00:26:01.496 --> 00:26:04.246 A:middle
Because of the way
networking APIs work,

00:26:04.856 --> 00:26:06.256 A:middle
data has to be delivered
in order.

00:26:07.626 --> 00:26:10.766 A:middle
If you lose one packet, then
all the packets that arrive

00:26:10.766 --> 00:26:12.786 A:middle
after it get delayed
in the kernel

00:26:13.026 --> 00:26:14.616 A:middle
until the gap has
been filled in.

00:26:15.076 --> 00:26:17.926 A:middle
Now, there are good
reasons for this.

00:26:18.146 --> 00:26:21.126 A:middle
People have talked many times
about out-of-order delivery,

00:26:21.516 --> 00:26:24.346 A:middle
but it turns out with almost
all applications it's hard

00:26:24.346 --> 00:26:25.626 A:middle
to use data out of order.

00:26:25.916 --> 00:26:29.946 A:middle
If you are trying to decode
H.264 video, having frames

00:26:29.946 --> 00:26:33.186 A:middle
that depend on an I-frame you
don't have is not helpful.

00:26:33.546 --> 00:26:37.706 A:middle
So it turns out that in-order
delivery really is the model

00:26:37.736 --> 00:26:38.856 A:middle
that applications want.

00:26:39.416 --> 00:26:42.346 A:middle
Because of that in-order
delivery,

00:26:42.806 --> 00:26:45.396 A:middle
we get these long plateaus
where no data is delivered.

00:26:46.186 --> 00:26:49.536 A:middle
And for the Apple TV,
video playback process,

00:26:50.046 --> 00:26:52.846 A:middle
that equals a period
of starvation

00:26:53.016 --> 00:26:54.166 A:middle
where it's getting no data.

00:26:54.816 --> 00:26:58.096 A:middle
And because we don't
want the video to freeze,

00:26:58.826 --> 00:27:01.586 A:middle
that's why all streaming
video applications need a



00:26:58.826 --> 00:27:01.586 A:middle
that's why all streaming
video applications need a

00:27:01.586 --> 00:27:02.426 A:middle
playback buffer.

00:27:03.456 --> 00:27:06.626 A:middle
And having a big
playback buffer is why

00:27:06.726 --> 00:27:08.266 A:middle
when you watch a
streaming video,

00:27:08.596 --> 00:27:10.976 A:middle
you see that spinning wheel
saying buffering, buffering,

00:27:10.976 --> 00:27:14.316 A:middle
buffering, because it has to
fill up the playback buffer

00:27:14.416 --> 00:27:18.226 A:middle
so that it can weather the
storms when no data arrives

00:27:18.226 --> 00:27:19.226 A:middle
for a long period of time.

00:27:20.236 --> 00:27:23.286 A:middle
When the missing packet
arrives, we then fill in the gap

00:27:23.486 --> 00:27:24.756 A:middle
and deliver it all at once.

00:27:26.596 --> 00:27:30.886 A:middle
That puts an excessive burden
on the network receiving thread

00:27:31.516 --> 00:27:36.086 A:middle
which takes away CPU time from
the video playback threads,

00:27:36.676 --> 00:27:38.496 A:middle
and that results
in the stuttering

00:27:38.816 --> 00:27:40.436 A:middle
of the smooth video playback.

00:27:40.436 --> 00:27:43.526 A:middle
So that's bad.

00:27:43.736 --> 00:27:48.736 A:middle
So this uneven delivery in the
network has bad consequences

00:27:48.846 --> 00:27:51.026 A:middle
for a device like Apple
TV; when we are trying

00:27:51.026 --> 00:27:54.726 A:middle
to make a very affordable,
cost-effective device,

00:27:55.546 --> 00:27:59.126 A:middle
these long plateaus
of starvation equate

00:27:59.356 --> 00:28:02.556 A:middle
to needing more RAM in the
device for more buffering



00:27:59.356 --> 00:28:02.556 A:middle
to needing more RAM in the
device for more buffering

00:28:03.206 --> 00:28:07.406 A:middle
and slower video start-up
and a poor user experience.

00:28:08.786 --> 00:28:13.056 A:middle
And these spikes in delivery
result in needing a faster CPU

00:28:13.056 --> 00:28:15.556 A:middle
in the device than we
otherwise might have needed,

00:28:15.816 --> 00:28:16.936 A:middle
which pushes the price up.

00:28:17.416 --> 00:28:24.306 A:middle
So this uneven delivery is very
damaging for streaming video.

00:28:25.666 --> 00:28:27.736 A:middle
One interesting thing
to note, though:

00:28:28.166 --> 00:28:33.966 A:middle
If you visually track the
slope of the yellow ack line --

00:28:34.376 --> 00:28:37.116 A:middle
the yellow window line
and the green ack line,

00:28:37.646 --> 00:28:40.986 A:middle
you'll see that at the end of
the trace, they pretty much end

00:28:40.986 --> 00:28:44.266 A:middle
up back where they should have
been, if no loss had happened

00:28:44.766 --> 00:28:47.546 A:middle
because TCP does do an
awesome job of filling

00:28:47.546 --> 00:28:51.166 A:middle
in exactly what needs to be
retransmitted, exactly once,

00:28:51.706 --> 00:28:53.176 A:middle
and not retransmitting anything

00:28:53.176 --> 00:28:54.726 A:middle
that didn't need to
be retransmitted.

00:28:55.186 --> 00:28:56.926 A:middle
So it gets back to where
it should have been.

00:28:57.916 --> 00:29:00.746 A:middle
If you measure this
network using Iperf and look



00:28:57.916 --> 00:29:00.746 A:middle
If you measure this
network using Iperf and look

00:29:00.746 --> 00:29:01.866 A:middle
at the number that comes out,

00:29:01.866 --> 00:29:04.196 A:middle
it will tell you 10
megabits per second,

00:29:04.556 --> 00:29:07.336 A:middle
and you will say thumbs up, my
network is working perfectly.

00:29:08.416 --> 00:29:11.036 A:middle
But distilling all
of this information

00:29:11.036 --> 00:29:15.406 A:middle
down to a single figure
loses all the subtlety

00:29:15.636 --> 00:29:22.156 A:middle
of what's really going
on on the network.

00:29:22.156 --> 00:29:25.976 A:middle
So now that I understood
what was going on

00:29:25.976 --> 00:29:27.936 A:middle
and causing the sluggish
performance,

00:29:28.666 --> 00:29:30.996 A:middle
I decided to experiment
with a smarter network.

00:29:31.586 --> 00:29:35.136 A:middle
For this experiment, I used a
smart cueing algorithm called

00:29:35.136 --> 00:29:38.056 A:middle
CoDel, which is short
for Controlled Delay.

00:29:39.316 --> 00:29:42.006 A:middle
The way it works is
instead of filling the queue

00:29:42.006 --> 00:29:45.796 A:middle
until it overflows and loses
data, it monitors the state

00:29:45.796 --> 00:29:51.986 A:middle
of the queue and as soon
as a standing queue starts

00:29:51.986 --> 00:29:56.866 A:middle
to build up, then it considers
that to be a sign of congestion.

00:29:57.766 --> 00:30:01.766 A:middle
And when I say congestion, a
lot of people think I'm talking



00:29:57.766 --> 00:30:01.766 A:middle
And when I say congestion, a
lot of people think I'm talking

00:30:01.766 --> 00:30:03.416 A:middle
about something that
happens rarely

00:30:03.416 --> 00:30:05.656 A:middle
at peak times, and it's not.

00:30:05.656 --> 00:30:09.116 A:middle
It's important to
understand that in networking,

00:30:09.626 --> 00:30:12.316 A:middle
congestion is what
happens all the time.

00:30:12.856 --> 00:30:14.516 A:middle
It's the steady state
of the network.

00:30:14.576 --> 00:30:17.336 A:middle
It's the job of any
transport protocol like TCP

00:30:18.096 --> 00:30:20.836 A:middle
to maximize its use
of the network,

00:30:21.306 --> 00:30:23.856 A:middle
to find out how much
the network can carry

00:30:24.336 --> 00:30:26.596 A:middle
and make the best use of that.

00:30:26.596 --> 00:30:28.346 A:middle
And the way a transport
protocol does

00:30:28.346 --> 00:30:33.006 A:middle
that is it sends data faster
and faster and faster.

00:30:33.006 --> 00:30:35.496 A:middle
It keeps probing and it
keeps trying a bit more,

00:30:35.986 --> 00:30:38.006 A:middle
until it loses a
packet, and then it knows

00:30:38.006 --> 00:30:39.586 A:middle
that was too much
and it backs off.

00:30:40.026 --> 00:30:43.346 A:middle
So it's constantly doing
this hunting to track

00:30:43.346 --> 00:30:45.166 A:middle
to find the right rate and what

00:30:45.166 --> 00:30:47.456 A:middle
that means is it's
always pushing the network

00:30:47.456 --> 00:30:49.636 A:middle
into congestion, and
then backing off,

00:30:49.636 --> 00:30:51.606 A:middle
and then congestion
and backing off.

00:30:52.456 --> 00:30:55.996 A:middle
What CoDel does is not wait
until things have gotten really,

00:30:55.996 --> 00:30:58.626 A:middle
really bad before it
signals congestion.

00:30:59.336 --> 00:31:01.976 A:middle
As soon as the first
sign of it starts



00:30:59.336 --> 00:31:01.976 A:middle
As soon as the first
sign of it starts

00:31:01.976 --> 00:31:05.156 A:middle
to happen, it tells the sender.

00:31:06.156 --> 00:31:09.436 A:middle
The other thing that I did for
this experiment was instead

00:31:09.436 --> 00:31:12.106 A:middle
of indicating congestion
by losing packets,

00:31:12.176 --> 00:31:13.686 A:middle
which requires a retransmission,

00:31:14.266 --> 00:31:16.636 A:middle
we used a new technology
called Explicit Congestion

00:31:16.636 --> 00:31:19.916 A:middle
Notification, and that way
the smart queuing algorithm,

00:31:19.916 --> 00:31:22.496 A:middle
instead of dropping the
packet, it sets a bit

00:31:22.866 --> 00:31:26.206 A:middle
in the IP header saying
congestion experienced.

00:31:26.856 --> 00:31:30.026 A:middle
That is echoed back to
the sender and it responds

00:31:30.026 --> 00:31:33.046 A:middle
by slowing down without
the destructive effects

00:31:33.046 --> 00:31:33.886 A:middle
of a packet loss.

00:31:34.466 --> 00:31:41.926 A:middle
So this is our graph of the
same data transfer, using CoDel

00:31:42.076 --> 00:31:46.176 A:middle
and ECN, and if I zoom in to
the same part we were looking

00:31:46.176 --> 00:31:49.426 A:middle
at before, you can
see an absolutely

00:31:49.516 --> 00:31:50.506 A:middle
phenomenal difference.

00:31:50.956 --> 00:31:52.646 A:middle
When I was doing
these experiments,

00:31:52.946 --> 00:31:56.206 A:middle
I had planned a week to do
the work and gather the data,

00:31:56.916 --> 00:31:59.416 A:middle
and I was finished
after two hours.

00:31:59.746 --> 00:32:02.286 A:middle
I did one plot with the
standard configuration



00:31:59.746 --> 00:32:02.286 A:middle
I did one plot with the
standard configuration

00:32:02.286 --> 00:32:03.576 A:middle
and one plot with CoDel.

00:32:03.796 --> 00:32:06.766 A:middle
This is my first experimental
run that I'm showing you.

00:32:06.766 --> 00:32:10.076 A:middle
I was expecting to have to
tweak parameters and retry

00:32:10.076 --> 00:32:11.506 A:middle
and rerun the experiment.

00:32:12.156 --> 00:32:16.446 A:middle
No. This is -- the
difference is that obvious,

00:32:16.586 --> 00:32:18.216 A:middle
that one trial was all it took.

00:32:18.976 --> 00:32:19.726 A:middle
I'm hearing applause.

00:32:19.726 --> 00:32:19.976 A:middle
Thank you.

00:32:20.516 --> 00:32:25.866 A:middle
[Applause]

00:32:26.366 --> 00:32:28.946 A:middle
We have no plateaus
of starvation.

00:32:28.986 --> 00:32:31.396 A:middle
We have no spikes
of peak delivery.

00:32:32.056 --> 00:32:35.396 A:middle
Every time the slightest
hint of a queue builds up,

00:32:35.956 --> 00:32:38.086 A:middle
we get these little
polite nudges

00:32:38.086 --> 00:32:40.326 A:middle
from the CoDel algorithm
saying slow down.

00:32:40.806 --> 00:32:44.606 A:middle
The CWR on that plot is
Congestion Window Reduced.

00:32:44.606 --> 00:32:47.026 A:middle
That's TCP's acknowledgment
saying message received

00:32:47.026 --> 00:32:48.836 A:middle
and understood; I
have slowed down.

00:32:49.646 --> 00:32:50.706 A:middle
Absolutely wonderful!

00:32:52.366 --> 00:32:56.136 A:middle
So, simple summary, CoDel

00:32:56.136 --> 00:32:58.516 A:middle
and other smart cueing
algorithms are great.

00:32:58.846 --> 00:32:59.846 A:middle
ECN are great.



00:33:00.626 --> 00:33:02.446 A:middle
Put them together,
it's totally awesome.

00:33:05.506 --> 00:33:07.606 A:middle
So if it's so great,
where is it?

00:33:08.226 --> 00:33:11.826 A:middle
Well, historically, packet loss

00:33:11.826 --> 00:33:14.736 A:middle
and retransmission has
not caused big problems

00:33:14.786 --> 00:33:17.416 A:middle
for the traditional
networking applications

00:33:17.416 --> 00:33:19.166 A:middle
like file transfer
and sending email.

00:33:21.636 --> 00:33:24.896 A:middle
When you transfer a
file, the transport layer

00:33:24.896 --> 00:33:28.336 A:middle
in principle could send
the first packet last

00:33:28.336 --> 00:33:31.156 A:middle
and the last packet first and
all the ones in the middle

00:33:31.156 --> 00:33:33.676 A:middle
in a random order; as
long as they all get there

00:33:33.676 --> 00:33:34.486 A:middle
and they are reassembled

00:33:34.486 --> 00:33:36.176 A:middle
in the correct order
you have your file,

00:33:36.176 --> 00:33:37.306 A:middle
and that's all you care about.

00:33:38.076 --> 00:33:41.966 A:middle
But when you are watching
streaming video, you don't want

00:33:41.966 --> 00:33:45.796 A:middle
to see the end first,
and the start last.

00:33:46.306 --> 00:33:47.506 A:middle
You want it in order.

00:33:47.956 --> 00:33:51.566 A:middle
So in order delivery has become
a much more pressing problem,

00:33:51.566 --> 00:33:54.286 A:middle
now that we are using the
Internet for streaming video.

00:33:57.196 --> 00:33:59.866 A:middle
One way I characterize
this is that we used

00:33:59.866 --> 00:34:03.096 A:middle
to have applications like
clicking send on an email,



00:33:59.866 --> 00:34:03.096 A:middle
to have applications like
clicking send on an email,

00:34:03.726 --> 00:34:06.236 A:middle
where you have a
predetermined amount of data

00:34:07.106 --> 00:34:09.306 A:middle
and how long it takes
to send it is variable.

00:34:10.266 --> 00:34:13.436 A:middle
Basically, the time you'd
like the network to take

00:34:13.436 --> 00:34:16.386 A:middle
to send your email is
as little as possible.

00:34:17.025 --> 00:34:19.176 A:middle
There's really no such thing
as sending an email too fast.

00:34:20.076 --> 00:34:22.106 A:middle
So the time is variable.

00:34:22.106 --> 00:34:23.146 A:middle
You would like it to be fast.

00:34:23.466 --> 00:34:25.196 A:middle
Now we have applications

00:34:25.196 --> 00:34:29.126 A:middle
where you are watching
a two-hour movie,

00:34:29.416 --> 00:34:30.886 A:middle
streaming over the Internet.

00:34:32.186 --> 00:34:35.556 A:middle
It doesn't help to watch it in
half an hour or in eight hours.

00:34:35.755 --> 00:34:37.196 A:middle
It has to take two hours.

00:34:38.045 --> 00:34:40.056 A:middle
So now we have adaptive
applications

00:34:40.056 --> 00:34:42.696 A:middle
where the time is fixed
but the amount of data

00:34:42.696 --> 00:34:45.116 A:middle
that could be sent in
that time has to adjust

00:34:45.226 --> 00:34:47.025 A:middle
to accommodate the
network conditions.

00:34:50.295 --> 00:34:51.386 A:middle
Where are we now?

00:34:52.116 --> 00:34:55.246 A:middle
Well, amazingly, because
it is in Linux and turned

00:34:55.246 --> 00:34:59.556 A:middle
on by default, more than half
of the top million web servers

00:34:59.556 --> 00:35:01.516 A:middle
in the world already
support ECN,



00:34:59.556 --> 00:35:01.516 A:middle
in the world already
support ECN,

00:35:02.176 --> 00:35:04.546 A:middle
which is phenomenal adoption

00:35:04.546 --> 00:35:05.976 A:middle
for a technology
that no one is using.

00:35:06.516 --> 00:35:09.546 A:middle
[Laughter]

00:35:10.046 --> 00:35:14.786 A:middle
Clients. Well, the clients are
not asking for ECN connections.

00:35:14.786 --> 00:35:18.286 A:middle
They are not requesting ECN
because pretty much none

00:35:18.286 --> 00:35:20.706 A:middle
of the Internet supports
ECN marking.

00:35:21.006 --> 00:35:24.746 A:middle
So if you turn on that option,
there might be some risk

00:35:24.746 --> 00:35:27.646 A:middle
of exposing bugs and
there's no immediate benefit.

00:35:29.626 --> 00:35:30.666 A:middle
What are the routers doing?

00:35:30.776 --> 00:35:33.626 A:middle
Well, none of the routers are
doing marking because none

00:35:33.626 --> 00:35:36.646 A:middle
of the clients are asking for
it, so why put engineering

00:35:36.646 --> 00:35:39.086 A:middle
into something that might have
risk that no one is asking for?

00:35:39.346 --> 00:35:41.736 A:middle
Well, I'm happy to
announce today

00:35:41.736 --> 00:35:43.306 A:middle
that Apple is taking
the initiative

00:35:43.596 --> 00:35:44.746 A:middle
to break this log jam.

00:35:45.226 --> 00:35:50.236 A:middle
In the seeds that you all have,
ECN is now turned on by default

00:35:50.606 --> 00:35:54.976 A:middle
for all TCP connections
for all applications.

00:35:55.516 --> 00:36:01.406 A:middle
[Applause]



00:35:55.516 --> 00:36:01.406 A:middle
[Applause]

00:36:01.906 --> 00:36:05.436 A:middle
We're not expecting to see
any problems; in our testing,

00:36:05.926 --> 00:36:07.226 A:middle
everything has gone smoothly.

00:36:07.696 --> 00:36:10.536 A:middle
I have been running it on my
own laptop for a long time;

00:36:11.676 --> 00:36:14.806 A:middle
of course, we want to
hear your experience.

00:36:14.976 --> 00:36:19.396 A:middle
Please take the seed builds, run
them on your networks at home,

00:36:20.056 --> 00:36:24.506 A:middle
at work, in your hotel, at
the airport, and as usual,

00:36:24.506 --> 00:36:26.636 A:middle
if you find any bugs,
please report them to Apple.

00:36:27.426 --> 00:36:30.346 A:middle
If we are successful, in a few
months' time we could have a

00:36:30.436 --> 00:36:35.156 A:middle
billion devices running ECN, and
that should be enough incentive

00:36:35.156 --> 00:36:37.236 A:middle
for the ISPs to start
offering that service.

00:36:37.806 --> 00:36:43.026 A:middle
Now we are going to move
on from network delays

00:36:43.326 --> 00:36:45.326 A:middle
to end system delays.

00:36:46.316 --> 00:36:50.506 A:middle
Like many advances in
technology, this was borne

00:36:50.506 --> 00:36:53.446 A:middle
out of a personal
pain point for me.

00:36:54.676 --> 00:36:59.336 A:middle
I use screen sharing to
connect to my Mac at home,

00:36:59.916 --> 00:37:01.236 A:middle
and it's absolutely wonderful.



00:36:59.916 --> 00:37:01.236 A:middle
and it's absolutely wonderful.

00:37:01.856 --> 00:37:03.526 A:middle
Being able to control
it remotely,

00:37:03.526 --> 00:37:05.346 A:middle
being able to access data on it,

00:37:06.036 --> 00:37:11.556 A:middle
being able to start a long video
transcode going that I want

00:37:11.556 --> 00:37:13.086 A:middle
to have finished
when I get back home:

00:37:13.746 --> 00:37:14.946 A:middle
these are all wonderful things.

00:37:15.996 --> 00:37:18.406 A:middle
And at the time I was
doing these experiments,

00:37:19.896 --> 00:37:23.136 A:middle
I had a fairly slow DSL line.

00:37:24.006 --> 00:37:27.236 A:middle
And, of course, DSL
is asymmetric.

00:37:27.656 --> 00:37:30.596 A:middle
It's typically ten times faster
in the downstream direction

00:37:30.596 --> 00:37:31.906 A:middle
than the upstream direction,

00:37:32.766 --> 00:37:34.766 A:middle
and when you are doing screen
sharing, the data is coming

00:37:35.186 --> 00:37:37.396 A:middle
in the wrong direction
in that sense.

00:37:37.546 --> 00:37:41.716 A:middle
So it's kind of to be
expected it will be a bit slow.

00:37:42.546 --> 00:37:45.066 A:middle
It's like the famous joke
about the dancing bear:

00:37:45.386 --> 00:37:47.346 A:middle
when you see a dancing
bear, you are not supposed

00:37:47.346 --> 00:37:49.196 A:middle
to be impressed that
it dances well.

00:37:49.316 --> 00:37:51.396 A:middle
You are supposed to be
impressed that it dances at all.

00:37:52.186 --> 00:37:58.216 A:middle
So for many years, like many
of us, I kind of suffered

00:37:58.216 --> 00:38:04.626 A:middle
with this painful, barely usable
experience, and I would find



00:37:58.216 --> 00:38:04.626 A:middle
with this painful, barely usable
experience, and I would find

00:38:04.676 --> 00:38:08.306 A:middle
that when I clicked on a menu,
it took three or four seconds

00:38:08.306 --> 00:38:10.786 A:middle
for the menu to appear,
and after a few minutes

00:38:10.786 --> 00:38:14.386 A:middle
of using the computer this way,
it's really, really frustrating.

00:38:14.466 --> 00:38:16.466 A:middle
There were times it felt
like it would be quicker

00:38:16.466 --> 00:38:19.596 A:middle
to drive home and do it.

00:38:19.816 --> 00:38:22.636 A:middle
And I had been working
on bufferbloat

00:38:23.256 --> 00:38:25.596 A:middle
and excessive queuing
in the network.

00:38:25.986 --> 00:38:28.626 A:middle
So naturally, that was
the first thing I blamed,

00:38:29.096 --> 00:38:30.656 A:middle
and I started digging in.

00:38:30.896 --> 00:38:32.396 A:middle
I started investigating.

00:38:32.726 --> 00:38:35.366 A:middle
I was all ready to be
thoroughly indignant

00:38:35.366 --> 00:38:37.896 A:middle
about this stupid DSL
modem that had all

00:38:37.896 --> 00:38:39.526 A:middle
of this excessive
bufferbloat in it.

00:38:40.156 --> 00:38:41.446 A:middle
And I pinged the machine,

00:38:42.176 --> 00:38:44.406 A:middle
and the ping time
was 35 milliseconds,

00:38:45.276 --> 00:38:46.666 A:middle
but when I click the mouse,

00:38:46.666 --> 00:38:48.736 A:middle
it takes 3 seconds
for a menu to appear.

00:38:49.796 --> 00:38:52.986 A:middle
So now I'm realizing this is
not as obvious as I thought.

00:38:53.686 --> 00:38:55.176 A:middle
Where is the delay coming from?

00:38:56.016 --> 00:38:59.136 A:middle
Well, I did some investigation.



00:39:00.626 --> 00:39:04.206 A:middle
The default socket send buffer
at that time was 120 kilobytes,

00:39:04.636 --> 00:39:08.236 A:middle
my throughput was about
50 kilobytes a second,

00:39:08.236 --> 00:39:10.246 A:middle
so that's about 2.5 seconds,

00:39:10.466 --> 00:39:12.106 A:middle
which was about the
delay I was seeing.

00:39:14.046 --> 00:39:17.246 A:middle
Now, the socket send buffer
serves a very important purpose.

00:39:18.496 --> 00:39:21.486 A:middle
When we use a transport
protocol like TCP,

00:39:21.486 --> 00:39:25.706 A:middle
if it just sent one packet and
waited for the acknowledgment

00:39:25.706 --> 00:39:27.816 A:middle
and one packet and waited
for the acknowledgment,

00:39:27.816 --> 00:39:29.516 A:middle
we would get terrible
performance.

00:39:29.906 --> 00:39:32.996 A:middle
We need multiple packets in
flight; we need enough packets

00:39:32.996 --> 00:39:37.106 A:middle
in flight to fill the bandwidth
delay product of that path

00:39:37.766 --> 00:39:40.906 A:middle
to the destination and
back, and those packets have

00:39:40.906 --> 00:39:43.336 A:middle
to be buffered so
that if they are lost,

00:39:43.406 --> 00:39:44.596 A:middle
they can be retransmitted.

00:39:45.076 --> 00:39:47.256 A:middle
That's all good and
useful and necessary

00:39:47.586 --> 00:39:50.296 A:middle
to maximize the throughput
of that connection.

00:39:51.096 --> 00:39:53.486 A:middle
But any excess buffering

00:39:53.486 --> 00:39:57.876 A:middle
above that requirement just
adds delay for no benefit.

00:39:58.056 --> 00:39:59.356 A:middle
It doesn't help the throughput.

00:39:59.856 --> 00:40:00.776 A:middle
It just adds delay.



00:39:59.856 --> 00:40:00.776 A:middle
It just adds delay.

00:40:01.626 --> 00:40:04.386 A:middle
And we end up with something
that looks like this.

00:40:05.206 --> 00:40:08.756 A:middle
We have a little bit of data
in flight, which is buffered,

00:40:08.976 --> 00:40:10.556 A:middle
in case it needs to
be retransmitted,

00:40:11.206 --> 00:40:15.196 A:middle
and we have a whole lot, just
sitting in the kernel waiting

00:40:15.196 --> 00:40:19.006 A:middle
for its turn to go out.

00:40:19.936 --> 00:40:22.986 A:middle
Well, this was an
eye-opening revelation for me.

00:40:23.536 --> 00:40:25.536 A:middle
There aren't just
delays in the network.

00:40:25.536 --> 00:40:27.766 A:middle
There are big delays in
the hosts themselves.

00:40:29.786 --> 00:40:33.076 A:middle
Screen sharing would grab a
frame, put it in the buffer,

00:40:33.276 --> 00:40:35.416 A:middle
grab a frame, put it in
the buffer, grab a frame,

00:40:35.536 --> 00:40:38.586 A:middle
put it in the buffer, and then
the kernel would let those

00:40:38.586 --> 00:40:42.196 A:middle
frames mature like a fine
wine before it was time

00:40:42.196 --> 00:40:43.406 A:middle
to put them out on the network.

00:40:44.031 --> 00:40:46.031 A:middle
[Laughter]

00:40:46.046 --> 00:40:51.596 A:middle
Because of that, we came up with
the TCP NOTSENT low-water mark

00:40:51.596 --> 00:40:52.296 A:middle
socket option.

00:40:53.116 --> 00:40:54.486 A:middle
When you send that option,

00:40:55.606 --> 00:40:58.636 A:middle
the socket send buffer
remains unchanged.

00:40:59.496 --> 00:41:02.706 A:middle
The difference is that kevent



00:40:59.496 --> 00:41:02.706 A:middle
The difference is that kevent

00:41:03.316 --> 00:41:07.756 A:middle
or your run loop will not report
the socket as being writable

00:41:08.126 --> 00:41:10.646 A:middle
until the unsent
data has drained

00:41:10.646 --> 00:41:13.106 A:middle
to some fairly low
threshold, typically 8

00:41:13.106 --> 00:41:14.806 A:middle
or 16 kilobytes works well.

00:41:15.816 --> 00:41:17.486 A:middle
When the socket becomes
writable,

00:41:18.046 --> 00:41:23.206 A:middle
you then write a single useful
atomic chunk into the buffer.

00:41:23.946 --> 00:41:27.656 A:middle
You don't loop, cramming as
much data into the kernel

00:41:27.656 --> 00:41:29.696 A:middle
as it can take, because
RAM is cheap these days,

00:41:29.696 --> 00:41:30.476 A:middle
it can take a lot.

00:41:31.526 --> 00:41:33.366 A:middle
You just write a sensible unit.

00:41:33.636 --> 00:41:36.356 A:middle
And in the case of screen
sharing, that's one frame.

00:41:37.226 --> 00:41:38.926 A:middle
And now the picture
looks like this.

00:41:40.026 --> 00:41:42.106 A:middle
We have data in flight,
that's buffered.

00:41:42.436 --> 00:41:44.686 A:middle
We have a little bit waiting
for its turn to go out.

00:41:45.726 --> 00:41:48.206 A:middle
As that drains and
reaches the threshold,

00:41:49.136 --> 00:41:50.456 A:middle
the socket becomes writable.

00:41:51.166 --> 00:41:53.176 A:middle
We write a single chunk and let

00:41:53.176 --> 00:41:54.766 A:middle
that drain before
we write some more.

00:41:55.496 --> 00:41:57.436 A:middle
So with that, I would
like to show you a demo

00:41:57.436 --> 00:41:57.976 A:middle
of this in action.



00:42:07.086 --> 00:42:08.506 A:middle
Here I'm using screen sharing

00:42:08.876 --> 00:42:11.496 A:middle
from this machine,
connecting to this.

00:42:12.436 --> 00:42:15.726 A:middle
I'm using a gateway running
sarawert [assumed spelling]

00:42:15.886 --> 00:42:18.376 A:middle
to simulate a DSL
performance connection.

00:42:20.296 --> 00:42:24.976 A:middle
And let's bring up
a Terminal window.

00:42:32.266 --> 00:42:33.086 A:middle
Okay, there we go.

00:42:34.976 --> 00:42:36.656 A:middle
I'm going to move this window.

00:42:37.806 --> 00:42:40.706 A:middle
You can see the mouse
pointer move

00:42:40.946 --> 00:42:42.416 A:middle
because it's generated locally.

00:42:42.826 --> 00:42:45.766 A:middle
The actual graphical updates are
generated by the remote machine.

00:42:46.216 --> 00:42:48.466 A:middle
So let's move this
window over here.

00:42:48.466 --> 00:42:50.316 A:middle
No, not over here.

00:42:50.316 --> 00:42:53.316 A:middle
So let's move it -- actually,
no I like it back where it is.

00:42:53.316 --> 00:42:54.306 A:middle
Hands off the keyboard.

00:42:55.516 --> 00:43:01.696 A:middle
[Laughter]



00:42:55.516 --> 00:43:01.696 A:middle
[Laughter]

00:43:02.196 --> 00:43:04.436 A:middle
Let's pull down some
menus: Shell.

00:43:06.686 --> 00:43:09.416 A:middle
There we go.

00:43:09.646 --> 00:43:11.186 A:middle
Let's look at Edit.

00:43:11.416 --> 00:43:12.666 A:middle
No, maybe View.

00:43:18.576 --> 00:43:21.556 A:middle
If this feels like a demo
that's going painfully badly,

00:43:21.796 --> 00:43:23.446 A:middle
this is what my life
was like trying

00:43:23.446 --> 00:43:24.896 A:middle
to use my computer remotely.

00:43:25.426 --> 00:43:28.836 A:middle
It takes the patience of a
saint to put up with this.

00:43:31.066 --> 00:43:37.056 A:middle
Well, now I have a new option.

00:43:37.056 --> 00:43:41.176 A:middle
Let's turn on the not
sent low-water mark,

00:43:42.726 --> 00:43:50.076 A:middle
and once we reconnect,

00:43:50.076 --> 00:43:53.086 A:middle
now I will try dragging
this window around.

00:43:54.516 --> 00:44:04.966 A:middle
[Applause]



00:43:54.516 --> 00:44:04.966 A:middle
[Applause]

00:44:05.466 --> 00:44:05.816 A:middle
Thank you.

00:44:06.436 --> 00:44:13.416 A:middle
And that was years of suffering
unusable screen-sharing

00:44:13.416 --> 00:44:16.706 A:middle
connections just for the
sake of a silly oversight

00:44:16.916 --> 00:44:18.946 A:middle
in the BSD networking stack.

00:44:19.776 --> 00:44:26.276 A:middle
The great news is that
we have fixed this.

00:44:27.226 --> 00:44:36.196 A:middle
It is available in -- it's now
being used by screen sharing

00:44:36.326 --> 00:44:39.786 A:middle
in the last software update
in 10.10.3, so if you noticed

00:44:39.786 --> 00:44:42.116 A:middle
that screen sharing seemed
to get a lot more snappy,

00:44:42.646 --> 00:44:44.366 A:middle
then this is the reason why.

00:44:44.996 --> 00:44:49.586 A:middle
It's used by AirPlay, and
it's available in Linux too

00:44:50.146 --> 00:44:52.386 A:middle
because this option
applies at the source

00:44:52.386 --> 00:44:54.166 A:middle
of the data on the sending side.

00:44:54.636 --> 00:44:57.356 A:middle
So for those of you who
are running Linux servers,

00:44:57.696 --> 00:45:02.866 A:middle
this option is available
for your servers too.



00:44:57.696 --> 00:45:02.866 A:middle
this option is available
for your servers too.

00:45:03.176 --> 00:45:06.716 A:middle
The benefit of this delay
reduction is really obvious

00:45:06.826 --> 00:45:08.226 A:middle
for real-time applications.

00:45:09.856 --> 00:45:13.896 A:middle
And we started making
slides for this presentation

00:45:14.006 --> 00:45:15.136 A:middle
where we had two columns.

00:45:15.136 --> 00:45:18.356 A:middle
We had the apps that should
use the low-water mark option

00:45:18.416 --> 00:45:19.506 A:middle
and the apps that shouldn't.

00:45:20.276 --> 00:45:23.606 A:middle
And we couldn't think of any
to go in the shouldn't column.

00:45:24.386 --> 00:45:26.606 A:middle
Every time we thought
of a traditional app

00:45:26.606 --> 00:45:28.586 A:middle
like file transfer, well,
that doesn't need it.

00:45:29.126 --> 00:45:31.976 A:middle
We realized you've
had that experience

00:45:31.976 --> 00:45:33.786 A:middle
where you change your
mind about a file transfer

00:45:33.786 --> 00:45:35.576 A:middle
and you press Control-C
and it seems to take

00:45:35.576 --> 00:45:37.106 A:middle
about 30 seconds to cancel.

00:45:37.976 --> 00:45:40.526 A:middle
It's because it had
over-committed all of this data

00:45:40.526 --> 00:45:42.606 A:middle
into the kernel and it had
to wait for it to drain

00:45:43.006 --> 00:45:44.506 A:middle
because there's no way
to change your mind.

00:45:45.016 --> 00:45:48.176 A:middle
So, yeah, actually, file
transfer does not benefit

00:45:48.176 --> 00:45:51.946 A:middle
from over-committing data,
and we couldn't think

00:45:51.946 --> 00:45:53.856 A:middle
of any application
that does benefit

00:45:53.856 --> 00:45:55.626 A:middle
from over-stuffing the kernel.

00:45:55.946 --> 00:46:00.836 A:middle
So once we had that
realization, we decided starting



00:45:55.946 --> 00:46:00.836 A:middle
So once we had that
realization, we decided starting

00:46:00.836 --> 00:46:04.686 A:middle
in the next seed, this option
will be turned on automatically

00:46:05.566 --> 00:46:09.766 A:middle
for all connections using
the higher layer NSURLSession

00:46:09.766 --> 00:46:11.546 A:middle
and CFNetwork APIs.

00:46:12.696 --> 00:46:15.776 A:middle
All you have to do to
make best use of this is

00:46:15.776 --> 00:46:20.606 A:middle
when your socket becomes
writable, don't loop writing

00:46:20.606 --> 00:46:23.086 A:middle
as much data as you can
until you get an EWOULDBLOCK.

00:46:23.446 --> 00:46:26.856 A:middle
Just write a sensible-sized
unit, and then wait

00:46:27.126 --> 00:46:28.426 A:middle
to be told it's time for more.

00:46:28.836 --> 00:46:31.606 A:middle
And that way if the user
has changed their mind

00:46:31.606 --> 00:46:33.686 A:middle
or something else has
changed about the environment,

00:46:33.686 --> 00:46:36.946 A:middle
next time you find your
socket is writable,

00:46:37.256 --> 00:46:39.466 A:middle
you can make an intelligent
decision.

00:46:40.456 --> 00:46:42.886 A:middle
You can do just-in-time
data generation

00:46:43.196 --> 00:46:47.116 A:middle
where you generate the data
so it is as fresh as possible

00:46:47.116 --> 00:46:48.656 A:middle
and based on the
current information,

00:46:49.046 --> 00:46:51.906 A:middle
not based on the information
from five or ten seconds ago.

00:46:52.486 --> 00:46:58.426 A:middle
And that brings me to our
final part of the presentation,

00:46:59.336 --> 00:47:01.416 A:middle
and that is a sneak peek



00:46:59.336 --> 00:47:01.416 A:middle
and that is a sneak peek

00:47:02.096 --> 00:47:06.416 A:middle
of a brand-new technology
called TCP Fast Open.

00:47:07.236 --> 00:47:14.516 A:middle
The way TCP traditionally works
is this: we do one round trip

00:47:15.076 --> 00:47:16.506 A:middle
to set up the TCP connection.

00:47:17.356 --> 00:47:18.746 A:middle
And then we do a
second round trip

00:47:19.396 --> 00:47:21.666 A:middle
to send the request
and get the response.

00:47:22.766 --> 00:47:27.056 A:middle
TCP Fast Open combines
the connection setup

00:47:27.056 --> 00:47:30.036 A:middle
and the data exchange
into one packet exchange.

00:47:31.216 --> 00:47:34.466 A:middle
This is not turned on by
default for all applications

00:47:34.566 --> 00:47:37.406 A:middle
and there's a reason for that.

00:47:37.636 --> 00:47:39.606 A:middle
There is a caveat you
need to be aware of,

00:47:40.026 --> 00:47:43.486 A:middle
and that is that this is only
safe for idempotent data.

00:47:43.796 --> 00:47:47.736 A:middle
I'll explain what that means.

00:47:47.906 --> 00:47:52.426 A:middle
When you use a TFO
operation, the handshake

00:47:52.426 --> 00:47:55.556 A:middle
and data are combined, the
server gets the message,

00:47:55.556 --> 00:47:57.946 A:middle
the server acts on that,
sends you the response,

00:47:58.336 --> 00:47:59.586 A:middle
and then you close
the connection.



00:48:00.686 --> 00:48:05.566 A:middle
But the service model of the
Internet doesn't guarantee

00:48:05.916 --> 00:48:08.536 A:middle
that packets can't
be duplicated.

00:48:09.366 --> 00:48:12.916 A:middle
The success of the
Internet has been due

00:48:12.916 --> 00:48:14.306 A:middle
to a very simple service model,

00:48:14.736 --> 00:48:18.446 A:middle
which is deliver the
packets fast and cheap.

00:48:19.146 --> 00:48:21.136 A:middle
And don't worry about
them being in order.

00:48:21.926 --> 00:48:24.296 A:middle
Don't worry if some get
corrupted, some get lost,

00:48:24.346 --> 00:48:26.916 A:middle
some get duplicated,
just be fast and cheap.

00:48:27.776 --> 00:48:30.816 A:middle
And the end systems are
smart enough to deal

00:48:30.816 --> 00:48:31.886 A:middle
with that network model.

00:48:33.456 --> 00:48:35.566 A:middle
Packets can be duplicated
for many reasons.

00:48:35.566 --> 00:48:37.446 A:middle
It could just be
a bug in a router,

00:48:37.996 --> 00:48:40.736 A:middle
it could be Wi-Fi link
layer retransmission

00:48:41.636 --> 00:48:43.876 A:middle
that accidentally
sends the packet twice.

00:48:44.276 --> 00:48:46.706 A:middle
It could be end-system
retransmission:

00:48:46.706 --> 00:48:50.396 A:middle
If you send a packet and
don't get an acknowledgment

00:48:50.966 --> 00:48:52.896 A:middle
because the acknowledgment
was lost, perhaps,

00:48:53.316 --> 00:48:54.786 A:middle
you will then retransmit
the packet

00:48:55.296 --> 00:48:56.946 A:middle
and then immediately
you've got two copies

00:48:56.946 --> 00:48:58.276 A:middle
of the same packet
in the network.

00:48:58.786 --> 00:49:02.956 A:middle
Well, if one of those copies is
delayed and shows up much later,



00:48:58.786 --> 00:49:02.956 A:middle
Well, if one of those copies is
delayed and shows up much later,

00:49:03.716 --> 00:49:06.496 A:middle
then to the server that looks

00:49:06.496 --> 00:49:09.766 A:middle
like a perfectly
valid TFO request,

00:49:10.156 --> 00:49:12.776 A:middle
and whatever the operation
was, it will do it again.

00:49:13.646 --> 00:49:16.996 A:middle
If that operation was
sending you a JPEG image,

00:49:17.336 --> 00:49:19.076 A:middle
doing it twice may
be no big deal.

00:49:20.046 --> 00:49:23.726 A:middle
If that operation was sending
you a pair of shoes from Zappos,

00:49:24.176 --> 00:49:26.006 A:middle
then doing it twice might
not be what you want.

00:49:26.456 --> 00:49:31.196 A:middle
So this is something where you
have to intelligently decide

00:49:31.316 --> 00:49:32.756 A:middle
when it's appropriate and safe

00:49:33.076 --> 00:49:35.396 A:middle
and when it's not
for your application.

00:49:36.626 --> 00:49:41.426 A:middle
You use this through the
connectx system call.

00:49:42.346 --> 00:49:48.086 A:middle
This is a sneak peek technology
preview for the early adopters.

00:49:49.136 --> 00:49:51.986 A:middle
Later, we will look
at how to expose this

00:49:51.986 --> 00:49:52.846 A:middle
through the higher level APIs

00:49:52.846 --> 00:49:55.616 A:middle
but now it's only
available through connectx.

00:49:56.456 --> 00:49:59.776 A:middle
The server you are talking to
has to support TFO as well,

00:49:59.776 --> 00:50:03.536 A:middle
and the application
has to opt in.



00:49:59.776 --> 00:50:03.536 A:middle
and the application
has to opt in.

00:50:03.536 --> 00:50:06.546 A:middle
For those of you running Linux
servers, if you have the very,

00:50:06.546 --> 00:50:09.686 A:middle
very latest Linux kernel as
of a couple of weeks ago,

00:50:10.096 --> 00:50:15.836 A:middle
that now supports the
standard ITF, TFO,

00:50:16.116 --> 00:50:18.676 A:middle
TCP option code,
the same as OS X.

00:50:19.236 --> 00:50:24.196 A:middle
So to wrap up what we
would like you to remember

00:50:24.196 --> 00:50:28.586 A:middle
from today's session,
wherever you can,

00:50:29.256 --> 00:50:32.356 A:middle
use the highest layer
network API as possible

00:50:32.886 --> 00:50:36.286 A:middle
and that way you get the
full benefit of all the work

00:50:36.286 --> 00:50:38.016 A:middle
that those APIs can do for you.

00:50:39.576 --> 00:50:42.956 A:middle
You absolutely must be
testing on a NAT64 network

00:50:43.076 --> 00:50:44.586 A:middle
for your applications,

00:50:45.206 --> 00:50:48.666 A:middle
and thankfully we have made
it really, really easy for you

00:50:48.666 --> 00:50:52.396 A:middle
to do that with just
an Option click.

00:50:52.596 --> 00:50:57.256 A:middle
Reliable network fallback will
give your customers a better

00:50:57.256 --> 00:50:59.286 A:middle
user experience with
your applications.



00:51:00.526 --> 00:51:04.246 A:middle
What you can do is pay attention
to the Better Route notification

00:51:04.506 --> 00:51:07.056 A:middle
so that you migrate back to
Wi-Fi when it's available.

00:51:08.856 --> 00:51:13.096 A:middle
Explicit Congestion Notification
is a new feature for the seed.

00:51:14.476 --> 00:51:17.646 A:middle
It will enable the
Internet to move

00:51:17.646 --> 00:51:21.476 A:middle
to this much more
responsive mode of operation

00:51:21.796 --> 00:51:24.756 A:middle
with lower queuing
and lower packet loss.

00:51:25.406 --> 00:51:28.116 A:middle
So we would like you to test
that and report any problems.

00:51:29.486 --> 00:51:32.836 A:middle
The TCP NOTSENT Low-Water mark
is something that you can set

00:51:32.836 --> 00:51:36.636 A:middle
for yourself as a socket
option or get for free starting

00:51:36.636 --> 00:51:39.506 A:middle
in the next seed, and that
will reduce the amount

00:51:39.506 --> 00:51:41.726 A:middle
of stagnant data buffered
in the sending machine.

00:51:42.706 --> 00:51:46.856 A:middle
And then finally, for the people
excited about TCP Fast Open,

00:51:46.856 --> 00:51:48.076 A:middle
we've made that available too.

00:51:49.896 --> 00:51:51.286 A:middle
There's a bunch of sources

00:51:51.286 --> 00:51:53.006 A:middle
of good documentation
that you can look at.

00:51:53.626 --> 00:51:55.906 A:middle
I'm not expecting anybody
to write down these URLs;

00:51:55.906 --> 00:51:57.806 A:middle
you can click those
in the PDF version.

00:51:59.066 --> 00:52:03.066 A:middle
There are some good forums
where you can ask questions



00:51:59.066 --> 00:52:03.066 A:middle
There are some good forums
where you can ask questions

00:52:03.066 --> 00:52:04.176 A:middle
and have discussions

00:52:04.666 --> 00:52:06.596 A:middle
with questions you
have about networking.

00:52:09.586 --> 00:52:11.586 A:middle
I encourage you to
watch the videos

00:52:11.586 --> 00:52:14.976 A:middle
of the NSURLSession presentation

00:52:15.196 --> 00:52:19.626 A:middle
and the Network Extensions
presentation and, of course,

00:52:20.326 --> 00:52:23.626 A:middle
come and join us in person after
lunch in the networking lab

00:52:23.766 --> 00:52:25.276 A:middle
and we can answer all
of your questions there.

00:52:25.746 --> 00:52:25.936 A:middle
Thank you.

00:52:26.516 --> 00:52:32.500 A:middle
[Applause]

