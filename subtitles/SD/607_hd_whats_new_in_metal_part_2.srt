
00:00:22.516 --> 00:00:28.026 A:middle
[ Applause ]

00:00:28.526 --> 00:00:30.126 A:middle
&gt;&gt; DAN OMACHI: Good morning,
welcome to the second part

00:00:30.126 --> 00:00:31.816 A:middle
of our What's New in
Metal presentation.

00:00:32.036 --> 00:00:33.436 A:middle
My name is Dan Omachi.

00:00:33.866 --> 00:00:36.616 A:middle
I'm an engineer in Apple's
GPU software frameworks team.

00:00:37.206 --> 00:00:40.226 A:middle
Today my colleague Anna
Tikhonova and I will talk

00:00:40.226 --> 00:00:42.756 A:middle
about technologies
that build upon Metal,

00:00:43.166 --> 00:00:46.266 A:middle
helping you deliver great
rendering experiences

00:00:46.376 --> 00:00:49.136 A:middle
on both iOS and OS X.

00:00:50.416 --> 00:00:53.506 A:middle
So this is the second
of three sessions

00:00:53.606 --> 00:00:56.586 A:middle
at this years WWDC
talking about Metal.

00:00:57.546 --> 00:01:01.386 A:middle
In the first session, Rob
Duraf talked about developments



00:00:57.546 --> 00:01:01.386 A:middle
In the first session, Rob
Duraf talked about developments

00:01:01.386 --> 00:01:03.266 A:middle
in Metal that have
happened in the past year.

00:01:04.025 --> 00:01:06.206 A:middle
He also described some
of the new features

00:01:06.206 --> 00:01:08.096 A:middle
in Metal we just released.

00:01:09.476 --> 00:01:12.686 A:middle
He also described how app
thinning is a great match

00:01:12.816 --> 00:01:14.316 A:middle
for your Metal applications.

00:01:14.856 --> 00:01:19.496 A:middle
In this session, I will be
up here first to talk to you

00:01:19.496 --> 00:01:23.886 A:middle
about MetalKit, convenience
APIs allowing you bring

00:01:23.886 --> 00:01:26.556 A:middle
up Metal applications
much more quickly.

00:01:27.486 --> 00:01:30.026 A:middle
Then Anna will come up to talk

00:01:30.026 --> 00:01:32.356 A:middle
about Metal performance
shaders framework,

00:01:32.956 --> 00:01:36.086 A:middle
which offers great shaders

00:01:36.806 --> 00:01:40.276 A:middle
for common data parallel
operations available

00:01:40.276 --> 00:01:42.666 A:middle
on iOS devices with
an A8 processor.

00:01:43.186 --> 00:01:46.636 A:middle
And tomorrow, you
will get a chance

00:01:47.036 --> 00:01:50.416 A:middle
to catch the Metal Performance
Optimization Techniques session,

00:01:50.886 --> 00:01:54.346 A:middle
where they will introduce
the Metal System Trace Tool

00:01:54.926 --> 00:01:57.396 A:middle
and provide you with
some best practices

00:01:57.796 --> 00:02:00.356 A:middle
for shipping an efficient
Metal application.



00:01:57.796 --> 00:02:00.356 A:middle
for shipping an efficient
Metal application.

00:02:00.356 --> 00:02:04.966 A:middle
So let's get started
with Metal kit.

00:02:05.226 --> 00:02:08.186 A:middle
Utility functionality
for your Metal apps.

00:02:09.616 --> 00:02:13.586 A:middle
So because Metal is a low
level API, there are a number

00:02:13.586 --> 00:02:17.616 A:middle
of things you need to do
to get up and running.

00:02:17.766 --> 00:02:20.346 A:middle
MetalKit hopes to help with this

00:02:20.346 --> 00:02:22.596 A:middle
by providing efficient
implementation

00:02:22.856 --> 00:02:24.956 A:middle
for commonly used scenarios.

00:02:25.466 --> 00:02:28.576 A:middle
This requires less effort
on your part to get up

00:02:28.576 --> 00:02:31.936 A:middle
and rendering and we offer
increased performance

00:02:32.056 --> 00:02:35.676 A:middle
and stability over the
standard boilerplate code

00:02:35.866 --> 00:02:37.416 A:middle
that you might implement
yourself.

00:02:38.156 --> 00:02:41.246 A:middle
There is less maintenance
for you as the burden

00:02:41.246 --> 00:02:45.786 A:middle
of that maintenance has
been shifted from you to us.

00:02:46.046 --> 00:02:49.966 A:middle
So MetalKit consists of
three main components.

00:02:50.926 --> 00:02:53.236 A:middle
First is the MetalKit view.

00:02:53.506 --> 00:02:57.656 A:middle
A unified view class
between iOS and OS X

00:02:58.206 --> 00:02:59.596 A:middle
for rendering your Metal scenes.



00:03:01.126 --> 00:03:05.666 A:middle
Second is the texture loader
which creates texture objects

00:03:06.016 --> 00:03:08.576 A:middle
from image files on disk.

00:03:09.966 --> 00:03:14.556 A:middle
And finally, Metal kit's model
I/O integration which loads

00:03:14.676 --> 00:03:17.176 A:middle
and manages mesh data
from Metal rendering.

00:03:20.506 --> 00:03:23.366 A:middle
MetalKit view is
the simplest way

00:03:23.486 --> 00:03:25.556 A:middle
to get Metal rendering
on screen.

00:03:26.136 --> 00:03:31.746 A:middle
It's a unified class
on both iOS and OS X.

00:03:32.006 --> 00:03:34.146 A:middle
It offers pretty much
the same interface

00:03:34.406 --> 00:03:37.546 A:middle
on both Operating Systems,
but naturally it's a subclass

00:03:37.546 --> 00:03:42.956 A:middle
of UI view for iOS and a
subclass of NS view on OS X.

00:03:43.456 --> 00:03:48.126 A:middle
Its main job is to manage
displayable render targets

00:03:48.126 --> 00:03:51.276 A:middle
for you, and it creates
render path descriptors

00:03:51.326 --> 00:03:53.536 A:middle
for these render
targets automatically.

00:03:53.536 --> 00:03:58.906 A:middle
Now, it's super flexible
in terms of the ways

00:03:59.276 --> 00:04:02.206 A:middle
that it can execute
your draw code.



00:03:59.276 --> 00:04:02.206 A:middle
that it can execute
your draw code.

00:04:03.436 --> 00:04:05.676 A:middle
You can use a timer-based mode

00:04:06.206 --> 00:04:09.056 A:middle
where it will execute your
draw code at a regular interval

00:04:09.456 --> 00:04:11.416 A:middle
in synchronization
with a display,

00:04:12.806 --> 00:04:14.366 A:middle
or you can use an
event-based mode

00:04:14.366 --> 00:04:16.776 A:middle
which will trigger your
draw code whenever a touch

00:04:16.826 --> 00:04:19.836 A:middle
or UI event has occurred, so
you can respond to that event.

00:04:21.055 --> 00:04:23.836 A:middle
Finally, you can explicitly
drive your draw code,

00:04:24.156 --> 00:04:27.066 A:middle
perhaps in an open loop
on a secondary thread

00:04:27.686 --> 00:04:29.096 A:middle
at your own frame rate.

00:04:29.726 --> 00:04:35.676 A:middle
So there are two approaches
to using the MetalKit view.

00:04:37.146 --> 00:04:39.586 A:middle
The simplest approach is
to implement a delegate

00:04:39.716 --> 00:04:42.556 A:middle
to handle your draw
and resize operations.

00:04:43.336 --> 00:04:45.756 A:middle
In this case, you would
implement the draw

00:04:45.756 --> 00:04:50.386 A:middle
in view method to handle your
per-frame updates including

00:04:50.726 --> 00:04:52.456 A:middle
encoding any rendering commands.

00:04:53.846 --> 00:04:56.006 A:middle
You would also implement
the view will layout

00:04:56.126 --> 00:05:00.836 A:middle
with size method to handle
size changes to your view.



00:04:56.126 --> 00:05:00.836 A:middle
with size method to handle
size changes to your view.

00:05:01.466 --> 00:05:04.696 A:middle
This is where you might
update your projection matrix

00:05:05.016 --> 00:05:06.966 A:middle
or change any texture sizes

00:05:06.996 --> 00:05:09.366 A:middle
to better fit your
displayable area.

00:05:10.836 --> 00:05:14.566 A:middle
Now, if you have any other
pieces of the view that you need

00:05:14.566 --> 00:05:18.536 A:middle
to override, you can
subclass the MetalKit view.

00:05:18.926 --> 00:05:20.896 A:middle
And in this case on iOS,

00:05:21.666 --> 00:05:23.566 A:middle
you would override
the draw Rect method

00:05:25.126 --> 00:05:26.466 A:middle
to handle your per-frame updates

00:05:27.336 --> 00:05:30.346 A:middle
and the layout subviews
method to handle resizes.

00:05:31.156 --> 00:05:33.706 A:middle
Likewise on OS X
you would handle,

00:05:34.106 --> 00:05:36.516 A:middle
you would override these
two methods, the draw Rect

00:05:36.516 --> 00:05:38.606 A:middle
and set frame size method.

00:05:39.316 --> 00:05:49.756 A:middle
So here is an example of
setting up a view controller

00:05:49.946 --> 00:05:53.166 A:middle
that also serves as the
delegate to our view.

00:05:54.446 --> 00:05:58.896 A:middle
In the view did load method,
after we received a reference

00:05:59.106 --> 00:06:02.976 A:middle
to the view, we will assign
ourself as the delegate,



00:05:59.106 --> 00:06:02.976 A:middle
to the view, we will assign
ourself as the delegate,

00:06:04.306 --> 00:06:11.516 A:middle
and particularly important on OS
X is that we will need to choose

00:06:11.516 --> 00:06:13.376 A:middle
and set a Metal device.

00:06:13.976 --> 00:06:18.136 A:middle
Once we are done with
that, we can configure some

00:06:18.136 --> 00:06:21.186 A:middle
of the view's properties
including choosing our own

00:06:21.186 --> 00:06:23.576 A:middle
custom pixel formats
for the color

00:06:23.576 --> 00:06:24.836 A:middle
and depth and stencil buffers.

00:06:25.516 --> 00:06:28.496 A:middle
We can use multisampling

00:06:28.706 --> 00:06:32.336 A:middle
by increasing the sample count
property to a value above 1,

00:06:32.336 --> 00:06:41.036 A:middle
or we can set our
custom clear color.

00:06:41.196 --> 00:06:45.626 A:middle
Now, here is a very basic
usage of the MetalKit view

00:06:45.796 --> 00:06:48.566 A:middle
in the implementation
of the per frame update.

00:06:49.506 --> 00:06:53.336 A:middle
In our drawing view method,
we call the views render,

00:06:53.336 --> 00:06:55.466 A:middle
I'm sorry, current
render past descriptor.

00:06:55.966 --> 00:06:59.666 A:middle
Now, the first time you access
this property each frame,



00:07:00.086 --> 00:07:02.516 A:middle
the view will call
into core animation

00:07:02.816 --> 00:07:04.646 A:middle
and get a drawable back,

00:07:05.256 --> 00:07:07.406 A:middle
which you can encode
your rendering commands

00:07:07.406 --> 00:07:08.076 A:middle
and render to.

00:07:08.686 --> 00:07:12.956 A:middle
So we will render our
final render pass,

00:07:13.466 --> 00:07:15.196 A:middle
which will show up
in this drawable.

00:07:15.726 --> 00:07:18.996 A:middle
And then we will present the
drawable, which is stored

00:07:18.996 --> 00:07:20.736 A:middle
in the view's current
drawable property

00:07:21.796 --> 00:07:24.866 A:middle
and we will commit
our command buffer.

00:07:25.036 --> 00:07:26.776 A:middle
Now, because of its importance

00:07:27.296 --> 00:07:30.396 A:middle
in structuring your per-frame
updates, let me take a minute

00:07:30.656 --> 00:07:32.896 A:middle
to talk about managing
these drawables.

00:07:33.586 --> 00:07:36.906 A:middle
So there are a limited
pool of drawables

00:07:37.436 --> 00:07:40.026 A:middle
in this system all
managed by core animation.

00:07:41.556 --> 00:07:44.246 A:middle
There are only a few of them
mostly because of their size,

00:07:44.246 --> 00:07:45.456 A:middle
they take up some space.

00:07:46.556 --> 00:07:49.346 A:middle
Now, these drawables
are concurrently used

00:07:49.346 --> 00:07:52.456 A:middle
through many stages of
the display pipeline.

00:07:53.916 --> 00:07:55.206 A:middle
Here is roughly how it works.

00:07:55.656 --> 00:07:57.706 A:middle
First, your application
encodes commands

00:07:57.706 --> 00:07:58.926 A:middle
to be rendered onto
the drawable.



00:08:00.016 --> 00:08:02.216 A:middle
It sends that drawable
down to the GPU

00:08:02.596 --> 00:08:05.656 A:middle
as your application encodes
commands for the next frame

00:08:05.876 --> 00:08:09.766 A:middle
and the GPU renders to that
drawable, and core animation

00:08:09.766 --> 00:08:11.666 A:middle
at this stage may do compositing

00:08:11.666 --> 00:08:15.026 A:middle
with other layers
into that drawable.

00:08:15.636 --> 00:08:19.726 A:middle
And finally, the display
can take the drawable

00:08:19.726 --> 00:08:21.016 A:middle
and slap it up onto the screen.

00:08:21.966 --> 00:08:24.086 A:middle
Now, the display can't
replace it with anything

00:08:24.086 --> 00:08:25.806 A:middle
until another drawable
is available.

00:08:26.106 --> 00:08:29.106 A:middle
So if any of these previous
stages are taking a lot of time,

00:08:29.416 --> 00:08:31.166 A:middle
it just has to sit
there for awhile.

00:08:31.606 --> 00:08:36.876 A:middle
Additionally, the display can't
recycle that drawable back

00:08:36.876 --> 00:08:39.015 A:middle
up to your frame until it
has something available.

00:08:39.015 --> 00:08:44.986 A:middle
So let's take a look at
your application frame

00:08:45.436 --> 00:08:47.456 A:middle
with respect to these drawables.

00:08:48.936 --> 00:08:51.796 A:middle
First, you call the MetalKit
views current render past

00:08:51.796 --> 00:08:54.166 A:middle
descriptor which
reserves a drawable.

00:08:54.166 --> 00:08:59.176 A:middle
Then you will encode rendering
commands that you want

00:08:59.176 --> 00:09:02.136 A:middle
into that drawable, and
finally you will present



00:08:59.176 --> 00:09:02.136 A:middle
into that drawable, and
finally you will present

00:09:02.236 --> 00:09:03.196 A:middle
and commit the drawable

00:09:03.396 --> 00:09:06.366 A:middle
which will release it
back to core animation.

00:09:06.926 --> 00:09:11.266 A:middle
Now, this is fine if all we
are doing is rendering a single

00:09:11.266 --> 00:09:13.156 A:middle
render pass, however,

00:09:13.156 --> 00:09:16.246 A:middle
it's likely we will
do other operations

00:09:16.856 --> 00:09:24.216 A:middle
such as some app logic, encoding
in offscreen render pass

00:09:24.456 --> 00:09:28.076 A:middle
where we don't actually
need the drawable,

00:09:28.076 --> 00:09:31.166 A:middle
or running some compute
kernels for physics or whatnot.

00:09:31.716 --> 00:09:36.426 A:middle
In this case we are
essentially hogging the drawable

00:09:36.426 --> 00:09:39.216 A:middle
from our future self because
in a subsequent frame,

00:09:39.216 --> 00:09:41.816 A:middle
we will call this current
render pass descriptor

00:09:42.256 --> 00:09:44.996 A:middle
and it will sit there
waiting for a drawable

00:09:44.996 --> 00:09:47.176 A:middle
to become available,
which may not be the case

00:09:47.176 --> 00:09:50.936 A:middle
because we are doing these other
operations and reserving it

00:09:50.936 --> 00:09:52.186 A:middle
for much longer than we need to.

00:09:52.606 --> 00:09:54.086 A:middle
So to solve this problem,

00:09:54.876 --> 00:09:58.136 A:middle
let's put these operations
before our access

00:09:58.246 --> 00:09:59.906 A:middle
to the current render
pass descriptor.



00:10:00.436 --> 00:10:04.306 A:middle
Now, let me just note that
this isn't a problem specific

00:10:04.396 --> 00:10:05.536 A:middle
to the MetalKit view.

00:10:05.896 --> 00:10:08.816 A:middle
You need to be aware of this
issue if you roll your own view

00:10:09.066 --> 00:10:11.056 A:middle
in access core animation
directly.

00:10:12.126 --> 00:10:17.656 A:middle
So this is information that's
quite useful in any case.

00:10:18.526 --> 00:10:20.846 A:middle
Now, here is a more
complete example

00:10:20.846 --> 00:10:22.806 A:middle
of our per-frame
rendering update.

00:10:23.816 --> 00:10:27.316 A:middle
First, as I described we want to
update our app's render state,

00:10:28.046 --> 00:10:29.866 A:middle
encode any offscreen passes,

00:10:30.166 --> 00:10:31.986 A:middle
do anything where we
don't need the drawable.

00:10:32.576 --> 00:10:36.266 A:middle
And then we can continue
as we did previously,

00:10:36.266 --> 00:10:39.256 A:middle
get the current render pass
descriptor, encode our commands

00:10:39.256 --> 00:10:41.996 A:middle
for that final pass, and present
and commit our command buffer.

00:10:42.996 --> 00:10:46.166 A:middle
The key point is that
these two stages should be

00:10:46.166 --> 00:10:48.236 A:middle
as close together as possible.

00:10:49.016 --> 00:10:52.166 A:middle
It's a critical section where
we are holding onto a resource

00:10:52.736 --> 00:10:57.386 A:middle
and we don't want to hold onto
it any longer than we need to.

00:10:57.626 --> 00:10:58.476 A:middle
That's it for the view.



00:11:00.216 --> 00:11:01.886 A:middle
Let's move on to
the texture loader.

00:11:02.476 --> 00:11:06.036 A:middle
It's textural loading
made simple.

00:11:07.096 --> 00:11:11.336 A:middle
You give a reference and
you get back a fully formed

00:11:11.666 --> 00:11:12.446 A:middle
Metal Texture.

00:11:13.006 --> 00:11:18.586 A:middle
Not only is it simple, it's
fast and fully featured.

00:11:19.656 --> 00:11:22.226 A:middle
It asynchronously decodes files

00:11:22.976 --> 00:11:26.486 A:middle
and creates textures
on a separate thread.

00:11:27.936 --> 00:11:31.376 A:middle
It has support for many common
image file formats including

00:11:31.376 --> 00:11:36.076 A:middle
JPG, TIF and PNG and
also supports the PVR

00:11:36.336 --> 00:11:38.646 A:middle
and KTX texture file formats.

00:11:38.996 --> 00:11:43.026 A:middle
What's interesting about these
formats is that they store data

00:11:43.296 --> 00:11:47.166 A:middle
in a raw form that can be
uploaded to your Metal Texture

00:11:47.166 --> 00:11:48.516 A:middle
without any conversion.

00:11:49.516 --> 00:11:54.996 A:middle
Additionally, you can encode
data for MIT maps for any

00:11:55.146 --> 00:11:58.896 A:middle
of the other types of
textures including 3D textures,

00:11:59.336 --> 00:12:01.886 A:middle
cube maps, and texture arrays.



00:11:59.336 --> 00:12:01.886 A:middle
cube maps, and texture arrays.

00:12:05.716 --> 00:12:07.206 A:middle
Its usage is really simple.

00:12:08.716 --> 00:12:10.976 A:middle
First, we create a
texture loader object

00:12:11.416 --> 00:12:13.386 A:middle
by supplying a device.

00:12:14.916 --> 00:12:17.586 A:middle
Then, once we have that
texture loader object,

00:12:17.586 --> 00:12:20.356 A:middle
we can create many
textures with it.

00:12:21.196 --> 00:12:26.116 A:middle
First, we will give a URL
location of our image file,

00:12:26.786 --> 00:12:29.996 A:middle
and we can supply a number of
options including how we want

00:12:29.996 --> 00:12:33.886 A:middle
to treat the sRGB information
in the file or whether

00:12:33.886 --> 00:12:36.136 A:middle
or not we want to allocate
memory for MIT maps

00:12:36.546 --> 00:12:37.866 A:middle
when we create this texture,

00:12:38.496 --> 00:12:42.426 A:middle
and finally we will supply
a completion handler block.

00:12:42.936 --> 00:12:45.526 A:middle
Now, this block will
get executed as soon

00:12:45.526 --> 00:12:48.206 A:middle
as the texture loader has
finished loading the texture

00:12:48.276 --> 00:12:49.086 A:middle
and created it.

00:12:49.166 --> 00:12:51.056 A:middle
It will pass the texture
handler back to you

00:12:51.096 --> 00:12:54.086 A:middle
which you can stash away
for later and render

00:12:54.086 --> 00:12:57.166 A:middle
with when you need to.

00:12:57.356 --> 00:12:59.396 A:middle
That's very simple,
the texture loader.

00:12:59.506 --> 00:13:02.686 A:middle
Let's move on to model I/O.



00:12:59.506 --> 00:13:02.686 A:middle
Let's move on to model I/O.

00:13:04.496 --> 00:13:07.236 A:middle
So model I/0 is a new
framework introduced

00:13:07.236 --> 00:13:09.396 A:middle
with iOS 9 and OS X El Capitan.

00:13:11.236 --> 00:13:13.246 A:middle
And one of its key features is

00:13:13.246 --> 00:13:17.696 A:middle
that it can load many
model file formats for you.

00:13:19.006 --> 00:13:22.336 A:middle
You can create your own
importers and exporters

00:13:22.366 --> 00:13:25.056 A:middle
for proprietary formats
if you need to.

00:13:25.056 --> 00:13:28.776 A:middle
Some of the cooler
features here are

00:13:28.776 --> 00:13:32.806 A:middle
that you can do offline
baking operations.

00:13:32.806 --> 00:13:36.286 A:middle
You can create static
ambient occlusion maps,

00:13:36.826 --> 00:13:40.856 A:middle
light map generations, it
also includes the Voxelization

00:13:40.956 --> 00:13:41.656 A:middle
of your meshes.

00:13:42.256 --> 00:13:48.536 A:middle
It provides you a way to
focus on your rendering code

00:13:48.536 --> 00:13:49.636 A:middle
and write your shaders.

00:13:49.706 --> 00:13:52.346 A:middle
You don't have to deal
with creating some parchers

00:13:52.346 --> 00:13:53.766 A:middle
to get some stuff off disk.

00:13:53.766 --> 00:13:57.106 A:middle
You have to deal less
with serialization,

00:13:57.776 --> 00:14:00.606 A:middle
you just load a model
file with Model I/O,



00:13:57.776 --> 00:14:00.606 A:middle
you just load a model
file with Model I/O,

00:14:01.636 --> 00:14:03.566 A:middle
put it into some form
you can render it with,

00:14:04.246 --> 00:14:06.596 A:middle
and start writing your shaders.

00:14:06.596 --> 00:14:12.216 A:middle
So what does MetalKit
provide in this context?

00:14:12.216 --> 00:14:15.456 A:middle
It's utilities to efficiently
use model I/O with Metal.

00:14:16.796 --> 00:14:19.636 A:middle
It offers optimized
loading of model I/O meshes

00:14:19.636 --> 00:14:23.786 A:middle
into Metal buffers, the
encapsulation of mesh data

00:14:24.206 --> 00:14:28.606 A:middle
within MetalKit objects, and
there are a number of functions

00:14:28.606 --> 00:14:31.676 A:middle
to prepare mesh data
for Metal pipelines.

00:14:32.326 --> 00:14:40.356 A:middle
Let me walk you through the
process of loading a model file

00:14:41.426 --> 00:14:46.026 A:middle
with model I/O and getting it
rendering on screen with Metal.

00:14:46.596 --> 00:14:53.626 A:middle
And here are the
steps we will take.

00:14:53.846 --> 00:14:58.986 A:middle
So first, we will create a
Metal render state pipeline

00:14:58.986 --> 00:15:01.866 A:middle
that we'll use to create our
mesh, to render our mesh.



00:14:58.986 --> 00:15:01.866 A:middle
that we'll use to create our
mesh, to render our mesh.

00:15:02.406 --> 00:15:06.256 A:middle
Then we will actually
load the model file

00:15:06.336 --> 00:15:09.426 A:middle
by initializing the
model I/O asset.

00:15:10.456 --> 00:15:14.506 A:middle
And with that asset, we
will create MetalKit mesh

00:15:14.506 --> 00:15:16.076 A:middle
and sub mesh objects.

00:15:17.496 --> 00:15:20.416 A:middle
Finally, we will render
those objects with Metal.

00:15:22.216 --> 00:15:26.146 A:middle
So let's focus on creating a
Metal Render State Pipeline

00:15:27.316 --> 00:15:29.436 A:middle
and we will pay particular
attention

00:15:29.756 --> 00:15:33.356 A:middle
to creating a vertex descriptor
that will describe the layout

00:15:33.356 --> 00:15:36.326 A:middle
of vertices that we'll
need our mesh to be

00:15:36.326 --> 00:15:40.086 A:middle
in to feed our pipeline.

00:15:40.086 --> 00:15:43.226 A:middle
Here is the bare bones
of a vertex shader.

00:15:45.046 --> 00:15:48.306 A:middle
It uses the stage in
qualifier which basically says

00:15:48.306 --> 00:15:51.776 A:middle
that our per vertex
inputs, the layout for them,

00:15:52.306 --> 00:15:54.426 A:middle
will be described
outside of the shader

00:15:54.426 --> 00:15:58.156 A:middle
in our objective-C code
using a vertex descriptor.

00:15:59.626 --> 00:16:02.386 A:middle
It uses this vertex
input structure



00:15:59.626 --> 00:16:02.386 A:middle
It uses this vertex
input structure

00:16:03.556 --> 00:16:04.706 A:middle
which is defined up here.

00:16:06.096 --> 00:16:09.406 A:middle
And the key part of this vertex
input structure are these

00:16:09.506 --> 00:16:13.026 A:middle
attributes, the indices here
which we will use to connect

00:16:13.026 --> 00:16:16.306 A:middle
up outside inside of
our Objective-C code.

00:16:17.136 --> 00:16:22.136 A:middle
Note that these floating-point
vector types define how the data

00:16:22.136 --> 00:16:27.456 A:middle
looks within the shader, not
actually how the data looks

00:16:27.456 --> 00:16:29.366 A:middle
as it's being fed
into the shader

00:16:29.416 --> 00:16:30.686 A:middle
from our Objective-C code.

00:16:33.036 --> 00:16:41.226 A:middle
For that, we need to
create a vertex descriptor.

00:16:41.796 --> 00:16:46.296 A:middle
Now, I'm going to put this
vertex input structure

00:16:46.296 --> 00:16:49.826 A:middle
up here just for reference,
but let me just remind you

00:16:49.826 --> 00:16:53.136 A:middle
that it does not define
the layout of the data

00:16:53.456 --> 00:16:54.796 A:middle
as it's being fed
into the shader.

00:16:54.796 --> 00:16:57.256 A:middle
We are actually creating
the Metal Vertex Descriptor

00:16:57.756 --> 00:17:01.146 A:middle
that is down below.



00:16:57.756 --> 00:17:01.146 A:middle
that is down below.

00:17:01.826 --> 00:17:06.256 A:middle
And for that, what we will
do is for attribute zero,

00:17:07.156 --> 00:17:12.796 A:middle
the position will define as
using three floating points,

00:17:13.215 --> 00:17:14.876 A:middle
three floating point values.

00:17:15.986 --> 00:17:23.756 A:middle
For attribute one, the color
will specify that it's going

00:17:23.756 --> 00:17:26.736 A:middle
to be composed of four
unsigned characters,

00:17:26.965 --> 00:17:29.666 A:middle
not the four floats above,
four unsigned characters

00:17:29.906 --> 00:17:31.396 A:middle
and it will have an offset

00:17:32.506 --> 00:17:40.906 A:middle
of 12 bytes immediately
following the position data.

00:17:41.086 --> 00:17:46.636 A:middle
Now, for the texture coordinates
in attribute 2, we will define

00:17:46.636 --> 00:17:49.026 A:middle
that it uses two half floats.

00:17:49.586 --> 00:17:55.756 A:middle
And that it immediately follows
the position and color data

00:17:55.836 --> 00:17:57.556 A:middle
with an offset of 16 bytes.

00:17:58.056 --> 00:18:02.576 A:middle
And finally, we will
specify that the size



00:17:58.056 --> 00:18:02.576 A:middle
And finally, we will
specify that the size

00:18:02.576 --> 00:18:05.656 A:middle
of each vertex is 20 bytes
by setting the stride

00:18:05.896 --> 00:18:07.646 A:middle
to 20 for that buffer.

00:18:11.736 --> 00:18:15.676 A:middle
Now, this defines the
layout of each vertex

00:18:15.786 --> 00:18:17.776 A:middle
within our array of vertices.

00:18:17.776 --> 00:18:23.386 A:middle
So now that we have got our
Metal Vertex Descriptor,

00:18:23.986 --> 00:18:26.046 A:middle
we can assign it to our
render state pipeline,

00:18:27.636 --> 00:18:28.426 A:middle
and with that render --

00:18:28.526 --> 00:18:31.016 A:middle
excuse me, with the
render pipeline descriptor,

00:18:31.306 --> 00:18:34.256 A:middle
we can create a Metal
Render State Pipeline.

00:18:35.776 --> 00:18:40.246 A:middle
So let's move on to
actually loading our asset

00:18:41.056 --> 00:18:45.646 A:middle
and using model I/O
for that task.

00:18:46.326 --> 00:18:49.086 A:middle
And we will actually use the
vertex descriptor we just

00:18:49.086 --> 00:18:50.366 A:middle
created in the previous step,

00:18:51.336 --> 00:18:55.056 A:middle
along with a MetalKit
mesh buffer object,

00:18:55.516 --> 00:18:58.066 A:middle
a mesh buffer allocator object.

00:18:58.876 --> 00:19:00.636 A:middle
I will describe a
little bit more



00:18:58.876 --> 00:19:00.636 A:middle
I will describe a
little bit more

00:19:00.636 --> 00:19:06.456 A:middle
about its importance
as we continue.

00:19:06.556 --> 00:19:11.426 A:middle
So the model I/O
vertex descriptor

00:19:11.686 --> 00:19:14.506 A:middle
and Metal Vertex
Descriptor are very similar,

00:19:15.586 --> 00:19:18.726 A:middle
but while the model I/O vertex
descriptor describes the layouts

00:19:18.726 --> 00:19:20.796 A:middle
of vertex attributes
within a mesh,

00:19:22.336 --> 00:19:25.076 A:middle
the Metal Vertex Descriptor
describes the layout

00:19:25.076 --> 00:19:27.156 A:middle
of vertex attributes
as their input

00:19:27.666 --> 00:19:29.166 A:middle
to a render state pipeline.

00:19:30.536 --> 00:19:33.696 A:middle
Now, they are intentionally
designed to look similar

00:19:34.456 --> 00:19:38.386 A:middle
as they contain attribute
and buffer layout objects,

00:19:39.376 --> 00:19:43.396 A:middle
and the reason for this is
it simplifies the translation

00:19:43.396 --> 00:19:44.906 A:middle
of one object to another.

00:19:47.366 --> 00:19:52.276 A:middle
Now, each attribute in a model
I/O vertex descriptor has an

00:19:52.276 --> 00:19:53.866 A:middle
identifying string base name.

00:19:54.836 --> 00:19:59.456 A:middle
Model I/O assigns a default
name if one does not exist

00:19:59.486 --> 00:20:02.626 A:middle
in the model file or that
model file does not support



00:19:59.486 --> 00:20:02.626 A:middle
in the model file or that
model file does not support

00:20:02.626 --> 00:20:03.366 A:middle
these names.

00:20:04.046 --> 00:20:07.046 A:middle
These names include position,
normal, texture, coordinate,

00:20:07.046 --> 00:20:11.046 A:middle
color, et cetera, and
model I/0 defines these

00:20:11.046 --> 00:20:14.746 A:middle
with the string based
MDLVertex attribute constants.

00:20:15.856 --> 00:20:19.796 A:middle
There are a number of files
including the Alembic file

00:20:19.796 --> 00:20:23.136 A:middle
format where you can
customize those names.

00:20:23.796 --> 00:20:27.646 A:middle
Be aware if you are changing
the names you will need

00:20:27.646 --> 00:20:31.806 A:middle
to access these attributes
with those customized names.

00:20:32.406 --> 00:20:39.146 A:middle
So we recommend that you create
a custom model I/O vertex

00:20:39.146 --> 00:20:42.366 A:middle
descriptor, because by default
model I/O loads vertices

00:20:42.586 --> 00:20:43.816 A:middle
as high-precision

00:20:44.066 --> 00:20:48.526 A:middle
yet memory-hungry
floating-point types.

00:20:48.526 --> 00:20:52.446 A:middle
This is one of the
advantages of using model I/0.

00:20:52.916 --> 00:20:58.976 A:middle
You can actually load a model
format and have the vertex data

00:20:58.976 --> 00:21:03.486 A:middle
in any form that you would like
and use model I/0 to massage



00:20:58.976 --> 00:21:03.486 A:middle
in any form that you would like
and use model I/0 to massage

00:21:03.536 --> 00:21:06.596 A:middle
that data into a format
you can actually use.

00:21:07.306 --> 00:21:09.766 A:middle
In this case, we want
to feed the pipelines

00:21:10.126 --> 00:21:11.206 A:middle
with the smallest type

00:21:11.596 --> 00:21:13.796 A:middle
that meets your precision
requirements.

00:21:14.186 --> 00:21:17.686 A:middle
This would improve your
vertex bandwidth efficiency;

00:21:18.036 --> 00:21:20.716 A:middle
as you are feeding each
vertex to the pipeline,

00:21:21.066 --> 00:21:23.086 A:middle
you don't really want
a bloated vertex.

00:21:23.626 --> 00:21:28.756 A:middle
So here is the layout
we defined previously

00:21:28.756 --> 00:21:30.906 A:middle
when creating our Metal
Vertex Descriptor.

00:21:31.456 --> 00:21:37.186 A:middle
Now, we will create our
model I/O vertex descriptor

00:21:37.606 --> 00:21:42.406 A:middle
by calling this MTK model
I/O vertex format from Metal

00:21:42.486 --> 00:21:45.426 A:middle
and we will supply our
Metal Vertex Descriptor.

00:21:45.716 --> 00:21:51.546 A:middle
This builds the majority of this
model I/O vertex descriptor,

00:21:52.376 --> 00:21:55.786 A:middle
yet we still need to tag
each attribute with a name,

00:21:55.786 --> 00:21:59.136 A:middle
so model I/O knows what
we are talking about.



00:22:00.066 --> 00:22:03.646 A:middle
So for attribute
0, we will tag it

00:22:03.646 --> 00:22:06.216 A:middle
with the vertex attribute
position name.

00:22:07.446 --> 00:22:10.846 A:middle
And similarly for attribute
1 and 2, we will tag them

00:22:10.846 --> 00:22:13.696 A:middle
with a color and texture
coordinate attributes.

00:22:17.036 --> 00:22:20.096 A:middle
The other thing we will do here
is we will create a MetalKit

00:22:20.356 --> 00:22:24.466 A:middle
mesh buffer allocator and we
will supply a Metal device.

00:22:24.996 --> 00:22:29.376 A:middle
Now, what this object does
is it allows model I/0

00:22:29.906 --> 00:22:35.116 A:middle
to load vertex data directly
into GPU backed memory.

00:22:35.936 --> 00:22:39.056 A:middle
Now, you don't have to use a
MetalKit mesh buffer allocator,

00:22:39.856 --> 00:22:44.206 A:middle
but what that will do is it
will allocate system memory

00:22:44.676 --> 00:22:49.876 A:middle
for these vertex and index
buffers inside of the mesh.

00:22:50.136 --> 00:22:53.596 A:middle
And when you want to actually
render it, we will need to copy

00:22:53.626 --> 00:22:56.816 A:middle
from that system memory down
into the GPU backed memory.

00:22:56.816 --> 00:23:01.926 A:middle
So for efficiency, it's
really desirable to use one



00:22:56.816 --> 00:23:01.926 A:middle
So for efficiency, it's
really desirable to use one

00:23:01.926 --> 00:23:05.026 A:middle
of these mesh buffer allocators,
and here is how you use it.

00:23:06.106 --> 00:23:09.856 A:middle
Now, we are going to
load our asset file.

00:23:10.086 --> 00:23:16.806 A:middle
We will supply the URL location,
the model I/0 vertex descriptor

00:23:16.806 --> 00:23:19.996 A:middle
which will tell model I/0
how to lay out each vertex

00:23:21.366 --> 00:23:24.406 A:middle
and we will also supply
this mesh buffer allocator

00:23:24.996 --> 00:23:28.006 A:middle
so that model I/0 can
load this data directly

00:23:28.006 --> 00:23:29.656 A:middle
into GPU backed memory.

00:23:30.916 --> 00:23:35.336 A:middle
So now that we have
got our asset,

00:23:35.556 --> 00:23:37.986 A:middle
let's actually create
some MetalKit mesh

00:23:37.986 --> 00:23:39.146 A:middle
and some mesh objects.

00:23:39.146 --> 00:23:43.636 A:middle
So here's an example of an asset

00:23:43.636 --> 00:23:47.686 A:middle
that might be created
by model I/0.

00:23:47.866 --> 00:23:51.606 A:middle
Inside of an asset, we
might have camera objects,

00:23:53.236 --> 00:23:57.616 A:middle
light objects, and
particularly important

00:23:57.616 --> 00:23:59.966 A:middle
to us right now are
the mesh objects.



00:24:00.346 --> 00:24:03.266 A:middle
Now, MetalKit is
primarily concerned

00:24:03.266 --> 00:24:04.166 A:middle
with these mesh objects.

00:24:04.166 --> 00:24:07.226 A:middle
It doesn't really deal
directly with the light

00:24:07.336 --> 00:24:10.876 A:middle
and camera objects because that
sort of data is very specific

00:24:11.166 --> 00:24:13.886 A:middle
to your custom shaders
and your engines.

00:24:14.676 --> 00:24:18.246 A:middle
You can actually
introspect into this object

00:24:18.246 --> 00:24:20.876 A:middle
or go look inside this object
and grab out that camera

00:24:20.876 --> 00:24:23.806 A:middle
and light information to
plug it into your shaders,

00:24:24.086 --> 00:24:27.106 A:middle
but MetalKit isn't directly
involved in that process.

00:24:28.116 --> 00:24:38.066 A:middle
So what we can do is pass
in this asset directly

00:24:38.066 --> 00:24:42.386 A:middle
to this mesh, meshes
from asset class function

00:24:42.756 --> 00:24:46.246 A:middle
which will create an
array of MetalKit meshes.

00:24:50.636 --> 00:24:54.006 A:middle
Let's take a look at what's
inside this mesh object.

00:24:55.276 --> 00:24:57.476 A:middle
So first are these
vertex buffers

00:24:57.476 --> 00:25:00.106 A:middle
which includes the
position attributes,



00:24:57.476 --> 00:25:00.106 A:middle
which includes the
position attributes,

00:25:00.366 --> 00:25:04.006 A:middle
the normal attributes,
textural attributes, et cetera.

00:25:04.406 --> 00:25:07.496 A:middle
In our example, we
only needed one array

00:25:07.696 --> 00:25:09.366 A:middle
because we interleaved
all of our data.

00:25:09.946 --> 00:25:13.696 A:middle
However, you can define the
layout to use multiple arrays,

00:25:13.696 --> 00:25:17.216 A:middle
and therefore you would have
multiple vertex buffers.

00:25:17.376 --> 00:25:21.326 A:middle
You could define that
attribute 0 would be inside

00:25:21.426 --> 00:25:23.966 A:middle
of a single array, so you would
have an array of positions

00:25:24.476 --> 00:25:28.156 A:middle
in one array, an array of
texture coordinates in the next,

00:25:28.636 --> 00:25:32.056 A:middle
another array with
colors, and so on.

00:25:35.276 --> 00:25:37.696 A:middle
The mesh also includes
a vertex descriptor

00:25:37.696 --> 00:25:39.336 A:middle
which defines this layout

00:25:39.436 --> 00:25:41.896 A:middle
and it's the same object
we just created and passed

00:25:41.896 --> 00:25:45.266 A:middle
in when we initialized
our asset.

00:25:46.026 --> 00:25:49.716 A:middle
And finally, the mesh contains
a number of sub mesh objects.

00:25:50.086 --> 00:25:53.666 A:middle
Now, the key part of each
sub mesh object is this index

00:25:53.696 --> 00:25:57.506 A:middle
buffer, which references
vertices inside the

00:25:57.506 --> 00:25:59.846 A:middle
vertex buffer.



00:26:00.016 --> 00:26:03.076 A:middle
Additionally, there are a number
of properties which you can use

00:26:03.566 --> 00:26:08.556 A:middle
to make a draw call with Metal.

00:26:08.696 --> 00:26:12.696 A:middle
So now that we have
got our Metal kit mesh

00:26:12.696 --> 00:26:21.086 A:middle
and sub mesh objects, let's
go ahead and render them.

00:26:21.586 --> 00:26:26.046 A:middle
So first we will iterate
through each vertex buffer.

00:26:27.426 --> 00:26:29.796 A:middle
Now, we may have a sparse
array, so we need to make sure

00:26:29.796 --> 00:26:32.136 A:middle
that there is actually
something in each buffer,

00:26:32.136 --> 00:26:35.956 A:middle
but once we are sure of
that, we can continue on

00:26:35.956 --> 00:26:39.716 A:middle
and set the vertex buffer
in our render encoder.

00:26:40.696 --> 00:26:43.346 A:middle
Now, the vertex buffer
actually has two properties,

00:26:43.556 --> 00:26:47.126 A:middle
the buffer itself, and an
offset within the buffer

00:26:47.616 --> 00:26:50.026 A:middle
where your vertex data resides.

00:26:50.026 --> 00:26:57.046 A:middle
We also need to supply a buffer
index telling the pipeline

00:26:57.546 --> 00:26:59.316 A:middle
exactly where the data is.

00:26:59.946 --> 00:27:03.826 A:middle
Now, we will actually
render our mesh.



00:26:59.946 --> 00:27:03.826 A:middle
Now, we will actually
render our mesh.

00:27:04.756 --> 00:27:06.466 A:middle
We will iterate through
every sub mesh,

00:27:07.906 --> 00:27:10.156 A:middle
and make our draw
index primitives call.

00:27:11.126 --> 00:27:15.506 A:middle
Note here that the sub mesh
has all of the parameters

00:27:15.506 --> 00:27:18.496 A:middle
for this draw index parameter.

00:27:20.416 --> 00:27:25.486 A:middle
So today we posted this
MetalKit essentials sample

00:27:25.486 --> 00:27:28.696 A:middle
on the WWDC 2015 site.

00:27:29.396 --> 00:27:31.356 A:middle
I encourage you to download it.

00:27:31.356 --> 00:27:34.116 A:middle
It describes a number of
the techniques I described.

00:27:34.506 --> 00:27:38.936 A:middle
It uses model I/0 to load this
little airplane object that's

00:27:38.996 --> 00:27:44.666 A:middle
stuffed in an OBJ file and
creates a MetalKit mesh

00:27:45.126 --> 00:27:47.226 A:middle
and renders it on screen.

00:27:47.526 --> 00:27:51.186 A:middle
So you can get an idea of
exactly how this is all done.

00:27:51.686 --> 00:27:55.966 A:middle
So I encourage you
to check that out.

00:27:56.226 --> 00:27:58.356 A:middle
So that's it for me,
my name is Dan Omachi,

00:27:58.616 --> 00:28:02.076 A:middle
I will be at the Metal Lab
tomorrow if you have questions



00:27:58.616 --> 00:28:02.076 A:middle
I will be at the Metal Lab
tomorrow if you have questions

00:28:02.076 --> 00:28:03.516 A:middle
about topics I have discussed.

00:28:03.516 --> 00:28:07.366 A:middle
I would like to welcome my
colleague, Anna Tikhonova

00:28:07.366 --> 00:28:12.336 A:middle
on stage to talk about the Metal
performance shaders frameworks.

00:28:12.636 --> 00:28:12.976 A:middle
Thank you.

00:28:13.516 --> 00:28:18.546 A:middle
[ Applause ]

00:28:19.046 --> 00:28:19.386 A:middle
&gt;&gt; ANNA TIKHONOVA: Good morning.

00:28:20.276 --> 00:28:22.676 A:middle
Thank you, Dan, for the
introduction, my name is Anna

00:28:23.206 --> 00:28:26.086 A:middle
and I will be talking to you
about Metal performance shaders.

00:28:26.266 --> 00:28:26.996 A:middle
Let's get started.

00:28:27.946 --> 00:28:29.926 A:middle
So first of all, what is it?

00:28:30.406 --> 00:28:34.276 A:middle
It's a framework of optimized
high performance data parallel

00:28:34.276 --> 00:28:35.926 A:middle
algorithms for the GPU in Metal.

00:28:37.066 --> 00:28:38.156 A:middle
When and why would you use it?

00:28:39.136 --> 00:28:41.466 A:middle
If you are writing
C code and you want

00:28:41.466 --> 00:28:42.996 A:middle
to add a common sorting
algorithm

00:28:42.996 --> 00:28:46.486 A:middle
to your CPU application, you are
very unlikely to implement one

00:28:46.486 --> 00:28:49.346 A:middle
from scratch unless it
was out of self-interest.

00:28:49.976 --> 00:28:52.736 A:middle
You are a lot more likely to
use the implementation provided

00:28:52.736 --> 00:28:56.746 A:middle
to you by the library because
it's already been debugged

00:28:56.986 --> 00:28:58.096 A:middle
and optimized for you.

00:28:59.006 --> 00:29:02.036 A:middle
Likewise, if you wanted to add
an image processing operation



00:28:59.006 --> 00:29:02.036 A:middle
Likewise, if you wanted to add
an image processing operation

00:29:02.036 --> 00:29:05.496 A:middle
to your CPU application,
on our platform,

00:29:05.496 --> 00:29:07.086 A:middle
you would use the
accelerate framework

00:29:07.466 --> 00:29:08.716 A:middle
because it uses vImage.

00:29:09.596 --> 00:29:10.796 A:middle
It's a powerful,

00:29:10.796 --> 00:29:14.976 A:middle
high-performance tuned image
processing framework for --

00:29:16.256 --> 00:29:19.136 A:middle
that utilizes the CPU's
vector processing.

00:29:19.656 --> 00:29:21.536 A:middle
These are just a few examples.

00:29:22.516 --> 00:29:25.636 A:middle
The point is that there is
a rich environment available

00:29:25.636 --> 00:29:26.836 A:middle
for your CPU applications.

00:29:27.496 --> 00:29:30.096 A:middle
On the GPU the story
is a bit different,

00:29:30.866 --> 00:29:33.366 A:middle
you simply have fewer
options but we would

00:29:33.366 --> 00:29:34.466 A:middle
like to change the story.

00:29:34.546 --> 00:29:38.136 A:middle
Our goal is to enrich your
Metal programming environment.

00:29:38.776 --> 00:29:42.536 A:middle
We have selected a
collection of common filters

00:29:42.756 --> 00:29:45.746 A:middle
that we see often used in
graphic processing pipelines

00:29:46.066 --> 00:29:47.956 A:middle
in your image processing
applications and games.

00:29:49.736 --> 00:29:53.656 A:middle
These algorithms are
optimized for iOS and available

00:29:53.906 --> 00:29:55.966 A:middle
in iOS 9 for the A8 processor.

00:29:56.996 --> 00:30:00.306 A:middle
The Metal performance shaders
framework has two goals,



00:29:56.996 --> 00:30:00.306 A:middle
The Metal performance shaders
framework has two goals,

00:30:00.786 --> 00:30:02.956 A:middle
performance and ease of use.

00:30:03.336 --> 00:30:05.416 A:middle
It's designed to
integrate easily

00:30:05.496 --> 00:30:06.726 A:middle
into your Metal applications.

00:30:07.476 --> 00:30:10.136 A:middle
It operates on Metal
resources directly.

00:30:10.596 --> 00:30:13.356 A:middle
They are the input
and the output.

00:30:13.356 --> 00:30:14.936 A:middle
We are not only giving
you collection

00:30:15.206 --> 00:30:18.086 A:middle
of these high performance
optimized awesome kernels --

00:30:18.386 --> 00:30:22.156 A:middle
we are giving you that, but
we are also taking care of all

00:30:22.156 --> 00:30:24.996 A:middle
of the host code necessary
to launch these kernels.

00:30:25.716 --> 00:30:28.756 A:middle
We take care of the
decision-making process of how

00:30:28.756 --> 00:30:30.996 A:middle
to split up the work for
parallel computation.

00:30:31.556 --> 00:30:35.556 A:middle
The work you have to do to take
advantage of this framework

00:30:35.556 --> 00:30:37.656 A:middle
in your applications
usually amounts

00:30:37.656 --> 00:30:40.266 A:middle
to only a few lines of code.

00:30:40.436 --> 00:30:42.636 A:middle
It's as simple as calling
a library function.

00:30:44.226 --> 00:30:46.186 A:middle
So now that I have introduced
the framework to you,

00:30:46.366 --> 00:30:48.306 A:middle
let's take a look at the
available operations.

00:30:49.296 --> 00:30:52.396 A:middle
Here is a full list and let's
start from the beginning.

00:30:52.666 --> 00:30:54.296 A:middle
I will cover just a
few of these actually

00:30:54.476 --> 00:30:55.586 A:middle
and I will show you examples.

00:30:56.756 --> 00:30:59.806 A:middle
So first, the framework
supports the histogram filter

00:30:59.806 --> 00:31:02.726 A:middle
and the histogram equalization
and specification filters.



00:30:59.806 --> 00:31:02.726 A:middle
and the histogram equalization
and specification filters.

00:31:03.846 --> 00:31:06.116 A:middle
The equalization and
specification filters,

00:31:06.566 --> 00:31:10.596 A:middle
they allow you to
change the distribution

00:31:10.596 --> 00:31:12.216 A:middle
of color intensities
in your image.

00:31:12.446 --> 00:31:15.076 A:middle
The equalization filter
is a special case.

00:31:15.536 --> 00:31:16.946 A:middle
It changes the distribution

00:31:17.396 --> 00:31:20.016 A:middle
from the current
distribution to the uniform one.

00:31:20.736 --> 00:31:23.046 A:middle
And the specification
filter enables you

00:31:23.046 --> 00:31:24.866 A:middle
to set any distribution
of your choice.

00:31:25.216 --> 00:31:27.606 A:middle
You specify the histogram that
will be used in the filter.

00:31:30.576 --> 00:31:34.386 A:middle
This is an example of
the equalization filter.

00:31:34.936 --> 00:31:40.186 A:middle
It increases the global
contrast in the image.

00:31:40.366 --> 00:31:43.216 A:middle
Here it brings out the rainbow
in the sky quite beautifully.

00:31:43.956 --> 00:31:45.446 A:middle
One thing I'd like to mention

00:31:45.846 --> 00:31:48.606 A:middle
about these filters is they
are not an end in themselves.

00:31:49.496 --> 00:31:51.606 A:middle
They can be used as
an intermediate step

00:31:52.026 --> 00:31:53.476 A:middle
in a more complex algorithm.

00:31:53.826 --> 00:31:57.336 A:middle
The histogram filter can be
used as an intermediate step

00:31:57.336 --> 00:31:58.636 A:middle
in implementing tune mapping,

00:31:58.966 --> 00:32:01.646 A:middle
which is a technique commonly
used by graphics developers



00:31:58.966 --> 00:32:01.646 A:middle
which is a technique commonly
used by graphics developers

00:32:02.096 --> 00:32:05.076 A:middle
to approximate the appearance
of high dynamic range.

00:32:05.676 --> 00:32:09.756 A:middle
So moving on, we also
support Lancos resampling.

00:32:10.226 --> 00:32:13.456 A:middle
It's a high-quality resampling
algorithm that can used

00:32:13.576 --> 00:32:16.476 A:middle
to downscale, upscale,
squeeze, and stretch images.

00:32:16.476 --> 00:32:21.906 A:middle
In this example, I
stretched the image vertically

00:32:22.086 --> 00:32:24.566 A:middle
and squeezed it horizontally
while preserving all

00:32:24.566 --> 00:32:25.506 A:middle
of the image content.

00:32:27.396 --> 00:32:29.566 A:middle
You also support the
thresholding filter.

00:32:30.156 --> 00:32:31.956 A:middle
It can be used to
find image edges

00:32:32.076 --> 00:32:33.486 A:middle
if chained with a Sobel filter.

00:32:34.746 --> 00:32:36.296 A:middle
Let's take a look at an example.

00:32:36.776 --> 00:32:39.776 A:middle
This is the output of
the thresholding filter,

00:32:39.776 --> 00:32:44.926 A:middle
and now it's fed into the Sobel
filter to give you image edges.

00:32:46.626 --> 00:32:49.666 A:middle
And finally we support
a whole range

00:32:49.666 --> 00:32:52.616 A:middle
of convolution kernels
including general convolution,

00:32:52.616 --> 00:32:55.296 A:middle
where you can specify your
own convolution matrix.

00:32:55.356 --> 00:32:57.716 A:middle
And we also support
Gaussian blur,

00:32:57.936 --> 00:32:59.696 A:middle
box tent, and Sobel filters.



00:33:00.196 --> 00:33:03.136 A:middle
My final example will
be of a Gaussian blur.

00:33:03.766 --> 00:33:05.326 A:middle
You should all be
very familiar with it;

00:33:05.706 --> 00:33:07.076 A:middle
we like to use it in our UI.

00:33:07.806 --> 00:33:09.936 A:middle
What if you wanted to
use a Gaussian blur

00:33:09.936 --> 00:33:11.426 A:middle
in your own application,

00:33:12.366 --> 00:33:15.396 A:middle
the Metal performance shaders
framework makes it very easy.

00:33:16.736 --> 00:33:17.616 A:middle
How easy, you ask?

00:33:18.716 --> 00:33:20.186 A:middle
I'm building some
anticipation here.

00:33:20.666 --> 00:33:23.206 A:middle
It's just two lines of code.

00:33:23.536 --> 00:33:28.466 A:middle
You first have to create a blur
filter object, and then you have

00:33:28.466 --> 00:33:33.356 A:middle
to encode the filter
to the command buffer.

00:33:33.986 --> 00:33:35.796 A:middle
And that's it [applause].

00:33:37.466 --> 00:33:38.226 A:middle
Thank you, guys.

00:33:40.906 --> 00:33:43.716 A:middle
And one thing I just wanted to
point out again and just note is

00:33:43.716 --> 00:33:47.536 A:middle
that this API takes your common
Metal resources as input.

00:33:48.146 --> 00:33:50.036 A:middle
Your device, your command
buffer, your textures.

00:33:51.096 --> 00:33:53.496 A:middle
These are the Metal resources

00:33:53.496 --> 00:33:55.176 A:middle
that you already create
in your application.

00:33:55.736 --> 00:33:59.116 A:middle
And now that I have shown
you these two lines of code,

00:33:59.536 --> 00:34:01.816 A:middle
let's take a look
at where they plug



00:33:59.536 --> 00:34:01.816 A:middle
let's take a look
at where they plug

00:34:01.816 --> 00:34:03.926 A:middle
in into your current
Metal work flow.

00:34:04.436 --> 00:34:06.336 A:middle
So this is a graphical
representation

00:34:06.336 --> 00:34:07.086 A:middle
of your command buffer.

00:34:08.436 --> 00:34:10.686 A:middle
It contains all of the
commands you are going

00:34:10.686 --> 00:34:11.866 A:middle
to be submitting to the device.

00:34:12.716 --> 00:34:14.755 A:middle
You do your work as
you usually would.

00:34:15.056 --> 00:34:17.025 A:middle
You render your scene
by issuing draw calls

00:34:18.326 --> 00:34:21.206 A:middle
and you do your post processing
effect by dispatching kernels.

00:34:21.545 --> 00:34:23.536 A:middle
Now you have decided that one

00:34:23.536 --> 00:34:26.136 A:middle
of your post processing effects
is going to be a blur filter.

00:34:26.976 --> 00:34:29.576 A:middle
So this is exactly
where it goes.

00:34:30.346 --> 00:34:34.315 A:middle
And don't forget that you still
have to submit your commands

00:34:34.315 --> 00:34:36.396 A:middle
to the device as
you normally would.

00:34:36.396 --> 00:34:37.356 A:middle
Nothing changes here.

00:34:38.106 --> 00:34:41.446 A:middle
And now, if you would like
to look at the sample code

00:34:41.446 --> 00:34:43.466 A:middle
for the example I was
just going through,

00:34:43.466 --> 00:34:44.485 A:middle
you could do so right now.

00:34:44.485 --> 00:34:46.295 A:middle
You can go to
developer.Apple.com

00:34:46.585 --> 00:34:49.275 A:middle
and download the example called
Metal performance shaders

00:34:49.356 --> 00:34:49.926 A:middle
hello world.

00:34:51.315 --> 00:34:54.626 A:middle
I've mentioned before that
the Metal performance shaders

00:34:54.626 --> 00:34:57.566 A:middle
framework has two goals,
performance and ease of use.

00:34:57.666 --> 00:35:00.206 A:middle
I just showed you how
easy it is to use.



00:34:57.666 --> 00:35:00.206 A:middle
I just showed you how
easy it is to use.

00:35:01.116 --> 00:35:03.056 A:middle
Let's take a quick
look behind the scenes

00:35:03.556 --> 00:35:05.416 A:middle
at what's giving you
this performance.

00:35:07.676 --> 00:35:10.606 A:middle
For every one of these filters
including the Gaussian blur

00:35:10.606 --> 00:35:13.656 A:middle
filter, we had to choose
the right algorithm.

00:35:14.106 --> 00:35:18.676 A:middle
The right here means correct
and it has to be the fastest.

00:35:19.346 --> 00:35:24.606 A:middle
The fastest for a particular
combination of input data,

00:35:24.836 --> 00:35:27.366 A:middle
input parameters,
and device GPU.

00:35:28.276 --> 00:35:30.286 A:middle
What do I mean by this?

00:35:30.366 --> 00:35:32.686 A:middle
There are multiple ways to
implement Gaussian blur.

00:35:32.686 --> 00:35:36.346 A:middle
There are constant
cost, log 2, linear,

00:35:36.346 --> 00:35:37.736 A:middle
and brute force algorithms.

00:35:39.276 --> 00:35:40.906 A:middle
All of these approaches
have different start

00:35:40.906 --> 00:35:42.296 A:middle
up costs and overheads.

00:35:42.666 --> 00:35:45.636 A:middle
One approach may work really
well for a small kernel radius

00:35:45.976 --> 00:35:48.806 A:middle
but perform very poorly
on a large kernel radius.

00:35:49.976 --> 00:35:54.326 A:middle
The point is we had to implement
each one of these approaches

00:35:54.406 --> 00:35:57.126 A:middle
and find out experimentally
which one is going

00:35:57.126 --> 00:35:59.536 A:middle
to be the fastest for a
particular combination

00:35:59.536 --> 00:36:03.956 A:middle
of input problem, input
parameters, and device GPU.



00:35:59.536 --> 00:36:03.956 A:middle
of input problem, input
parameters, and device GPU.

00:36:03.956 --> 00:36:09.076 A:middle
And after this process, all
of the kernels had to be tuned

00:36:09.076 --> 00:36:11.266 A:middle
for such parameters
as your kernel radius,

00:36:12.436 --> 00:36:13.456 A:middle
your pixel format,

00:36:14.416 --> 00:36:16.936 A:middle
your underlying hardware
architecture's memory hierarchy,

00:36:17.326 --> 00:36:19.776 A:middle
and such parameters as
number of pixels per thread

00:36:19.776 --> 00:36:20.846 A:middle
and thread group dimensions.

00:36:21.206 --> 00:36:23.636 A:middle
This is what determines how to
split up your work in parallel.

00:36:23.636 --> 00:36:26.476 A:middle
And finally, I would
like to mention

00:36:27.196 --> 00:36:30.626 A:middle
that the framework also performs
CPU optimizations for you.

00:36:31.176 --> 00:36:35.016 A:middle
It optimizes program
loading speed.

00:36:36.266 --> 00:36:40.546 A:middle
It also reuses intermediate
textures,

00:36:41.206 --> 00:36:45.096 A:middle
and finally it does some compute
encoder optimization for you.

00:36:45.146 --> 00:36:47.256 A:middle
Specifically, it can defect

00:36:47.646 --> 00:36:51.106 A:middle
if you are using multiple
computing coders in a row and if

00:36:51.106 --> 00:36:52.416 A:middle
so it will coalesce them.

00:36:53.116 --> 00:36:58.896 A:middle
And after we have done all
of these steps for you,

00:36:58.896 --> 00:37:01.076 A:middle
that's cool, but what would
this actually look like in terms



00:36:58.896 --> 00:37:01.076 A:middle
that's cool, but what would
this actually look like in terms

00:37:01.076 --> 00:37:03.776 A:middle
of code, for example, for an
optimized Gaussian blur shader

00:37:03.776 --> 00:37:04.736 A:middle
that I just showed you?

00:37:07.436 --> 00:37:08.656 A:middle
Well, are you ready for it?

00:37:09.686 --> 00:37:11.926 A:middle
Here is the code.

00:37:12.436 --> 00:37:13.606 A:middle
So now all of you know how

00:37:13.606 --> 00:37:15.726 A:middle
to implement your own
optimized Gaussian blur, right?

00:37:16.196 --> 00:37:17.396 A:middle
I bet you didn't
know you were going

00:37:17.396 --> 00:37:19.046 A:middle
to learn this in this session.

00:37:19.826 --> 00:37:23.016 A:middle
Basically all joking aside,
this is 49 Metal kernels,

00:37:23.066 --> 00:37:25.066 A:middle
2,000 lines of kernel code

00:37:25.296 --> 00:37:29.756 A:middle
and 821 different Metal
Gaussian blur implementations

00:37:30.576 --> 00:37:33.706 A:middle
where each implementation
is some combination

00:37:33.706 --> 00:37:37.426 A:middle
of these 49 Metal kernels, so it
looks like a lot of work we did

00:37:37.686 --> 00:37:39.566 A:middle
and now you don't have to.

00:37:39.566 --> 00:37:40.946 A:middle
Now, let's take a look

00:37:40.946 --> 00:37:50.216 A:middle
at the Metal performance
shaders framework in action.

00:37:50.316 --> 00:37:53.286 A:middle
So first, I will
demonstrate the performance

00:37:53.366 --> 00:37:58.556 A:middle
of a simple textbook separable
Gaussian blur implementation

00:37:59.466 --> 00:38:01.486 A:middle
that took only minutes
to write in Metal.



00:37:59.466 --> 00:38:01.486 A:middle
that took only minutes
to write in Metal.

00:38:01.656 --> 00:38:04.026 A:middle
This is probably something you
would start with if you had

00:38:04.026 --> 00:38:05.646 A:middle
to implement your own blur

00:38:05.646 --> 00:38:07.806 A:middle
and you didn't have Metal
performance shaders available

00:38:07.806 --> 00:38:08.086 A:middle
to you.

00:38:08.456 --> 00:38:11.336 A:middle
So now we are happily running
at 60 frames per second

00:38:11.336 --> 00:38:12.996 A:middle
but we are not actually
doing any work yet.

00:38:13.996 --> 00:38:15.186 A:middle
The sigma value is 0.

00:38:15.606 --> 00:38:19.466 A:middle
Let's change the sigma value
to 6 and we are down to

00:38:19.466 --> 00:38:21.146 A:middle
about 8 frames per second.

00:38:21.956 --> 00:38:23.046 A:middle
Dare we go any further?

00:38:23.376 --> 00:38:24.736 A:middle
Let's try a sigma of 20.

00:38:25.396 --> 00:38:30.896 A:middle
Okay. And we are down
to 3 frames per second

00:38:30.896 --> 00:38:32.176 A:middle
so that's not going to work.

00:38:33.006 --> 00:38:34.806 A:middle
Let's switch to the
Metal performance

00:38:34.806 --> 00:38:35.956 A:middle
shaders implementation.

00:38:36.566 --> 00:38:39.946 A:middle
So now we are back to
60 frames per second,

00:38:39.946 --> 00:38:42.626 A:middle
not doing any work, sigma of 6.

00:38:43.416 --> 00:38:44.846 A:middle
Still 60 frames per second.

00:38:45.576 --> 00:38:46.556 A:middle
Sigma of 20.

00:38:47.136 --> 00:38:48.586 A:middle
Still 60 frames per second.

00:38:49.876 --> 00:38:53.366 A:middle
And, of course, we had to go
further and really blur it,

00:38:53.706 --> 00:38:55.226 A:middle
still at 60 frames per second.

00:38:55.226 --> 00:38:56.486 A:middle
So this looks like a winner.



00:39:02.516 --> 00:39:12.026 A:middle
[ Applause ]

00:39:12.526 --> 00:39:12.656 A:middle
Okay.

00:39:13.046 --> 00:39:15.336 A:middle
So your screen refresh
rate is 60 hertz.

00:39:17.096 --> 00:39:21.056 A:middle
This means that we are running
at 60 frames we are second,

00:39:21.056 --> 00:39:24.956 A:middle
so the performance of this
optimized Gaussian blur shader

00:39:24.956 --> 00:39:28.326 A:middle
you have seen in the demo is
capped at 60 frames per second.

00:39:28.966 --> 00:39:33.786 A:middle
This means that you have 16.6
milliseconds to draw your frame,

00:39:33.786 --> 00:39:36.566 A:middle
and this also includes
any compositing work

00:39:36.596 --> 00:39:39.306 A:middle
that your system
might need to do.

00:39:39.806 --> 00:39:43.066 A:middle
This chart shows you
the execution time

00:39:43.646 --> 00:39:46.616 A:middle
of this optimized Gaussian blur
filter for different values

00:39:46.616 --> 00:39:51.096 A:middle
of sigma and as you can see,
the execution time is a lot less

00:39:51.246 --> 00:39:52.756 A:middle
than 16.6 milliseconds.

00:39:53.436 --> 00:39:56.416 A:middle
So this means that you
still have some extra time

00:39:56.416 --> 00:39:57.976 A:middle
to do additional GPU work,

00:39:59.496 --> 00:40:02.766 A:middle
and still hit the desired
60 frames per second.



00:39:59.496 --> 00:40:02.766 A:middle
and still hit the desired
60 frames per second.

00:40:03.416 --> 00:40:07.036 A:middle
And now there are just a
few more details I would

00:40:07.036 --> 00:40:07.596 A:middle
like to cover.

00:40:08.966 --> 00:40:12.266 A:middle
Sometimes you will need to
work on very large images

00:40:12.266 --> 00:40:13.376 A:middle
and you will need to tile them.

00:40:14.546 --> 00:40:16.036 A:middle
And sometimes you
will just need to work

00:40:16.036 --> 00:40:17.186 A:middle
on a portion of your image.

00:40:17.186 --> 00:40:18.976 A:middle
So there is a mechanism
for that.

00:40:19.486 --> 00:40:22.616 A:middle
It's called source offset
and destination clip Rect.

00:40:23.106 --> 00:40:25.616 A:middle
Clip rect has an
origin and size.

00:40:26.206 --> 00:40:28.866 A:middle
It determines the region
of the destination texture,

00:40:28.866 --> 00:40:32.416 A:middle
which is going to be
updated by a filter.

00:40:32.416 --> 00:40:34.346 A:middle
The source offset
only has an origin.

00:40:35.136 --> 00:40:37.356 A:middle
The size is implicit, it's
determined by the clip rect,

00:40:37.356 --> 00:40:40.066 A:middle
and it is just an offset
from the upper left corner

00:40:40.066 --> 00:40:41.436 A:middle
of your source texture.

00:40:42.316 --> 00:40:45.366 A:middle
They work together to
give you the final image.

00:40:45.916 --> 00:40:50.716 A:middle
In the Metal performance
shaders framework your source

00:40:50.716 --> 00:40:53.646 A:middle
and destination can be
one in the same texture.

00:40:54.096 --> 00:40:56.066 A:middle
In this case, the clip rect

00:40:56.896 --> 00:40:59.546 A:middle
and source offset work
exactly the same way.



00:41:00.126 --> 00:41:06.246 A:middle
When the source and destination
are the same texture,

00:41:06.406 --> 00:41:08.246 A:middle
we call it an in
place operation.

00:41:08.836 --> 00:41:09.846 A:middle
Use it to save memory.

00:41:09.846 --> 00:41:12.386 A:middle
How could you do you
actually encode one

00:41:12.386 --> 00:41:13.466 A:middle
of these filters in place?

00:41:14.836 --> 00:41:17.936 A:middle
You have to use the encode to
command buffer method that takes

00:41:17.936 --> 00:41:20.606 A:middle
in place texture and a fall
by back copy allocator.

00:41:22.376 --> 00:41:25.346 A:middle
One thing to keep in mind
here, it's not always possible

00:41:25.346 --> 00:41:26.716 A:middle
for the shaders to run in place.

00:41:27.076 --> 00:41:28.596 A:middle
It depends on your filter,

00:41:28.996 --> 00:41:30.506 A:middle
on the filter parameters
and properties.

00:41:31.106 --> 00:41:32.806 A:middle
If you want this operation

00:41:32.806 --> 00:41:35.486 A:middle
to always succeed,
use a copy allocator.

00:41:35.726 --> 00:41:40.086 A:middle
It will be called automatically,
only in the situation where the

00:41:40.086 --> 00:41:41.646 A:middle
in place operation
is not possible.

00:41:42.046 --> 00:41:44.866 A:middle
And we will create a new
destination texture for you

00:41:46.216 --> 00:41:47.736 A:middle
so that the operation
can proceed

00:41:47.736 --> 00:41:49.286 A:middle
out of place if necessary.

00:41:50.206 --> 00:41:54.206 A:middle
And here is an example of a
simple fall back copy allocator.

00:41:55.826 --> 00:41:58.946 A:middle
This one simply creates
a new destination texture

00:41:59.726 --> 00:42:02.886 A:middle
with the same pixel
format and dimensions



00:41:59.726 --> 00:42:02.886 A:middle
with the same pixel
format and dimensions

00:42:02.886 --> 00:42:04.626 A:middle
as the source texture,
very simple.

00:42:05.326 --> 00:42:08.016 A:middle
So now I have shown you
an example before of an

00:42:08.016 --> 00:42:10.796 A:middle
in place operation where
you only modified a portion

00:42:10.796 --> 00:42:13.976 A:middle
of your destination texture
and everything outside

00:42:13.976 --> 00:42:15.866 A:middle
of the clip rect
remained unchanged.

00:42:16.226 --> 00:42:18.366 A:middle
You can also do this
in the copy allocator.

00:42:19.346 --> 00:42:22.596 A:middle
Just initialize your destination
texture with the contexts

00:42:22.596 --> 00:42:23.536 A:middle
of your source texture.

00:42:24.136 --> 00:42:28.696 A:middle
And I would also like
to mention that all

00:42:28.696 --> 00:42:31.176 A:middle
of the usual Metal
resources such as your device

00:42:31.176 --> 00:42:33.316 A:middle
and your command buffer
are available to you

00:42:33.316 --> 00:42:34.286 A:middle
in the copy allocator.

00:42:34.796 --> 00:42:36.916 A:middle
Now that I have covered
these details,

00:42:37.166 --> 00:42:38.286 A:middle
let's jump into the summary.

00:42:38.846 --> 00:42:43.296 A:middle
I would like to say please use
the Metal support frameworks,

00:42:43.416 --> 00:42:46.416 A:middle
MetalKit and Metal performance
shaders, they are robust,

00:42:46.606 --> 00:42:49.716 A:middle
they are optimized, and as I
have shown you, they're easy

00:42:49.716 --> 00:42:51.486 A:middle
to integrate into your
Metal applications.

00:42:52.026 --> 00:42:54.586 A:middle
They will allow for faster bring
up time of your applications.

00:42:54.906 --> 00:42:56.216 A:middle
Now, you can spend the time

00:42:56.216 --> 00:42:58.316 A:middle
on making application
unique instead

00:42:58.316 --> 00:43:00.626 A:middle
of implementing common tasks.



00:42:58.316 --> 00:43:00.626 A:middle
of implementing common tasks.

00:43:00.626 --> 00:43:03.566 A:middle
And, of course, as an added
benefit, there is less code

00:43:03.566 --> 00:43:04.956 A:middle
for you to write and maintain.

00:43:05.736 --> 00:43:07.746 A:middle
And come to our labs,
give us feedback.

00:43:07.856 --> 00:43:10.366 A:middle
Let us know how to get
started or give us questions.

00:43:10.836 --> 00:43:14.106 A:middle
Let us know if there are new
utilities or shaders you would

00:43:14.106 --> 00:43:15.856 A:middle
like to see added to
the support frameworks.

00:43:16.466 --> 00:43:19.686 A:middle
You can always find
more information online.

00:43:19.786 --> 00:43:22.886 A:middle
We have documentation videos
available, and take advantage

00:43:22.886 --> 00:43:25.216 A:middle
of the Apple Developer
Forums and technical support.

00:43:25.496 --> 00:43:28.416 A:middle
For general inquiries,
contact our gaming technologies

00:43:28.416 --> 00:43:29.706 A:middle
evangelist Allan Schaffer.

00:43:31.926 --> 00:43:35.726 A:middle
You can watch the past sessions
online, but if you would

00:43:35.726 --> 00:43:38.236 A:middle
like to learn new Metal
performance optimization

00:43:38.236 --> 00:43:40.576 A:middle
techniques, come to
our talk tomorrow

00:43:40.576 --> 00:43:42.956 A:middle
at 11:00 a.m. Thank you.

00:43:44.516 --> 00:43:58.360 A:middle
[ Applause ]

