1
00:00:20,016 --> 00:00:21,046
[ Applause ]


2
00:00:21,046 --> 00:00:24,206
>> DOUG GREGOR: Thank you.


3
00:00:24,206 --> 00:00:26,056
Hello. I'm Doug Gregor.


4
00:00:26,266 --> 00:00:29,366
I'm here with my colleague
Bill Dudney, and we will talk


5
00:00:29,366 --> 00:00:32,366
about building better apps
with value types in Swift.


6
00:00:32,665 --> 00:00:37,696
First, we are going
to start off talking


7
00:00:37,696 --> 00:00:41,256
about reference semantics,
and then we will delve


8
00:00:41,316 --> 00:00:44,726
through immutability as a
solution to some of the problems


9
00:00:44,726 --> 00:00:46,376
that reference semantics pose.


10
00:00:48,036 --> 00:00:51,236
Dive into value semantics and
value types, how it works,


11
00:00:51,236 --> 00:00:54,226
especially how it works
in Swift, and then talk


12
00:00:54,226 --> 00:00:56,856
about using value types in
practice and then the mixing


13
00:00:56,856 --> 00:01:00,116
of reference types and value
types together within Swift.


14
00:01:01,086 --> 00:01:03,916
Let's get started.


15
00:01:04,025 --> 00:01:05,075
Reference semantics.


16
00:01:05,676 --> 00:01:07,366
So the way into reference
semantics


17
00:01:07,366 --> 00:01:10,086
in the Swift world
is to define a class.


18
00:01:11,396 --> 00:01:13,196
Here's a very simple
temperature class.


19
00:01:13,796 --> 00:01:16,436
We are storing our
temperature value in Celsius.


20
00:01:16,716 --> 00:01:19,206
We want to have this nice
computed Fahrenheit property


21
00:01:19,206 --> 00:01:22,576
so we can always get to
it with the correct unit.


22
00:01:23,646 --> 00:01:25,696
Simple, abstracted
version of a temperature.


23
00:01:26,316 --> 00:01:28,056
Let's try to use it
in some simple code.


24
00:01:28,746 --> 00:01:31,886
We create a home instance, we
create a temperature instance.


25
00:01:32,236 --> 00:01:35,506
We set our thermostat to a
balmy 75 degrees Fahrenheit.


26
00:01:36,886 --> 00:01:39,466
Now we decide, oh, it's
getting close to dinnertime


27
00:01:39,466 --> 00:01:40,626
and I want to bake some salmon.


28
00:01:40,976 --> 00:01:44,146
So I set my oven to 425
degrees and hit Bake.


29
00:01:44,876 --> 00:01:45,456
Walk away.


30
00:01:45,546 --> 00:01:49,636
Why is it so hot in here?


31
00:01:49,796 --> 00:01:50,416
What's going on?


32
00:01:51,866 --> 00:01:52,676
You know what happened.


33
00:01:52,736 --> 00:01:55,076
We hit this case of
unintended sharing.


34
00:01:55,456 --> 00:01:56,466
Think of the object graph.


35
00:01:57,966 --> 00:01:58,966
We have our house.


36
00:01:59,056 --> 00:02:00,806
It has a thermostat and an oven.


37
00:02:01,166 --> 00:02:03,686
We have this temperature
object that temp points to.


38
00:02:04,526 --> 00:02:06,076
When we set our thermostat,


39
00:02:06,536 --> 00:02:08,436
we wired it to the same
object as the temp.


40
00:02:09,166 --> 00:02:12,476
Things look like fine until
we go ahead and do a mutation,


41
00:02:12,806 --> 00:02:14,186
and now this unintended


42
00:02:14,186 --> 00:02:18,186
or unexpected sharing just
caused us to set our thermostat


43
00:02:18,226 --> 00:02:20,216
to 425 degrees Fahrenheit.


44
00:02:21,496 --> 00:02:23,176
At this point it was
already game over,


45
00:02:23,176 --> 00:02:26,616
but just for good measure let's
wire our thermostat to our oven


46
00:02:26,616 --> 00:02:27,736
because we've lost already.


47
00:02:27,776 --> 00:02:32,556
So what did we do wrong?


48
00:02:32,556 --> 00:02:34,966
In this world where you
have reference semantics,


49
00:02:35,656 --> 00:02:38,456
you want to prevent sharing,
and so you do copies.


50
00:02:40,066 --> 00:02:41,786
Okay? Let's do this
the right way.


51
00:02:42,696 --> 00:02:45,356
Okay. I'm going to
set my temperature


52
00:02:45,356 --> 00:02:47,196
to 75 degrees Fahrenheit again.


53
00:02:47,806 --> 00:02:51,816
When I set the temperature of my
thermostat, I will cause a copy.


54
00:02:52,146 --> 00:02:53,646
So I get a brand new object.


55
00:02:53,906 --> 00:02:56,046
That's what my thermostat's
temperature points to.


56
00:02:56,716 --> 00:02:58,686
When I go ahead and
change the temperature


57
00:02:58,686 --> 00:03:00,626
of my temp variable,
it doesn't affect it.


58
00:03:00,896 --> 00:03:01,256
That's good.


59
00:03:02,156 --> 00:03:03,926
Now I go and set the
oven's temperature,


60
00:03:04,156 --> 00:03:05,326
I will make another copy.


61
00:03:06,496 --> 00:03:09,596
Now, technically, I don't
need this last copy.


62
00:03:10,216 --> 00:03:13,666
It's inefficient to go
waste time allocating memory


63
00:03:13,666 --> 00:03:15,556
on the heap to create
this extra copy.


64
00:03:16,286 --> 00:03:18,656
But I'm going to be safe because
the last time I missed a copy,


65
00:03:18,986 --> 00:03:19,826
I got burned [groaning]!


66
00:03:22,166 --> 00:03:24,216
Come on, it's a Friday
session, give me a break!


67
00:03:25,516 --> 00:03:29,696
[ Applause ]


68
00:03:30,196 --> 00:03:35,716
So we refer to this as defensive
copying, where we copy not


69
00:03:35,716 --> 00:03:38,656
because we know we need it,
but because if we do happen


70
00:03:38,656 --> 00:03:41,986
to need it now or sometime
down the road, it's really hard


71
00:03:41,986 --> 00:03:43,406
to debug these problems.


72
00:03:43,866 --> 00:03:46,236
And so it's way too easy


73
00:03:46,236 --> 00:03:49,286
to forget a dot copy any time we
assigned a temperature somewhere


74
00:03:49,286 --> 00:03:49,866
in our oven.


75
00:03:50,216 --> 00:03:52,866
So instead, I will bake
this behavior right


76
00:03:53,606 --> 00:03:55,976
into my oven [laughter].


77
00:03:56,146 --> 00:03:56,926
All right, I'm done.


78
00:03:56,926 --> 00:03:57,836
I'm done. I'm sorry.


79
00:03:58,006 --> 00:03:58,486
I'm sorry [applause].


80
00:03:59,486 --> 00:04:01,516
Naturally I have to do
this exact same thing


81
00:04:01,516 --> 00:04:02,936
for the thermostat, all right?


82
00:04:02,936 --> 00:04:05,066
So now we've got a whole bunch
of boilerplate we are copying


83
00:04:05,066 --> 00:04:07,256
and pasting, and sooner or
later, you will be knocking


84
00:04:07,256 --> 00:04:09,126
on my door asking for a
language feature here.


85
00:04:09,846 --> 00:04:14,206
Hold off on that, and let's
talk about where we see copying


86
00:04:14,206 --> 00:04:15,646
in Cocoa and Objective-C.


87
00:04:16,666 --> 00:04:18,486
So in Cocoa, you
have this notion


88
00:04:18,486 --> 00:04:19,836
of the NSCopying protocol.


89
00:04:20,315 --> 00:04:22,866
And this codifies
what it means to copy,


90
00:04:23,506 --> 00:04:26,386
and you have a whole lot of
data types and this NSstring,


91
00:04:26,446 --> 00:04:28,796
NSArray, NSURLRequest, etcetera.


92
00:04:29,056 --> 00:04:31,906
These things conform to
NSCopying because you have


93
00:04:31,956 --> 00:04:33,226
to copy them to be safe.


94
00:04:33,616 --> 00:04:37,896
We are in a system that needs
copying, and so you see a lot


95
00:04:37,896 --> 00:04:40,676
of defensive copying for
very, very good reasons.


96
00:04:40,716 --> 00:04:44,756
So NSDictionary will defensively
copy the keys you place


97
00:04:44,756 --> 00:04:45,506
in the dictionary.


98
00:04:46,366 --> 00:04:49,966
Why? Well, if you were to hand
NSDictionary a key to insert it


99
00:04:50,246 --> 00:04:53,736
and then go change it in a way
that, say, alters the hash value


100
00:04:53,736 --> 00:04:55,996
of it, you will break
all the internal variance


101
00:04:55,996 --> 00:04:58,396
of NSDictionary and
blame us for your bugs.


102
00:04:58,396 --> 00:04:59,596
We don't really want that.


103
00:05:00,216 --> 00:05:02,846
What we really do is
we do defensive copying


104
00:05:02,846 --> 00:05:03,566
in NSDictionary.


105
00:05:03,566 --> 00:05:06,626
That's the right answer in this
system, but it's unfortunate


106
00:05:06,666 --> 00:05:09,166
that we are losing performance


107
00:05:09,166 --> 00:05:10,616
because we are doing
these extra copies.


108
00:05:11,736 --> 00:05:14,346
Of course, we moved this all
the way down into the level


109
00:05:14,346 --> 00:05:17,146
of the language with copy
properties in Objective-C


110
00:05:17,456 --> 00:05:20,746
that do defensive copying on
every single assignment to try


111
00:05:20,746 --> 00:05:23,176
to prevent these
problems, and it helps,


112
00:05:23,176 --> 00:05:25,106
all this defensive
copying helps,


113
00:05:25,186 --> 00:05:26,546
but it's never good enough.


114
00:05:26,846 --> 00:05:28,226
You still have a ton of bugs.


115
00:05:29,036 --> 00:05:32,086
So we have problems with
those reference semantics


116
00:05:32,136 --> 00:05:33,106
and there's mutation.


117
00:05:34,356 --> 00:05:36,716
Maybe the problem here is
not the reference semantics


118
00:05:36,936 --> 00:05:38,166
but the mutation itself.


119
00:05:38,496 --> 00:05:40,066
Perhaps we should
move to a world


120
00:05:40,066 --> 00:05:43,306
of immutable data structures
with reference semantics.


121
00:05:44,006 --> 00:05:45,126
If you go talk to someone


122
00:05:45,126 --> 00:05:48,546
in the functional programming
community, they will say, yeah,


123
00:05:48,736 --> 00:05:50,246
we have been doing
this for decades!


124
00:05:51,066 --> 00:05:52,926
And it does improve
things there.


125
00:05:53,316 --> 00:05:56,386
So you can't have unintended
side effects in a world


126
00:05:56,386 --> 00:05:58,826
where there are no side effects,


127
00:05:58,896 --> 00:06:01,646
and so immutable reference
semantics are a consistent way


128
00:06:01,826 --> 00:06:02,766
to work in the system.


129
00:06:02,916 --> 00:06:06,666
It doesn't have these unintended
consequences, which we ran


130
00:06:06,666 --> 00:06:08,306
into in our little
temperature example.


131
00:06:09,296 --> 00:06:13,296
The problem is that immutability
has some disadvantages.


132
00:06:13,756 --> 00:06:15,856
It can lead to some
awkward interfaces,


133
00:06:16,306 --> 00:06:19,166
and part of this is just
the way the languages work,


134
00:06:19,616 --> 00:06:22,506
and part of this is that we're
used to living in a world


135
00:06:22,506 --> 00:06:25,376
where we can mutate things,
and we think about state


136
00:06:25,376 --> 00:06:27,646
and mutating state,
and so thinking


137
00:06:27,646 --> 00:06:29,996
in purely a immutable world
can be a little bit weird


138
00:06:29,996 --> 00:06:30,936
for us at times.


139
00:06:31,826 --> 00:06:33,776
There's also the question
of an efficient mapping


140
00:06:33,776 --> 00:06:35,016
down to the machine model.


141
00:06:35,816 --> 00:06:37,766
Eventually, you have to
get down to machine code,


142
00:06:37,766 --> 00:06:40,516
and you are running on a CPU
that has stateful registers,


143
00:06:40,516 --> 00:06:41,446
and stateful caches,


144
00:06:41,446 --> 00:06:43,326
and stateful memory,
and stateful storage.


145
00:06:44,356 --> 00:06:48,416
It's not always easy to map
an immutable algorithm down to


146
00:06:48,416 --> 00:06:49,796
that level efficiently.


147
00:06:50,486 --> 00:06:51,656
Let's talk through
a couple of these.


148
00:06:52,166 --> 00:06:54,756
We will take this temperature
class of ours and try


149
00:06:54,756 --> 00:06:56,586
to make it safer by
making it immutable.


150
00:06:57,386 --> 00:07:00,436
So, all we had to do here was
change the stored property


151
00:07:00,436 --> 00:07:03,286
Celsius from a var to a let,
and now you can't change it.


152
00:07:03,916 --> 00:07:07,006
And then the Fahrenheit computer
property loses its setter.


153
00:07:07,156 --> 00:07:08,296
So you can't change the state


154
00:07:08,296 --> 00:07:09,646
of temperature no
matter what you do.


155
00:07:09,966 --> 00:07:11,846
We add some initializers
for convenience.


156
00:07:12,146 --> 00:07:15,706
Okay. Let's talk
about awkwarding.


157
00:07:16,646 --> 00:07:18,066
Awkward immutable interfaces.


158
00:07:18,466 --> 00:07:22,586
Before, if I wanted to, say,
tweak the temperature of my oven


159
00:07:22,586 --> 00:07:25,356
by 10 degrees Fahrenheit,
this was a simple operation.


160
00:07:26,306 --> 00:07:27,006
Plus equals 10.


161
00:07:27,186 --> 00:07:27,856
That does it.


162
00:07:27,856 --> 00:07:28,216
That's it.


163
00:07:29,416 --> 00:07:31,876
How would we do this if we
have taken away mutation?


164
00:07:32,206 --> 00:07:35,016
Well, we have to go and grab the
temperature object in the oven,


165
00:07:35,656 --> 00:07:39,206
create yet another temperature
object that has the new value.


166
00:07:39,206 --> 00:07:40,856
All right?


167
00:07:41,106 --> 00:07:42,296
So it's a little
bit more awkward.


168
00:07:42,296 --> 00:07:46,686
There's more code, and we wasted
time allocating another object


169
00:07:46,686 --> 00:07:47,106
on the heap.


170
00:07:47,946 --> 00:07:50,476
But in truth, we have not
embraced immutability here


171
00:07:50,796 --> 00:07:54,336
because we did an assignment
that mutated the oven itself.


172
00:07:55,196 --> 00:07:57,096
If we were embracing the notion


173
00:07:57,096 --> 00:07:59,576
of immutable reference
types throughout here,


174
00:08:00,116 --> 00:08:02,366
we would be creating a new
temperature to put in a new oven


175
00:08:02,366 --> 00:08:03,536
to put in a new home [laughter].


176
00:08:05,716 --> 00:08:11,856
Awkward! So let's get a
little bit more theoretical


177
00:08:11,856 --> 00:08:12,346
and do some math.


178
00:08:13,286 --> 00:08:17,496
So the Sieve of Eratosthenes
is an ancient algorithm


179
00:08:17,496 --> 00:08:18,916
for computing prime numbers.


180
00:08:19,446 --> 00:08:22,106
It uses mutation and
actually lends itself well


181
00:08:22,106 --> 00:08:24,256
to drawing things out in
the dirt with a stick.


182
00:08:24,786 --> 00:08:29,246
So this is the implementation of
the mutating version in Swift.


183
00:08:29,246 --> 00:08:31,366
We are going to walk through it
so you get the idea behind it.


184
00:08:31,966 --> 00:08:33,546
First thing you do:
create an array.


185
00:08:34,696 --> 00:08:36,416
Notice the var because we are
going to mutate this array.


186
00:08:36,986 --> 00:08:40,716
Notice this array is from
two, first prime number,


187
00:08:41,006 --> 00:08:42,676
up through whatever
number you want to compute.


188
00:08:42,676 --> 00:08:43,535
We will do 20 here.


189
00:08:44,836 --> 00:08:47,806
Now, the outer loop,
each time through it,


190
00:08:47,806 --> 00:08:50,146
we will pick the next
number in the array.


191
00:08:51,006 --> 00:08:52,536
That number is a
prime number, P.


192
00:08:53,786 --> 00:08:56,546
What the inner loop is
going to do is walk over all


193
00:08:56,546 --> 00:09:01,666
of the multiples of P,
erasing them from the array


194
00:09:01,956 --> 00:09:02,856
by setting them to zero.


195
00:09:04,166 --> 00:09:05,276
Because, of course,
if you are a multiple


196
00:09:05,276 --> 00:09:06,446
of a prime number,
you are not prime.


197
00:09:07,516 --> 00:09:08,506
Back to the outer loop,


198
00:09:08,506 --> 00:09:11,016
we go and grab the next
number, it's a prime number.


199
00:09:11,276 --> 00:09:13,766
We erase all of its
multiples from the array.


200
00:09:13,766 --> 00:09:15,486
So it's a very, very
simple algorithm.


201
00:09:15,546 --> 00:09:16,686
Think of the stick in the dirt.


202
00:09:16,686 --> 00:09:18,486
You are just scratching
things out.


203
00:09:19,636 --> 00:09:21,136
Once we are done
going through all


204
00:09:21,136 --> 00:09:24,236
of our iterations,
we go down here.


205
00:09:24,456 --> 00:09:26,786
And we do the last simple
operation, which says,


206
00:09:27,106 --> 00:09:28,986
everything that we have not
zeroed out in the array,


207
00:09:28,986 --> 00:09:30,226
that's part of our result.


208
00:09:30,226 --> 00:09:32,736
So we will do that
with a filter.


209
00:09:32,846 --> 00:09:35,786
Simple algorithm,
entirely based on mutation.


210
00:09:36,306 --> 00:09:38,956
Now that doesn't mean
you can't express it


211
00:09:39,046 --> 00:09:40,356
in a world without mutation.


212
00:09:40,646 --> 00:09:42,186
You can. Of course.


213
00:09:42,986 --> 00:09:44,776
So to do that, we are
going to use Haskell,


214
00:09:44,776 --> 00:09:46,456
because it's a pure
functional language [applause].


215
00:09:48,256 --> 00:09:49,806
Yes, I knew people
would love it!


216
00:09:50,276 --> 00:09:50,586
All right.


217
00:09:51,586 --> 00:09:53,416
So this is the Haskell
formulation.


218
00:09:53,416 --> 00:09:55,986
It's -- if you read
Haskell, it's beautiful.


219
00:09:56,836 --> 00:09:57,546
It's functional.


220
00:09:57,546 --> 00:09:58,516
It doesn't mutate at all.


221
00:09:59,186 --> 00:10:01,106
Here's a very similar
implementation because it turns


222
00:10:01,106 --> 00:10:03,676
out Swift can do functional
also, and if you want


223
00:10:03,676 --> 00:10:05,666
to make it lazy, that's
an exercise to the reader


224
00:10:05,666 --> 00:10:06,796
but it's not that much harder.


225
00:10:07,556 --> 00:10:09,726
And we're going to walk through
how this algorithm works,


226
00:10:09,766 --> 00:10:11,516
because It's very, very similar.


227
00:10:12,036 --> 00:10:16,776
We start with our array
of numbers from 2 to 20.


228
00:10:17,356 --> 00:10:21,586
In the simple basis case,
if there's no numbers, well,


229
00:10:21,586 --> 00:10:22,636
there's no prime
numbers in there.


230
00:10:22,636 --> 00:10:24,046
So that's the first
If statement.


231
00:10:24,046 --> 00:10:24,636
It's trivial.


232
00:10:25,916 --> 00:10:28,676
Otherwise, what you do is we
take out the first number,


233
00:10:28,776 --> 00:10:30,206
that's always going to be prime.


234
00:10:30,896 --> 00:10:32,786
And separate it from
the remaining numbers.


235
00:10:33,196 --> 00:10:34,876
Right? Haskell did this
with pattern matching,


236
00:10:34,876 --> 00:10:35,796
and we can do slicing here.


237
00:10:36,786 --> 00:10:39,686
Then we take that prime number
and we run a filter operation


238
00:10:39,906 --> 00:10:44,186
over all of the elements
here in this remaining array.


239
00:10:45,166 --> 00:10:46,516
Copying only those things


240
00:10:46,516 --> 00:10:48,566
that aren't multiples
of that prime number.


241
00:10:49,936 --> 00:10:51,356
Now we recurse and do it again.


242
00:10:52,106 --> 00:10:54,136
Split out the three and this
is our new prime number.


243
00:10:54,516 --> 00:10:55,696
Go ahead and run the filter.


244
00:10:56,886 --> 00:11:00,496
Eliminate all the multiples of
three, and so on and so forth.


245
00:11:00,986 --> 00:11:02,286
What happens here is you end


246
00:11:02,286 --> 00:11:05,986
up building along this left-hand
diagonal the actual prime


247
00:11:05,986 --> 00:11:08,666
numbers, and as a result they
all get concatenated together.


248
00:11:10,176 --> 00:11:11,456
The idea is similar.


249
00:11:11,706 --> 00:11:12,946
It's very, very similar.


250
00:11:13,976 --> 00:11:16,246
But it's not the same algorithm


251
00:11:16,246 --> 00:11:20,076
because it has different
performance characteristics.


252
00:11:21,236 --> 00:11:23,486
So this result comes
from a brilliant paper


253
00:11:23,486 --> 00:11:26,486
by Melissa O'Neil called "The
Genuine Sieve of Eratosthenes,"


254
00:11:27,156 --> 00:11:28,996
where she showed the
Haskell community


255
00:11:28,996 --> 00:11:32,106
that their beloved sieve
was not the real sieve


256
00:11:32,596 --> 00:11:35,616
because it did not perform
the same as the real sieve.


257
00:11:36,356 --> 00:11:40,386
She goes through much more
complicated implementations


258
00:11:40,386 --> 00:11:43,936
in Haskell, that can get back to
the performance characteristics.


259
00:11:44,136 --> 00:11:45,126
Read the paper and check it out.


260
00:11:45,126 --> 00:11:45,826
It's really cool.


261
00:11:46,056 --> 00:11:48,736
I want to give you a taste
of why this is the case.


262
00:11:48,736 --> 00:11:50,646
Look at either the
Haskell list comprehension


263
00:11:50,946 --> 00:11:52,966
or the equivalent
Swift filter below.


264
00:11:53,456 --> 00:11:59,206
In this nonmutating version,
this operation will walk


265
00:11:59,206 --> 00:12:01,896
over every single
element in the array


266
00:12:02,136 --> 00:12:04,566
and do a division operation
to see if it should still be


267
00:12:04,566 --> 00:12:06,726
in the next step, to see if
it's a multiple of P or not.


268
00:12:07,666 --> 00:12:11,646
In the original mutating
algorithm, we only walked


269
00:12:11,646 --> 00:12:14,936
over the multiples of the prime
number and those, of course,


270
00:12:14,936 --> 00:12:16,536
become increasingly
sparse as you get


271
00:12:16,536 --> 00:12:17,866
to bigger and bigger numbers.


272
00:12:18,016 --> 00:12:20,926
So you are visiting fewer
elements, and moreover,


273
00:12:20,926 --> 00:12:23,316
you only have to do an addition
to the get to the next element.


274
00:12:23,316 --> 00:12:26,216
So you are doing less
work per element.


275
00:12:26,726 --> 00:12:27,606
That matters.


276
00:12:28,386 --> 00:12:30,596
And the nonmutating
version is not as efficient


277
00:12:30,596 --> 00:12:32,986
as the mutating version
without a whole ton of work.


278
00:12:33,586 --> 00:12:35,806
Let's bring it back to Cocoa.


279
00:12:36,816 --> 00:12:39,786
So you see uses of
immutability in the Cocoa,


280
00:12:39,786 --> 00:12:40,946
Cocoa Touch frameworks.


281
00:12:41,436 --> 00:12:42,086
There's a lot of them.


282
00:12:42,086 --> 00:12:44,436
And that's Date, UI
image, NSNumber, and so on.


283
00:12:44,656 --> 00:12:45,886
These are immutable types,


284
00:12:46,106 --> 00:12:48,606
and having these immutable
types improves safety.


285
00:12:48,836 --> 00:12:50,176
It's a good thing
because you don't have


286
00:12:50,176 --> 00:12:51,046
to worrying about copying.


287
00:12:51,366 --> 00:12:52,026
You don't have to worry


288
00:12:52,026 --> 00:12:54,576
about your sharing having
unintended side effects.


289
00:12:55,536 --> 00:12:58,126
But you also see the downsides
there when you work with it.


290
00:12:58,186 --> 00:13:00,816
I gave myself a little
task in Objective-C.


291
00:13:01,206 --> 00:13:05,026
I want to create an NSURL by
starting with my home directory


292
00:13:05,026 --> 00:13:07,616
and adding successive
path components


293
00:13:07,906 --> 00:13:08,956
to get to some directory.


294
00:13:09,836 --> 00:13:11,406
And I wanted to do it
without the mutation


295
00:13:11,406 --> 00:13:12,646
in the reference semantic world.


296
00:13:13,066 --> 00:13:14,776
So I created an NSURL.


297
00:13:15,246 --> 00:13:17,846
Each time through the
loop, I create a new URL


298
00:13:17,846 --> 00:13:19,566
by appending the
next path component.


299
00:13:20,506 --> 00:13:22,006
This is not a great
algorithm, really.


300
00:13:22,706 --> 00:13:25,556
Every time through, I'm creating
an NSURL, another object,


301
00:13:25,646 --> 00:13:31,676
the old one goes away, and then
the NSURL is going to copy all


302
00:13:31,676 --> 00:13:33,906
of the string data each
time through the loop.


303
00:13:34,456 --> 00:13:36,736
Not very efficient there.


304
00:13:37,086 --> 00:13:38,976
Doug, you are holding it wrong.


305
00:13:39,216 --> 00:13:41,246
Really you should be
collecting all these components


306
00:13:41,626 --> 00:13:45,346
into an NSArray and then use
file URL with path components.


307
00:13:46,636 --> 00:13:49,536
Fine. But, remember, we are
embracing immutability here.


308
00:13:50,556 --> 00:13:53,266
So when I create my array,
I will create an NSArray


309
00:13:53,646 --> 00:13:55,226
with a particular
object, all right,


310
00:13:55,226 --> 00:13:56,106
that's the home directory.


311
00:13:56,516 --> 00:13:59,066
Each time through, I
create a new array,


312
00:13:59,626 --> 00:14:00,886
adding one more object.


313
00:14:01,356 --> 00:14:02,456
I'm still quadratic.


314
00:14:03,026 --> 00:14:04,376
I'm still copying the elements.


315
00:14:04,376 --> 00:14:05,486
I'm not copying the string data.


316
00:14:05,486 --> 00:14:06,396
So it's a little better.


317
00:14:06,696 --> 00:14:07,866
I'm still copying the elements.


318
00:14:08,206 --> 00:14:11,726
This is why we don't
fully embrace immutability


319
00:14:11,726 --> 00:14:13,726
in the world of Cocoa
because it doesn't make sense.


320
00:14:13,726 --> 00:14:15,596
Instead, you use mutability


321
00:14:16,096 --> 00:14:18,606
in more localized places
where it makes sense.


322
00:14:19,096 --> 00:14:22,336
Collect all of your components
into an NSMutable array.


323
00:14:22,946 --> 00:14:25,786
Then use file URL with
path components to get back


324
00:14:25,786 --> 00:14:28,046
to that immutable NSURL.


325
00:14:29,336 --> 00:14:31,806
So immutability is a good thing.


326
00:14:31,846 --> 00:14:34,606
It makes the reference semantic
world easier to reason about.


327
00:14:35,296 --> 00:14:38,006
But you can't go
completely to immutability


328
00:14:38,296 --> 00:14:39,486
or you start to go crazy.


329
00:14:39,886 --> 00:14:43,236
So that brings us
to value semantics.


330
00:14:44,216 --> 00:14:46,076
With value semantics, we
take a different approach.


331
00:14:46,566 --> 00:14:47,446
We like mutation.


332
00:14:47,866 --> 00:14:48,626
We think it's valuable.


333
00:14:48,626 --> 00:14:51,466
We think it's easy to
use when done correctly.


334
00:14:52,146 --> 00:14:55,486
The problem, as we see
it, is the sharing.


335
00:14:56,936 --> 00:14:59,906
So you already know how value
semantics work and you demand


336
00:14:59,906 --> 00:15:03,976
on it all the time, whether you
are in Objective-C or in Swift.


337
00:15:04,046 --> 00:15:05,976
The idea is simple: if
you have two variables,


338
00:15:06,506 --> 00:15:09,056
the values in those variables
are logically distinct.


339
00:15:10,416 --> 00:15:13,916
So I have an integer A, I
copy it over to an integer B.


340
00:15:14,156 --> 00:15:16,466
Of course they are
equivalent; it's a copy.


341
00:15:16,886 --> 00:15:18,876
I go to mutate B.


342
00:15:19,626 --> 00:15:22,686
If I told you that would change
A, you would say I'm crazy.


343
00:15:24,126 --> 00:15:24,896
These are integers.


344
00:15:25,096 --> 00:15:26,146
They have value semantics


345
00:15:26,146 --> 00:15:29,406
in every language we
have ever worked with.


346
00:15:29,616 --> 00:15:31,176
Go to CGPoint, for example.


347
00:15:32,916 --> 00:15:36,566
Copy from A to B,
mutate B, it's not going


348
00:15:36,566 --> 00:15:37,956
to have any effect on A.


349
00:15:38,936 --> 00:15:41,106
You are used to this.


350
00:15:41,106 --> 00:15:42,606
If CGPoint didn't
behave this way,


351
00:15:42,606 --> 00:15:44,386
you would be really,
really surprised.


352
00:15:46,496 --> 00:15:50,276
The idea of value semantics is
take this thing we already know


353
00:15:50,276 --> 00:15:53,636
and understand for the very
fundamental types, like numbers


354
00:15:53,636 --> 00:15:57,126
and small structs containing
numbers, and extend it outward


355
00:15:57,976 --> 00:16:00,456
to work with much,
much richer types.


356
00:16:00,516 --> 00:16:02,836
So in Swift, strings
are value types.


357
00:16:03,526 --> 00:16:07,216
You create A, copy from B
to A, go ahead and change B


358
00:16:07,216 --> 00:16:09,516
in some way, it won't
have any effect on A.


359
00:16:10,756 --> 00:16:11,706
Because it's a value type.


360
00:16:11,706 --> 00:16:13,746
A and B are different variables.


361
00:16:13,836 --> 00:16:15,306
Therefore, they are
logically distinct.


362
00:16:18,026 --> 00:16:22,256
Okay? Why shouldn't the arrays
behave exactly the same way?


363
00:16:23,666 --> 00:16:26,206
Create A, copy it
over to B, mutate B.


364
00:16:26,206 --> 00:16:27,186
It has no effect on A.


365
00:16:27,186 --> 00:16:29,876
They are completely
distinct values.


366
00:16:31,976 --> 00:16:33,826
Last one, well, dictionaries,
of course.


367
00:16:33,886 --> 00:16:34,846
It's just a collection.


368
00:16:35,396 --> 00:16:37,036
You put value semantic
things into it,


369
00:16:37,736 --> 00:16:38,886
you get value semantics back.


370
00:16:39,586 --> 00:16:43,316
The great thing here is that
value types compose beautifully.


371
00:16:43,676 --> 00:16:46,856
So you can build up very rich
abstractions all in the world


372
00:16:46,856 --> 00:16:48,416
of value semantics easily.


373
00:16:49,106 --> 00:16:52,396
So in Swift, all the fundamental
types -- integers, doubles,


374
00:16:52,466 --> 00:16:55,686
strings, characters, et cetera
-- they are all value types.


375
00:16:55,686 --> 00:16:57,316
They have this fundamental
behavior,


376
00:16:57,316 --> 00:16:59,036
the two variables are
logically distinct.


377
00:16:59,806 --> 00:17:02,056
All the collections we
build on top of them --


378
00:17:02,056 --> 00:17:03,436
array, set, dictionary --


379
00:17:03,926 --> 00:17:06,246
are value types when
they're given value types.


380
00:17:06,736 --> 00:17:09,366
And the language
abstractions you use


381
00:17:09,366 --> 00:17:12,576
to build your own types --
tuples, structs, and enums --


382
00:17:12,886 --> 00:17:15,806
when you put value types into
those, you get value types out.


383
00:17:16,156 --> 00:17:20,516
Again, it's very, very easy
to build rich abstractions all


384
00:17:20,516 --> 00:17:21,796
in the world of value semantics.


385
00:17:22,836 --> 00:17:25,746
Now, there's one more
critical piece to a value type,


386
00:17:26,296 --> 00:17:30,076
and that is that you have the
notion of when two values,


387
00:17:30,076 --> 00:17:32,506
two variables of value
type, are equivalent.


388
00:17:32,626 --> 00:17:33,846
They hold the same value.


389
00:17:33,846 --> 00:17:37,916
And the important thing is that
identity is not what matters.


390
00:17:38,826 --> 00:17:40,226
Because you can have
any number of copies.


391
00:17:40,226 --> 00:17:42,426
What matters is the actual
value that's stored there.


392
00:17:42,426 --> 00:17:44,826
It doesn't matter how
you got to that value.


393
00:17:45,226 --> 00:17:47,536
I will tell you things that
are really, really silly.


394
00:17:48,376 --> 00:17:50,506
Here we have A, we set
it to 5, and we have B


395
00:17:50,506 --> 00:17:51,806
and we set it to 2 plus 3.


396
00:17:52,646 --> 00:17:54,276
Of course A and B
are equivalent.


397
00:17:55,376 --> 00:17:56,376
You work with this all the time.


398
00:17:56,376 --> 00:17:58,896
You couldn't understand integers
if they didn't work this way.


399
00:17:59,516 --> 00:18:01,726
So just extend that notion out.


400
00:18:02,296 --> 00:18:04,196
Of course it's the same
thing for CGPoints,


401
00:18:04,196 --> 00:18:05,146
you wouldn't be able
to understand them


402
00:18:05,146 --> 00:18:05,956
if it wasn't this way.


403
00:18:07,276 --> 00:18:09,696
Why shouldn't strings
behave exactly the same way?


404
00:18:09,696 --> 00:18:13,466
It doesn't matter how I get
to the string "Hello, WWDC."


405
00:18:14,576 --> 00:18:17,526
The string is the value, and
the equality operator needs


406
00:18:17,526 --> 00:18:18,316
to represent that.


407
00:18:19,206 --> 00:18:21,736
You can make this
arbitrarily crazy and stupid.


408
00:18:21,736 --> 00:18:24,456
So here I will go and do
some sorting operation.


409
00:18:25,086 --> 00:18:26,596
What it comes down to though
is that I have two arrays


410
00:18:26,596 --> 00:18:28,816
of integers, the integers
have the same values.


411
00:18:29,196 --> 00:18:30,596
Therefore, these
things are equivalent.


412
00:18:31,566 --> 00:18:35,336
When you're building a value
type, it's extremely important


413
00:18:35,946 --> 00:18:37,756
that it conform to the
Equatable protocol.


414
00:18:37,756 --> 00:18:41,076
Because every value type out
there should be equatable.


415
00:18:41,726 --> 00:18:44,156
That means it has the
equal equal operator


416
00:18:44,316 --> 00:18:46,586
to do a comparison,
but that operator has


417
00:18:46,586 --> 00:18:48,266
to behave in a sensible way.


418
00:18:48,266 --> 00:18:50,946
It needs to be reflexive,
symmetric, and transitive.


419
00:18:51,626 --> 00:18:53,016
Why are these properties
important?


420
00:18:53,016 --> 00:18:55,716
Because you can't understand
your code unless you have them.


421
00:18:56,676 --> 00:19:00,346
If I copy from A to B, well,
I expect that A is equal


422
00:19:00,346 --> 00:19:01,626
to B and B is equal to A.


423
00:19:01,846 --> 00:19:02,346
Of course.


424
00:19:02,346 --> 00:19:03,056
Why wouldn't it be?


425
00:19:03,516 --> 00:19:06,186
If I then copy B over to
C, well then C and B and A,


426
00:19:06,186 --> 00:19:06,916
they're all equivalent.


427
00:19:06,916 --> 00:19:08,926
It doesn't matter which I
have because the only thing


428
00:19:08,926 --> 00:19:11,206
that matters there is the
value, not the identity.


429
00:19:12,416 --> 00:19:15,396
Fortunately, it's very, very
easy to implement these things.


430
00:19:15,816 --> 00:19:20,066
I can just say, take CGPoints
and extend it with Equatable


431
00:19:20,066 --> 00:19:21,516
and implement the
equality operator,


432
00:19:21,706 --> 00:19:24,136
and when you compose value
types out of other value types,


433
00:19:24,246 --> 00:19:26,576
generally speaking,
you just have


434
00:19:26,666 --> 00:19:29,126
to use the underlying
equal, equal operators


435
00:19:29,126 --> 00:19:30,046
of all the value types.


436
00:19:30,556 --> 00:19:32,036
All right.


437
00:19:32,256 --> 00:19:34,536
Let's bring this back
to our temperature type.


438
00:19:34,766 --> 00:19:36,396
We will make it a struct now.


439
00:19:36,396 --> 00:19:38,176
We are going to switch
Celsius back


440
00:19:38,176 --> 00:19:40,406
to a var to we can mutate it.


441
00:19:41,166 --> 00:19:42,556
This now has value semantics.


442
00:19:42,556 --> 00:19:44,286
We give it the obvious
equality operator.


443
00:19:44,856 --> 00:19:46,936
We go ahead and use this
in our example before.


444
00:19:47,256 --> 00:19:47,706
That's fine.


445
00:19:47,706 --> 00:19:49,896
We create the home, create the
temperature, set the temperature


446
00:19:49,896 --> 00:19:52,406
to 75 degrees Fahrenheit
and whoa!


447
00:19:52,756 --> 00:19:53,876
Compiler stops us here.


448
00:19:54,146 --> 00:19:54,826
What went on?


449
00:19:55,716 --> 00:19:59,236
Well, we are trying to
mutate a property of temp,


450
00:19:59,476 --> 00:20:00,556
which is describes as a let.


451
00:20:00,556 --> 00:20:01,726
It's a constant.


452
00:20:01,786 --> 00:20:02,386
It can't change.


453
00:20:03,076 --> 00:20:04,236
We will appease the compiler.


454
00:20:04,606 --> 00:20:06,116
Change it to var, and
now we can mutate it.


455
00:20:06,626 --> 00:20:08,326
And this all works
perfectly fine.


456
00:20:09,606 --> 00:20:10,396
Why is it fine?


457
00:20:10,396 --> 00:20:12,776
Well, the house points out to
the thermostat in the oven.


458
00:20:12,776 --> 00:20:16,076
The thermostat and the oven
both have their own instances


459
00:20:16,076 --> 00:20:17,336
of temperature values.


460
00:20:17,336 --> 00:20:19,406
They are completely distinct,
they're never shared.


461
00:20:20,086 --> 00:20:21,676
They also happen to be
inlined into the struct,


462
00:20:21,676 --> 00:20:23,656
and you are getting better
memory usage and performance.


463
00:20:24,856 --> 00:20:25,656
This is great.


464
00:20:25,656 --> 00:20:27,966
Value semantics have made
our lives easier here.


465
00:20:28,646 --> 00:20:31,346
With our example,
let's go all the way


466
00:20:31,436 --> 00:20:33,456
and make everything
value semantics.


467
00:20:34,976 --> 00:20:37,366
Now, house is a struct that
has a thermostat struct


468
00:20:37,366 --> 00:20:39,906
and an oven struct, and the
whole world is value semantics.


469
00:20:40,146 --> 00:20:40,956
The changes we need to make


470
00:20:40,956 --> 00:20:45,256
to our code is now home can be
mutated because we can go ahead


471
00:20:45,556 --> 00:20:48,086
and change the temperature on
the thermostat of the home,


472
00:20:48,496 --> 00:20:49,846
right, and that's
a mutation to home


473
00:20:49,846 --> 00:20:51,446
and thermostat and
to temperature.


474
00:20:51,936 --> 00:20:57,126
Okay. This brings us to
a really important point.


475
00:20:57,586 --> 00:21:00,836
Value semantics works
beautifully in Swift


476
00:21:01,226 --> 00:21:04,356
because of the way Swift's
immutability model works.


477
00:21:05,006 --> 00:21:08,276
When you have a let in
Swift, it's of a value type.


478
00:21:08,746 --> 00:21:12,526
It means this value
will never change short


479
00:21:12,526 --> 00:21:14,576
of something corrupting
your process' memory.


480
00:21:15,086 --> 00:21:18,446
This is a really
strong statement.


481
00:21:19,196 --> 00:21:20,546
It means it's very
easy to reason


482
00:21:20,546 --> 00:21:21,566
about things that are let.


483
00:21:22,356 --> 00:21:24,216
But we still allow mutation.


484
00:21:24,396 --> 00:21:27,386
You can use var to say this
variable can be changed.


485
00:21:27,896 --> 00:21:30,016
And that's extremely
useful for our algorithms.


486
00:21:31,316 --> 00:21:33,286
Note that this change
is very local.


487
00:21:33,466 --> 00:21:36,006
I can change this
variable, but it's not going


488
00:21:36,006 --> 00:21:38,426
to affect anything else
anywhere in my program


489
00:21:38,646 --> 00:21:41,236
until I tell it to, until I
do a mutation somewhere else,


490
00:21:41,806 --> 00:21:44,896
which gives you this really
nice controlled mutability.


491
00:21:45,446 --> 00:21:47,776
With strong guarantees
elsewhere.


492
00:21:49,016 --> 00:21:51,696
One of the nice things here is
when you are using value types


493
00:21:51,696 --> 00:21:54,476
of passing them across thread
boundaries, it gives you freedom


494
00:21:54,476 --> 00:21:56,696
from race conditions
on those types.


495
00:21:57,166 --> 00:21:58,086
So I create numbers.


496
00:21:58,086 --> 00:21:59,816
I passed them off
to some process


497
00:21:59,816 --> 00:22:01,586
that will do something
asynchronously.


498
00:22:02,156 --> 00:22:04,156
I mutate numbers locally
and then do it again.


499
00:22:04,596 --> 00:22:08,646
With a reference semantic
array, this is a race condition.


500
00:22:08,646 --> 00:22:10,356
It's going to blow
up on you sometime.


501
00:22:10,636 --> 00:22:13,226
With value semantics, you
are getting copies each time,


502
00:22:13,786 --> 00:22:14,916
logical copies each time.


503
00:22:16,086 --> 00:22:17,746
And therefore, there
is no race condition.


504
00:22:18,366 --> 00:22:19,576
They are not hitting
the same array.


505
00:22:19,576 --> 00:22:21,616
All right.


506
00:22:21,616 --> 00:22:23,926
Hold on. This sounds like a
performance problem, right?


507
00:22:24,256 --> 00:22:26,816
We are doing a copy every
time we pass numbers


508
00:22:26,816 --> 00:22:27,606
through a parameter.


509
00:22:28,846 --> 00:22:32,916
Okay. One of the important other
pieces of value semantics is


510
00:22:32,916 --> 00:22:34,396
that it copies are cheap.


511
00:22:34,876 --> 00:22:37,456
By cheap, I mean
constant time cheap.


512
00:22:37,886 --> 00:22:40,886
Let's build this up
from fundamentals.


513
00:22:40,886 --> 00:22:42,556
So when you have the
fundamental types,


514
00:22:42,556 --> 00:22:45,106
the really low-level things
-- integers, doubles, floats,


515
00:22:45,106 --> 00:22:48,176
et cetera -- copying
these is cheap.


516
00:22:48,236 --> 00:22:49,656
You are copying a
couple of bytes.


517
00:22:49,836 --> 00:22:51,646
Usually it happens
in the processor.


518
00:22:52,986 --> 00:22:55,126
So then you start
building structs


519
00:22:55,126 --> 00:22:57,206
out of doubles and
ints and so on.


520
00:22:57,236 --> 00:22:59,676
Like CG points is
built of two CG floats.


521
00:23:00,166 --> 00:23:02,526
And any of these
structs, enums or tuples,


522
00:23:02,526 --> 00:23:06,246
they have a fixed number
of fields, and copying each


523
00:23:06,246 --> 00:23:08,096
of the things in there
is constant time.


524
00:23:08,096 --> 00:23:10,336
So copying the whole
thing is constant time.


525
00:23:10,896 --> 00:23:12,396
All right.


526
00:23:13,376 --> 00:23:14,776
That's great for
fixed-length things.


527
00:23:14,776 --> 00:23:17,396
What about extensible
things, strings, arrays,


528
00:23:17,396 --> 00:23:18,546
dictionaries, and so on?


529
00:23:19,086 --> 00:23:21,816
The way we handle these in the
Swift world is by copy-on-write.


530
00:23:22,836 --> 00:23:24,466
So this makes the copy cheap.


531
00:23:24,676 --> 00:23:27,226
It's just some fixed number of
reference-counting operations


532
00:23:27,226 --> 00:23:29,596
to do a copy of a
copy-on-write value.


533
00:23:29,596 --> 00:23:32,746
And then at the point where you
do a mutation, you have a var


534
00:23:32,746 --> 00:23:35,196
and then you change
it, then we make a copy


535
00:23:35,196 --> 00:23:36,066
and work on the copy.


536
00:23:36,836 --> 00:23:39,306
So you have sharing
behind the scenes,


537
00:23:40,666 --> 00:23:42,646
but it's not logical sharing


538
00:23:42,646 --> 00:23:45,006
but logically these are
still distinct values.


539
00:23:45,226 --> 00:23:47,146
This gives you great
performance characteristics


540
00:23:47,416 --> 00:23:50,676
from value semantics and is
really a nice programming model.


541
00:23:51,576 --> 00:23:53,606
So we really love the value
semantic programming model.


542
00:23:54,266 --> 00:23:57,166
Different variables are
logically distinct, always.


543
00:23:58,506 --> 00:24:01,566
You have the notion of
mutation, an efficient mutation,


544
00:24:01,826 --> 00:24:04,036
when you want it
locally controlled.


545
00:24:05,416 --> 00:24:07,216
But you have these
strong guarantees of let,


546
00:24:07,216 --> 00:24:08,726
meaning it will not
change elsewhere.


547
00:24:09,736 --> 00:24:11,936
And copies are cheap, which
makes us all work together.


548
00:24:13,256 --> 00:24:13,596
All right.


549
00:24:13,626 --> 00:24:15,716
With that, I would like to
hand it over to my colleague,


550
00:24:15,716 --> 00:24:18,476
Bill Dudney, who will talk
about value types and practice.


551
00:24:19,516 --> 00:24:25,996
[ Applause ]


552
00:24:26,496 --> 00:24:27,006
>> BILL DUDNEY: Thanks, Doug.


553
00:24:27,876 --> 00:24:28,536
Hi, everybody.


554
00:24:28,536 --> 00:24:31,726
So now that Doug has filled our
minds with how value types work,


555
00:24:32,056 --> 00:24:34,536
how they compare with
reference semantics,


556
00:24:34,636 --> 00:24:38,596
let's talk about building a real
example that uses value types.


557
00:24:38,596 --> 00:24:42,636
So what we are going to do
is put together an example


558
00:24:42,636 --> 00:24:44,936
where we build a
simple diagram made


559
00:24:44,936 --> 00:24:48,306
of a couple odifferent value
types, a circle and a polygon.


560
00:24:49,386 --> 00:24:51,406
So we will get started
with the circle.


561
00:24:51,916 --> 00:24:54,236
It's a center, and a radius.


562
00:24:54,306 --> 00:24:56,056
A couple of value types
that come straight


563
00:24:56,056 --> 00:24:57,246
out of the standard library.


564
00:24:57,856 --> 00:25:00,766
Of course, we want to
implement the equality operator,


565
00:25:00,766 --> 00:25:02,086
the equals equals operator,


566
00:25:02,086 --> 00:25:04,496
and we do that by just
comparing those types.


567
00:25:04,496 --> 00:25:06,756
Again, since they are built
into the standard library,


568
00:25:07,056 --> 00:25:09,746
all we have to do is use
those since we are composing


569
00:25:09,746 --> 00:25:11,806
from the simple types that
came out of the library.


570
00:25:12,326 --> 00:25:14,676
Next up is the polygon.


571
00:25:15,066 --> 00:25:16,906
It has an array of corners,


572
00:25:17,116 --> 00:25:19,836
and each of the corners is
just another CG point, which,


573
00:25:19,836 --> 00:25:20,916
again, is a value type.


574
00:25:21,326 --> 00:25:23,986
So our array is a
value type, and, again,


575
00:25:23,986 --> 00:25:25,606
our comparison is
straightforward,


576
00:25:25,726 --> 00:25:27,676
just using the equals,
equals operator there


577
00:25:27,676 --> 00:25:29,896
to make sure we implement
the Equatable operator.


578
00:25:29,896 --> 00:25:36,296
Now what we want to do is put
these types into our diagram,


579
00:25:36,656 --> 00:25:39,116
put both polygons and circles.


580
00:25:40,376 --> 00:25:42,526
Making an array of
circles is straightforward.


581
00:25:43,506 --> 00:25:46,876
Making an array of
polygons is straightforward.


582
00:25:46,876 --> 00:25:49,536
So we can make an
array of either type.


583
00:25:49,536 --> 00:25:53,376
What we need to do is make
one array that contains both.


584
00:25:54,006 --> 00:25:59,476
The mechanism to do that in
Swift is with a protocol.


585
00:25:59,476 --> 00:26:02,176
So we will create a
protocol called Drawable.


586
00:26:02,176 --> 00:26:05,416
We will make both of
our subtypes implement


587
00:26:05,416 --> 00:26:07,516
that protocol, and
then we can put them


588
00:26:07,516 --> 00:26:09,286
into an array in our diagram.


589
00:26:10,816 --> 00:26:12,046
Tons of great information


590
00:26:12,046 --> 00:26:14,916
in this Protocol-Oriented
Programming in Swift talk,


591
00:26:14,916 --> 00:26:17,726
which is repeating
again today at 3:30.


592
00:26:18,066 --> 00:26:19,096
So if you haven't seen that,


593
00:26:19,096 --> 00:26:21,396
I would highly suggest
you take a look


594
00:26:21,396 --> 00:26:23,166
at it or catch it on video.


595
00:26:24,086 --> 00:26:27,526
So here's our Drawable protocol.


596
00:26:27,816 --> 00:26:31,686
Straightforward and simple,
has one method, Draw, on it.


597
00:26:32,276 --> 00:26:34,596
And, of course, we want to
implement that on our two types.


598
00:26:34,596 --> 00:26:36,466
We will create an
extension of polygon,


599
00:26:36,826 --> 00:26:39,176
implement that draw method,
and that's just going to call


600
00:26:39,176 --> 00:26:41,216
out to Core Graphics
and draw the polygon.


601
00:26:41,876 --> 00:26:44,496
And the same thing
for the circle.


602
00:26:44,496 --> 00:26:47,276
So what we are going to do,
just call Core Graphics to build


603
00:26:47,276 --> 00:26:49,316
up the representation
of the circle.


604
00:26:49,316 --> 00:26:55,626
Now back to out diagram.


605
00:26:55,626 --> 00:26:58,056
It's got this array of
drawables called Items.


606
00:26:58,886 --> 00:27:00,756
We need to create a
method to add items.


607
00:27:00,926 --> 00:27:03,436
That's marked as mutating
because that mutates self.


608
00:27:03,436 --> 00:27:08,096
We are going to implement the
Draw method to simply iterate


609
00:27:08,096 --> 00:27:10,296
through that list of items
and call the Draw method


610
00:27:10,296 --> 00:27:11,856
on each item that's in the list.


611
00:27:13,176 --> 00:27:15,056
So let's take a look
at it diagrammatically.


612
00:27:15,836 --> 00:27:18,806
So we create a diagram,
called doc.


613
00:27:19,766 --> 00:27:21,876
We create a polygon and
add that to the array.


614
00:27:23,426 --> 00:27:26,676
We create another one, a circle,
and we add that to the array.


615
00:27:26,676 --> 00:27:28,696
Now our array has
two drawables in it.


616
00:27:29,466 --> 00:27:30,806
Notice they are different types.


617
00:27:31,386 --> 00:27:37,566
When we create another document,
by saying doc2 equals doc,


618
00:27:37,716 --> 00:27:40,466
we get a logically
distinct, brand-new instance.


619
00:27:40,466 --> 00:27:43,286
It's logically separate
from that first instance.


620
00:27:45,076 --> 00:27:50,136
I can go back and make changes
to doc2 now, and when I do that,


621
00:27:50,136 --> 00:27:52,326
of course, it has
no effect on doc.


622
00:27:52,786 --> 00:27:54,696
I change that circle
to a polygon.


623
00:27:55,756 --> 00:28:00,186
The array has value semantics
even though the collection


624
00:28:00,186 --> 00:28:01,186
is heterogeneous.


625
00:28:01,256 --> 00:28:05,976
So it has the polygon inside,
and the circle is inside


626
00:28:05,976 --> 00:28:07,166
that array as a value.


627
00:28:07,826 --> 00:28:15,516
So, of course, we want to make
our diagram struct Equatable.


628
00:28:15,936 --> 00:28:17,506
So we implement the protocol.


629
00:28:17,506 --> 00:28:19,486
And this would be the
straightforward implementation


630
00:28:19,486 --> 00:28:20,486
that we would look at doing.


631
00:28:21,176 --> 00:28:23,396
However, if we would do that,
the compiler says, "Hey,


632
00:28:23,396 --> 00:28:26,846
wait a minute, I don't have
an equals equals operator


633
00:28:27,066 --> 00:28:29,836
for these two values on
either side of that equation."


634
00:28:30,166 --> 00:28:31,186
Again, I will refer you


635
00:28:31,186 --> 00:28:33,056
to the Protocol-Oriented
Programming talk,


636
00:28:33,056 --> 00:28:36,366
where we talked through all the
details of how all that works.


637
00:28:36,526 --> 00:28:39,436
In this talk, we will focus
on the value semantics.


638
00:28:39,966 --> 00:28:45,536
So drawable has a single
method called Draw,


639
00:28:45,536 --> 00:28:48,286
our diagram has a
method called Draw.


640
00:28:48,506 --> 00:28:51,586
So let's go ahead and turn
our diagram into a drawable.


641
00:28:51,586 --> 00:28:54,516
All we have to do is add
that declaration to it.


642
00:28:54,656 --> 00:28:59,046
Now our diagram quacks
like a duck and is a duck.


643
00:28:59,736 --> 00:29:02,816
So this brings us to
an interesting point.


644
00:29:02,816 --> 00:29:08,866
I can create a new diagram and
add it to my existing diagram.


645
00:29:09,946 --> 00:29:12,246
It's got three different
types in there,


646
00:29:12,246 --> 00:29:15,166
but they are all
contained inside that array.


647
00:29:16,016 --> 00:29:17,786
It's a new instance of Diagram.


648
00:29:19,106 --> 00:29:21,246
But I can push it
one further and add


649
00:29:21,246 --> 00:29:23,256
that document to the array.


650
00:29:23,646 --> 00:29:25,536
Now if this were
reference semantics --


651
00:29:26,416 --> 00:29:27,386
let's look at the Draw method.


652
00:29:27,386 --> 00:29:28,996
If this were reference
semantics,


653
00:29:29,386 --> 00:29:30,746
this would infinite recurse.


654
00:29:31,326 --> 00:29:35,866
As I call Draw on my diagram,
it will go through the list


655
00:29:35,866 --> 00:29:37,986
of items and find
itself in that list.


656
00:29:37,986 --> 00:29:40,476
And so it's going to call Draw
again and infinitely recurse.


657
00:29:41,146 --> 00:29:43,476
But, we are using values.


658
00:29:43,776 --> 00:29:48,416
So instead of the doc
being added to my diagram,


659
00:29:48,476 --> 00:29:49,866
it's completely a separate


660
00:29:49,866 --> 00:29:53,156
and distinct instance
because it's a value.


661
00:29:54,336 --> 00:29:55,986
So there's no infinite
recursion.


662
00:29:56,246 --> 00:29:59,206
I just get two polygons
and two circles drawn.


663
00:29:59,206 --> 00:30:05,146
Now that we have talked
about building a tree


664
00:30:05,146 --> 00:30:06,976
of objects purely
out of value types,


665
00:30:07,026 --> 00:30:10,186
let's talk about how we mix
value types and reference types.


666
00:30:10,886 --> 00:30:12,256
Now in Objective-C, you are used


667
00:30:12,256 --> 00:30:15,906
to putting primitive data types
inside your reference types all


668
00:30:15,906 --> 00:30:16,286
the time.


669
00:30:16,286 --> 00:30:18,186
This is how we build
things in Objective-C.


670
00:30:19,286 --> 00:30:22,496
But the flip side introduces
some interesting questions


671
00:30:22,496 --> 00:30:23,606
that we have to think through.


672
00:30:25,226 --> 00:30:28,006
If we are building a value
type, we want to make sure


673
00:30:28,006 --> 00:30:31,306
that that value type
maintains its value semantics,


674
00:30:31,436 --> 00:30:33,926
even though it has a
reference inside of it.


675
00:30:34,356 --> 00:30:35,826
So if we are going to do that,


676
00:30:35,826 --> 00:30:37,386
we have to think
about that question.


677
00:30:37,386 --> 00:30:39,376
How do we deal with this fact


678
00:30:39,426 --> 00:30:44,026
that two different values might
be pointing to the same thing


679
00:30:44,026 --> 00:30:45,126
because it has a
reference in it?


680
00:30:45,126 --> 00:30:46,866
So we have to solve
that question.


681
00:30:47,416 --> 00:30:48,426
The other thing we have to think


682
00:30:48,426 --> 00:30:51,796
through is how is
equality affected by that.


683
00:30:52,026 --> 00:30:53,786
So let's start with
a simple example


684
00:30:53,786 --> 00:30:56,856
with an immutable
class, UIImage.


685
00:30:57,456 --> 00:31:01,236
We will create an image struct
that is going to be a drawable,


686
00:31:01,386 --> 00:31:03,326
and it has a reference
to a UIImage.


687
00:31:03,856 --> 00:31:06,286
So we create the instance


688
00:31:06,286 --> 00:31:08,666
with this beautiful
photograph of San Francisco.


689
00:31:09,726 --> 00:31:13,596
And if we create another
one, image 2, so now image


690
00:31:13,596 --> 00:31:16,696
and image 2 are both
pointing to the same object.


691
00:31:17,206 --> 00:31:18,836
And you look at this and
you think, Bill is going


692
00:31:18,836 --> 00:31:20,816
to trick us, and this is going
to be a problem, and it will be


693
00:31:20,816 --> 00:31:21,936
like the temperature thing.


694
00:31:22,436 --> 00:31:25,386
But it's not because
UIImage is immutable.


695
00:31:25,716 --> 00:31:29,816
So we don't have to worry about
image 2 mutating the image


696
00:31:29,816 --> 00:31:30,766
that sits underneath it


697
00:31:30,806 --> 00:31:33,646
and having the first
image be caught off guard


698
00:31:33,646 --> 00:31:34,486
with that change.


699
00:31:35,736 --> 00:31:38,726
Of course we want to make
sure we implement the equality


700
00:31:39,586 --> 00:31:41,796
and at first blush, you might
look at this and think, okay,


701
00:31:41,796 --> 00:31:43,496
I will use the triple
equals operator,


702
00:31:43,496 --> 00:31:46,366
which will compare
the reference and see


703
00:31:46,366 --> 00:31:47,796
if those references
are the same.


704
00:31:48,356 --> 00:31:51,846
Well this would work okay in
this example, but we also have


705
00:31:51,846 --> 00:31:52,986
to think through what happens


706
00:31:52,986 --> 00:31:57,766
if we create two UI images using
the same underlying bitmap.


707
00:31:58,526 --> 00:32:02,596
We want those also to equate to
being equal, and in this case,


708
00:32:02,596 --> 00:32:05,036
since we are comparing the
reference, they would not.


709
00:32:05,036 --> 00:32:06,606
So this would be falsely saying


710
00:32:06,606 --> 00:32:08,746
that these two images
are not the same.


711
00:32:09,236 --> 00:32:12,386
So instead what we want to
do is use the Is Equal method


712
00:32:12,896 --> 00:32:16,116
that we inherit from NSObject
on UIImage to do the comparison,


713
00:32:16,416 --> 00:32:19,056
so we'll be sure that the
reference type gets the right


714
00:32:19,546 --> 00:32:25,206
answer on whether or not
it's the same object or not.


715
00:32:25,206 --> 00:32:27,666
Let's talk about
using mutable objects.


716
00:32:28,226 --> 00:32:30,266
We have a BezierPath here.


717
00:32:31,366 --> 00:32:32,956
It also implements Drawable.


718
00:32:33,526 --> 00:32:35,226
But its entire implementation
is made


719
00:32:35,226 --> 00:32:37,676
up by this mutable
reference type, UIBezierPath.


720
00:32:37,676 --> 00:32:42,706
In the reading case, when
we're doing Is Empty,


721
00:32:42,776 --> 00:32:43,726
everything is okay.


722
00:32:43,726 --> 00:32:45,886
We are not doing any
mutation, so we're not going


723
00:32:45,886 --> 00:32:48,386
to mess any other instances up.


724
00:32:49,066 --> 00:32:52,146
But on this one below, we have
this Add Line To Point method,


725
00:32:52,456 --> 00:32:54,966
and if we have two
BezierPaths pointing to that,


726
00:32:55,316 --> 00:32:56,616
it will cause problems.


727
00:32:57,436 --> 00:33:00,716
Also notice here, we don't have
the Mutating keyword there.


728
00:33:01,416 --> 00:33:04,636
That's a sign that we know we
are mutating because Add Line


729
00:33:04,636 --> 00:33:06,746
To Point is there, but the
compiler is not yelling


730
00:33:06,746 --> 00:33:07,326
at us about it.


731
00:33:07,526 --> 00:33:09,346
That's because path
is a reference type.


732
00:33:09,346 --> 00:33:11,566
We will look at that
again in just a moment.


733
00:33:12,656 --> 00:33:16,766
So if I have two instances
of BezierPath, both pointing


734
00:33:16,766 --> 00:33:18,866
to the same instance
of UIBezierPath


735
00:33:18,866 --> 00:33:22,346
through this reference, and I
make this mutation, that's going


736
00:33:22,346 --> 00:33:24,026
to catch the other
one off guard.


737
00:33:24,026 --> 00:33:25,666
This is a bad situation.


738
00:33:25,666 --> 00:33:27,786
We are not maintaining
value semantics.


739
00:33:28,186 --> 00:33:29,726
We need to fix that.


740
00:33:30,356 --> 00:33:33,226
The way we will fix that
is use copy-on-write,


741
00:33:33,876 --> 00:33:37,446
and we want to make sure that
before we write to that path,


742
00:33:37,446 --> 00:33:39,466
that we make a copy of it.


743
00:33:40,656 --> 00:33:42,846
So to do that, we need
to introduce a couple


744
00:33:42,846 --> 00:33:44,826
of new things to our BezierPath.


745
00:33:44,956 --> 00:33:48,936
First, we want to make
our path instance private,


746
00:33:49,506 --> 00:33:52,516
and next we want to implement
this computed path property


747
00:33:52,956 --> 00:33:55,396
for reading and from there
we will return our private


748
00:33:55,396 --> 00:33:56,196
instance variable.


749
00:33:56,756 --> 00:33:59,026
And we want to make a path


750
00:33:59,406 --> 00:34:02,776
for writing computed property
that's marked as mutating,


751
00:34:03,096 --> 00:34:04,926
and that's going to, in
fact, change the state.


752
00:34:04,926 --> 00:34:07,786
So we marked it mutating
and we set path equal


753
00:34:07,786 --> 00:34:10,766
to a new copy of
our existing path.


754
00:34:11,275 --> 00:34:15,136
Now we have both a reading copy
and a way to get a writing copy.


755
00:34:16,315 --> 00:34:18,896
And we change our
implementation to reflect that.


756
00:34:18,896 --> 00:34:21,696
In the Is Empty method, we
will call our reading copy,


757
00:34:22,025 --> 00:34:23,815
and in the mutating
method below,


758
00:34:23,815 --> 00:34:25,166
we will call the
path for writing.


759
00:34:25,735 --> 00:34:28,466
And the great thing about this
that the compiler is going


760
00:34:28,466 --> 00:34:29,956
to yell at us and say, "Hey,


761
00:34:30,356 --> 00:34:33,466
that path for writing
property is marked as mutating,


762
00:34:33,806 --> 00:34:36,065
and this method is not
marked for mutating."


763
00:34:36,065 --> 00:34:39,076
So we are getting help from
the compiler to help us figure


764
00:34:39,076 --> 00:34:41,096
out when we are doing
something wrong.


765
00:34:41,795 --> 00:34:46,085
Just to look through it
in a diagram, the path,


766
00:34:46,996 --> 00:34:49,545
I create another one
by saying Path To.


767
00:34:49,996 --> 00:34:51,156
Of course, I can read from it.


768
00:34:51,156 --> 00:34:54,376
No issue. And when
I go to write to it,


769
00:34:54,985 --> 00:34:58,966
since I'm creating another
instance of BezierPath,


770
00:34:59,566 --> 00:35:02,736
path two is none the wiser
that a mutation has happened.


771
00:35:03,096 --> 00:35:06,676
So I will not introduce some
unexpected mutation behind


772
00:35:07,996 --> 00:35:08,646
path two.


773
00:35:11,046 --> 00:35:14,626
So now let's talk about how to
use these things in practice.


774
00:35:15,656 --> 00:35:19,356
Here we have our polygon
type, and we are extending


775
00:35:19,356 --> 00:35:21,506
that by adding a method
that's going to return


776
00:35:21,506 --> 00:35:24,106
to us a BezierPath that
describes that polygon.


777
00:35:24,826 --> 00:35:27,386
So we create the BezierPath,
iterate through the points,


778
00:35:27,386 --> 00:35:29,776
adding a line two to
each of these points.


779
00:35:30,086 --> 00:35:33,176
Now, the downside is
remember that Add Line


780
00:35:33,176 --> 00:35:36,066
To Point method is
copying on every call.


781
00:35:36,646 --> 00:35:39,166
So this is not going to
perform as well as it might.


782
00:35:40,966 --> 00:35:43,656
So instead, what we should
do is create an instance


783
00:35:43,656 --> 00:35:48,986
of UIBezierPath and mutate that
mutable reference type in place


784
00:35:49,326 --> 00:35:52,686
and when we're done, create a
new instance of our value type


785
00:35:52,826 --> 00:35:54,816
with that BezierPath
and return that.


786
00:35:55,216 --> 00:35:57,806
That creates only one
copy or only one instance


787
00:35:57,806 --> 00:35:59,926
of UIBezierPath instead
of multiple.


788
00:36:00,536 --> 00:36:05,686
In Swift, we have a great
feature where we know


789
00:36:05,686 --> 00:36:07,436
if objects are uniquely
referenced,


790
00:36:07,436 --> 00:36:09,156
and so we can take
advantage of that.


791
00:36:09,156 --> 00:36:11,566
This is a similar structure to
what we saw in our BezierPath,


792
00:36:12,196 --> 00:36:15,556
and we can use this fact that
we have this uniquely referenced


793
00:36:15,686 --> 00:36:17,636
property and we know for a fact


794
00:36:17,716 --> 00:36:18,996
that something is
uniquely referenced


795
00:36:18,996 --> 00:36:21,566
so we can avoid making
the copies if we know


796
00:36:21,566 --> 00:36:23,836
that that reference type
is uniquely referenced.


797
00:36:24,276 --> 00:36:27,566
The standard library uses
that feature throughout


798
00:36:27,566 --> 00:36:29,826
and does a lot of great
performance optimizations


799
00:36:29,826 --> 00:36:31,006
using that.


800
00:36:31,956 --> 00:36:34,616
So that's mixing value
types and reference types.


801
00:36:34,616 --> 00:36:38,286
You want to make sure that you
maintain value semantics despite


802
00:36:38,286 --> 00:36:42,656
the fact that you have these
references to mutable types


803
00:36:42,786 --> 00:36:44,746
by using copy-on-write.


804
00:36:45,496 --> 00:36:47,136
So now I want to look


805
00:36:47,136 --> 00:36:49,026
at a really cool
feature we can do now


806
00:36:49,026 --> 00:36:52,296
that we have a model type
implemented as a value,


807
00:36:53,086 --> 00:36:54,726
and implement an undo stack.


808
00:36:55,376 --> 00:36:59,056
So I'm going to create a diagram
and an array of diagrams.


809
00:36:59,316 --> 00:37:04,896
Then with every mutation, I will
add my doc to my diagram array.


810
00:37:05,246 --> 00:37:06,746
So I create it and append.


811
00:37:07,456 --> 00:37:10,706
I add a polygon and append
it to the undo stack.


812
00:37:11,616 --> 00:37:14,336
I create a circle and append
that to the undo stack.


813
00:37:14,886 --> 00:37:19,606
Now in my undo stack I have
three distinct instances


814
00:37:19,666 --> 00:37:20,756
of Diagram.


815
00:37:21,066 --> 00:37:23,746
These are not references
to the same thing,


816
00:37:23,746 --> 00:37:25,956
these are three distinct values.


817
00:37:26,566 --> 00:37:29,386
And so, I can implement some
really cool features with this.


818
00:37:29,716 --> 00:37:33,756
So imagine this in an app,
and I have a History button.


819
00:37:34,046 --> 00:37:37,206
I tap on the History button and
I get the list of all the states


820
00:37:37,206 --> 00:37:40,516
of my diagram back
through my undo stack.


821
00:37:41,086 --> 00:37:43,296
I can allow the user
to tap on something


822
00:37:43,626 --> 00:37:45,326
and essentially go back in time.


823
00:37:45,686 --> 00:37:50,206
I don't have to keep anything in
some array of how to undo adding


824
00:37:50,206 --> 00:37:51,356
that property or anything.


825
00:37:51,696 --> 00:37:53,716
It just goes back to
that previous instance,


826
00:37:53,716 --> 00:37:56,756
and that's the one
that gets drawn.


827
00:37:56,936 --> 00:37:59,916
This is a super-powerful
feature, and, in fact,


828
00:38:00,316 --> 00:38:03,236
Photoshop uses this
extensively to implement all


829
00:38:03,236 --> 00:38:04,186
of their history stuff.


830
00:38:05,086 --> 00:38:07,036
When you open an
image in Photoshop,


831
00:38:07,226 --> 00:38:08,966
what happens behind the scenes?


832
00:38:09,316 --> 00:38:11,576
Photoshop slices and
dices that photo,


833
00:38:11,576 --> 00:38:14,506
no matter how large it is,
into a bunch of small tiles.


834
00:38:15,116 --> 00:38:18,566
Each of those tiles are
values, and the document


835
00:38:18,686 --> 00:38:21,686
that contains the
tiles is also a value.


836
00:38:22,116 --> 00:38:24,686
Then if I make a change, like
change this person's shirt


837
00:38:24,686 --> 00:38:29,686
from purple to green, the
only thing that gets copied


838
00:38:29,686 --> 00:38:33,196
in the two instances of
that diagram are the tiles


839
00:38:33,246 --> 00:38:34,996
that contain the person's shirt.


840
00:38:35,606 --> 00:38:38,306
So even though I have
two distinct documents,


841
00:38:38,386 --> 00:38:42,596
the old state and the new
state, the only new data


842
00:38:42,596 --> 00:38:44,596
that I have had to
consume as a result


843
00:38:44,596 --> 00:38:47,836
of that is the tiles contained
in this person's shirt.


844
00:38:48,486 --> 00:38:52,966
So in summary, we have
talked about value types,


845
00:38:53,036 --> 00:38:55,806
and what great features they
bring to your applications,


846
00:38:55,866 --> 00:38:59,246
compared that to reference types
and showed how value types fix


847
00:38:59,246 --> 00:39:00,376
up some of those issues.


848
00:39:00,906 --> 00:39:03,466
We talked through an example
and saw some cool features


849
00:39:03,466 --> 00:39:05,416
that you can add to
your applications


850
00:39:05,796 --> 00:39:07,046
by using value types.


851
00:39:07,346 --> 00:39:09,356
I look forward to seeing
how those things play


852
00:39:09,356 --> 00:39:10,486
out in your apps.


853
00:39:11,046 --> 00:39:13,696
Some related sessions that
you can catch on video


854
00:39:13,696 --> 00:39:15,456
or if you have time
today at 3:30


855
00:39:15,456 --> 00:39:16,896
for the protocol-oriented talk.


856
00:39:18,406 --> 00:39:21,496
For more information, you can
always email Stephan or go


857
00:39:21,496 --> 00:39:25,156
to our forums, and the
documentation also has


858
00:39:25,186 --> 00:39:26,306
great information.


859
00:39:27,076 --> 00:39:29,526
Thank you very much and I hope
the rest of your WWDC is great.


860
00:39:31,516 --> 00:39:42,900
[ Applause ]

