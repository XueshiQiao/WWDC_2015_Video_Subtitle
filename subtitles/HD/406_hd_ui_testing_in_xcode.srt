
00:00:28.136 --> 00:00:28.656 A:middle
&gt;&gt; WIL TURNER: Good morning.

00:00:29.286 --> 00:00:32.356 A:middle
And welcome to UI
testing in Xcode.

00:00:33.146 --> 00:00:34.046 A:middle
My name is Wil Turner.

00:00:34.636 --> 00:00:35.976 A:middle
With me is Brooke Callahan.

00:00:36.716 --> 00:00:39.626 A:middle
We both work on the
Xcode developer tools.

00:00:40.536 --> 00:00:44.466 A:middle
And I am extremely excited
today because we are sharing

00:00:44.466 --> 00:00:48.506 A:middle
with you a huge expansion
of the testing technology

00:00:48.506 --> 00:00:50.166 A:middle
in the Xcode developer tools.

00:00:51.316 --> 00:00:52.726 A:middle
That is UI testing.

00:00:53.196 --> 00:00:57.986 A:middle
With UI testing you can find
user interface elements,

00:00:58.546 --> 00:01:03.086 A:middle
interact with them, and validate
the UI properties in state.



00:00:58.546 --> 00:01:03.086 A:middle
interact with them, and validate
the UI properties in state.

00:01:04.256 --> 00:01:07.756 A:middle
Along with UI testing, we've
introduced UI recording

00:01:07.896 --> 00:01:10.796 A:middle
which will allow you
to really rapidly set

00:01:10.796 --> 00:01:12.996 A:middle
up UI testing for your projects.

00:01:14.256 --> 00:01:17.806 A:middle
Finally, we've updated
the test reports in Xcode,

00:01:17.806 --> 00:01:21.516 A:middle
which show the pass and fail and
results of your test outcomes,

00:01:21.646 --> 00:01:24.466 A:middle
to accommodate new data
we have with UI testing.

00:01:26.166 --> 00:01:29.106 A:middle
So I want to talk about
the core technologies

00:01:29.386 --> 00:01:31.566 A:middle
for UI testing, the
first is XCTest.

00:01:32.566 --> 00:01:34.616 A:middle
The second is accessibility.

00:01:35.766 --> 00:01:38.606 A:middle
So XCTest is Xcode's
testing framework.

00:01:38.926 --> 00:01:42.506 A:middle
In it, you create subclasses
for your test cases,

00:01:42.856 --> 00:01:46.956 A:middle
you implement test methods, and
you use assertions to validate

00:01:47.036 --> 00:01:49.356 A:middle
that your expected
outcomes are holding true.

00:01:50.676 --> 00:01:55.056 A:middle
XCtest is integrated with Xcode,
which means you get everything

00:01:55.056 --> 00:01:58.536 A:middle
from the ID in terms of
code completion, debugging,

00:01:58.536 --> 00:02:01.216 A:middle
and the ability to run
your tests directly



00:01:58.536 --> 00:02:01.216 A:middle
and the ability to run
your tests directly

00:02:01.306 --> 00:02:04.356 A:middle
from your source code, and
see the results right there.

00:02:05.436 --> 00:02:08.656 A:middle
You also get continuous
integration via Xcode Server

00:02:08.656 --> 00:02:09.576 A:middle
and Xcodebuild.

00:02:10.856 --> 00:02:14.806 A:middle
Finally, XCTest supports
both Swift and Objective-C,

00:02:14.906 --> 00:02:16.966 A:middle
so you can choose the
native coding language

00:02:17.026 --> 00:02:18.786 A:middle
that you're most
comfortable with.

00:02:20.116 --> 00:02:24.196 A:middle
XCTest was introduced in Xcode
5 as a unit testing framework.

00:02:24.376 --> 00:02:28.716 A:middle
In Xcode 6, we expanded it to
support performance testing.

00:02:29.246 --> 00:02:31.776 A:middle
This allows you to catch
regressions in your code,

00:02:31.976 --> 00:02:33.236 A:middle
and ensure that it continues

00:02:33.236 --> 00:02:36.306 A:middle
to perform optimally,
release to release.

00:02:37.106 --> 00:02:40.886 A:middle
Now in Xcode 7, we've introduced
UI testing which you can use

00:02:40.886 --> 00:02:43.086 A:middle
for both correctness
and performance testing.

00:02:44.596 --> 00:02:45.366 A:middle
So that's XCTest.

00:02:46.016 --> 00:02:47.676 A:middle
Now let's take a look
at Accessibility.

00:02:48.576 --> 00:02:51.456 A:middle
Accessibility is the
technology on our platforms,

00:02:51.666 --> 00:02:54.786 A:middle
that gives disabled people
the same great experience

00:02:54.786 --> 00:02:56.716 A:middle
on our devices and
with our applications

00:02:57.056 --> 00:02:58.416 A:middle
that all other users receive.

00:02:59.116 --> 00:03:02.336 A:middle
To make Accessibility
work, it offers a rich set



00:02:59.116 --> 00:03:02.336 A:middle
To make Accessibility
work, it offers a rich set

00:03:02.336 --> 00:03:05.966 A:middle
of semantic data about the UI
that technologies like Voice

00:03:05.966 --> 00:03:08.976 A:middle
Over can use to guide users
through the application.

00:03:09.676 --> 00:03:13.406 A:middle
UI testing uses that, and
Accessibility is integrated

00:03:13.406 --> 00:03:16.536 A:middle
with the UI kit, and app kit,
so, when you use controls

00:03:16.536 --> 00:03:19.516 A:middle
from those frameworks, you get
a lot of accessibility support

00:03:19.786 --> 00:03:21.336 A:middle
for free, right out of the box.

00:03:22.306 --> 00:03:24.206 A:middle
It also provides
APIs that allow you

00:03:24.206 --> 00:03:27.256 A:middle
to fine tune the accessibility
data that is exposed.

00:03:28.646 --> 00:03:31.016 A:middle
The key about this is
that with UI testing,

00:03:31.176 --> 00:03:32.486 A:middle
your tests will interact

00:03:32.926 --> 00:03:34.956 A:middle
with the application
just the way a user does.

00:03:36.636 --> 00:03:38.496 A:middle
UI testing has a
few requirements

00:03:38.646 --> 00:03:39.876 A:middle
that you should understand.

00:03:39.946 --> 00:03:44.236 A:middle
The first is it depends
on new features in the OS.

00:03:44.236 --> 00:03:48.856 A:middle
For iOS you need iOS 9 and
for OS X you need OS 10.11.

00:03:50.746 --> 00:03:52.426 A:middle
UI testing protects
your privacy.

00:03:52.856 --> 00:03:57.126 A:middle
And to do so it means your
iOS devices need to be enabled

00:03:57.126 --> 00:04:02.546 A:middle
for development and connected
to a trusted host running Xcode.



00:03:57.126 --> 00:04:02.546 A:middle
for development and connected
to a trusted host running Xcode.

00:04:03.496 --> 00:04:05.746 A:middle
On OS X you'll need
to grant permission

00:04:05.746 --> 00:04:09.066 A:middle
to a special Xcode helper app,
and you will be prompted to do

00:04:09.066 --> 00:04:12.996 A:middle
so the first time
you run UI tests.

00:04:13.246 --> 00:04:15.946 A:middle
Let's take a look at what
you need to get started

00:04:16.216 --> 00:04:17.486 A:middle
with UI test in your project.

00:04:18.536 --> 00:04:20.826 A:middle
First of all there's a
new Xcode target type.

00:04:21.226 --> 00:04:24.596 A:middle
Traditionally, unit tests were
a specific target type in Xcode,

00:04:24.916 --> 00:04:27.166 A:middle
and now UI tests are
target type as well.

00:04:28.096 --> 00:04:30.876 A:middle
We've also introduced a
large set of set of new APIs

00:04:31.066 --> 00:04:35.486 A:middle
for UI test, and of
course UI recording,

00:04:35.646 --> 00:04:37.936 A:middle
which will really get
you started quickly.

00:04:38.506 --> 00:04:43.856 A:middle
So the Xcode testing targets
support the special requirements

00:04:43.966 --> 00:04:45.016 A:middle
that UI tests have.

00:04:45.416 --> 00:04:47.726 A:middle
This includes executing
in a separate process

00:04:47.726 --> 00:04:49.296 A:middle
from your application
that you are testing.

00:04:49.296 --> 00:04:52.616 A:middle
And it also handles the
permission to use Accessibility

00:04:52.616 --> 00:04:53.736 A:middle
in the privacy protection.

00:04:55.376 --> 00:04:59.346 A:middle
These targets have new templates
for both Cocoa and Cocoa Touch

00:04:59.896 --> 00:05:01.916 A:middle
and the assistant for
these will set everything



00:04:59.896 --> 00:05:01.916 A:middle
and the assistant for
these will set everything

00:05:01.916 --> 00:05:04.156 A:middle
up the way you need
it to get started.

00:05:05.116 --> 00:05:08.196 A:middle
There's a target to be tested
setting for UI test bundles

00:05:08.236 --> 00:05:10.796 A:middle
that identifies the application
that you are testing.

00:05:11.446 --> 00:05:16.486 A:middle
In the new APIs there
are three key classes.

00:05:16.946 --> 00:05:18.376 A:middle
The first is applications.

00:05:19.556 --> 00:05:20.956 A:middle
The second is elements.

00:05:21.106 --> 00:05:23.386 A:middle
And the third is element query.

00:05:23.906 --> 00:05:25.976 A:middle
We will take a deep dive

00:05:25.976 --> 00:05:28.756 A:middle
into these APIs a little bit
later in the presentation.

00:05:30.356 --> 00:05:32.636 A:middle
UI Recording lets you interact

00:05:32.636 --> 00:05:34.886 A:middle
with your application
hands-on your device,

00:05:34.886 --> 00:05:38.346 A:middle
the simulator, or OS X Mac.

00:05:38.636 --> 00:05:42.406 A:middle
While you are doing so, it
generates the code necessary

00:05:42.406 --> 00:05:43.966 A:middle
to recreate those interactions.

00:05:44.536 --> 00:05:50.256 A:middle
You can do this to create new
tests or expand existing tests.

00:05:51.126 --> 00:05:54.446 A:middle
So let's take a look at
what this is all about.

00:05:55.056 --> 00:05:56.696 A:middle
Brooke, let's see a quick demo.

00:05:58.516 --> 00:06:04.276 A:middle
[Applause]



00:05:58.516 --> 00:06:04.276 A:middle
[Applause]

00:06:04.776 --> 00:06:05.116 A:middle
&gt;&gt; BROOKE CALLAHAN: Thanks, Wil.

00:06:05.606 --> 00:06:07.916 A:middle
So, without further ado.

00:06:08.696 --> 00:06:10.246 A:middle
The project I'm going
to be using

00:06:10.246 --> 00:06:12.316 A:middle
for the demo today is
the lister application.

00:06:12.316 --> 00:06:14.486 A:middle
This is an example project
that you can download

00:06:14.486 --> 00:06:15.706 A:middle
from developer.Apple.com.

00:06:16.246 --> 00:06:19.306 A:middle
So, let's get started, now it's
got my target configured just

00:06:19.306 --> 00:06:21.176 A:middle
the way I want, but the one
part I want to point out is

00:06:21.176 --> 00:06:23.656 A:middle
that the target to be tested
is the lister application.

00:06:23.656 --> 00:06:25.006 A:middle
This is the one application

00:06:25.006 --> 00:06:30.826 A:middle
that my tests will be
able to interact with.

00:06:31.036 --> 00:06:35.316 A:middle
So now I've got my
new test class here.

00:06:35.886 --> 00:06:40.476 A:middle
And there's a little stub test
method here and a setup function

00:06:40.616 --> 00:06:43.336 A:middle
which is going to
call, which is going

00:06:43.336 --> 00:06:47.576 A:middle
to launch the application
before my test method is called.

00:06:47.576 --> 00:06:49.786 A:middle
And it's going to do that for
all the test methods I add

00:06:49.786 --> 00:06:50.416 A:middle
to this class.

00:06:51.666 --> 00:06:54.446 A:middle
So Let's add a new test
from the lister app.

00:06:54.646 --> 00:06:59.806 A:middle
I'm going to put the keyboard
cursor in the method and click

00:06:59.806 --> 00:07:04.586 A:middle
on the record button
down the debug bar.



00:06:59.806 --> 00:07:04.586 A:middle
on the record button
down the debug bar.

00:07:04.806 --> 00:07:06.356 A:middle
Now, Xcode is launching
my application.

00:07:06.926 --> 00:07:07.676 A:middle
And here it is.

00:07:08.126 --> 00:07:12.026 A:middle
The lister application allows
me to manage a series of lists.

00:07:12.406 --> 00:07:17.366 A:middle
So probably the most common
thing people do is add

00:07:17.626 --> 00:07:19.136 A:middle
and remove items
from their list.

00:07:19.416 --> 00:07:21.066 A:middle
So I am going to
click here, add item.

00:07:21.496 --> 00:07:23.566 A:middle
It looks like we have a lot

00:07:23.566 --> 00:07:25.886 A:middle
of health some things
in this grocery list.

00:07:25.886 --> 00:07:27.636 A:middle
So I'm going to add cookies.

00:07:27.976 --> 00:07:33.216 A:middle
You can see that, as I'm typing,
the source header is updating.

00:07:33.216 --> 00:07:36.916 A:middle
If I press delete, it also
removes what I removed

00:07:36.916 --> 00:07:37.636 A:middle
from the text field.

00:07:38.666 --> 00:07:45.776 A:middle
Next thing I'm going to do
is tap on the cookies item

00:07:46.026 --> 00:07:47.046 A:middle
to mark it as completed.

00:07:47.586 --> 00:07:49.286 A:middle
And another thing I can do

00:07:49.286 --> 00:07:51.816 A:middle
in this application is
remove items from the list.

00:07:51.816 --> 00:07:55.366 A:middle
So I'll click on edit,
and then delete cookies,

00:07:55.836 --> 00:07:58.296 A:middle
and the delete confirmation
button, and finally done.

00:07:59.406 --> 00:08:01.976 A:middle
Great. Now I have a
simple test that adds



00:07:59.406 --> 00:08:01.976 A:middle
Great. Now I have a
simple test that adds

00:08:01.976 --> 00:08:03.546 A:middle
and removes an item
from the list.

00:08:03.546 --> 00:08:04.876 A:middle
So I'll click stop.

00:08:05.796 --> 00:08:06.646 A:middle
Let's see that in action.

00:08:14.686 --> 00:08:18.026 A:middle
It added the cookies
and it is removing it.

00:08:18.726 --> 00:08:19.216 A:middle
And we are done.

00:08:20.516 --> 00:08:27.316 A:middle
[Applause]

00:08:27.816 --> 00:08:30.626 A:middle
Thanks. As the test
interacts with UI elements,

00:08:30.626 --> 00:08:33.586 A:middle
we get implicit validation
that those UI elements exist.

00:08:33.905 --> 00:08:36.166 A:middle
But What we don't
get validation of,

00:08:36.265 --> 00:08:38.145 A:middle
are things like state
changes in the application.

00:08:38.265 --> 00:08:40.856 A:middle
For example, when we tapped
on that cookies button,

00:08:41.166 --> 00:08:43.866 A:middle
we don't get any
validation that the state

00:08:43.866 --> 00:08:45.166 A:middle
of the button actually changed.

00:08:46.436 --> 00:08:49.696 A:middle
And later on in the
test, when it taps

00:08:49.696 --> 00:08:52.436 A:middle
on the delete confirmation
button,

00:08:52.856 --> 00:08:55.616 A:middle
we know that the delete
confirmation button was tapped.

00:08:56.036 --> 00:08:58.936 A:middle
but running the test
doesn't validate

00:08:58.936 --> 00:09:01.356 A:middle
that the cookies row
actually is removed.



00:08:58.936 --> 00:09:01.356 A:middle
that the cookies row
actually is removed.

00:09:02.406 --> 00:09:04.846 A:middle
So to get validation
of those for my test,

00:09:04.846 --> 00:09:07.126 A:middle
I want to add some
explicit assertions.

00:09:07.156 --> 00:09:11.636 A:middle
First thing I am going
to do is add an assertion

00:09:11.676 --> 00:09:15.726 A:middle
that the cookies button here
actually changes its state.

00:09:15.806 --> 00:09:17.676 A:middle
To do that, I will
add a new constant.

00:09:17.676 --> 00:09:19.706 A:middle
Call this let cookies button.

00:09:20.376 --> 00:09:27.436 A:middle
I'm going to change the test
to tap on that constant.

00:09:27.436 --> 00:09:31.196 A:middle
Now, to add the assertion I
need some state, some properties

00:09:31.196 --> 00:09:35.256 A:middle
of the element to assert on.

00:09:35.616 --> 00:09:38.386 A:middle
And cookies button
is XUI element

00:09:39.036 --> 00:09:41.456 A:middle
and XUI elements have
a value property.

00:09:41.966 --> 00:09:43.836 A:middle
What I'm going to do, is I'm
going to set a breakpoint here,

00:09:44.706 --> 00:09:52.676 A:middle
and run the test to that point.

00:09:53.056 --> 00:09:54.926 A:middle
So here we have the
test in the state

00:09:54.926 --> 00:09:56.646 A:middle
where it's added
the cookies row.

00:09:57.416 --> 00:09:59.396 A:middle
And it has yet to
tap on that button.

00:09:59.456 --> 00:10:03.316 A:middle
So I'm going to go
in the debugger,



00:09:59.456 --> 00:10:03.316 A:middle
So I'm going to go
in the debugger,

00:10:03.926 --> 00:10:08.166 A:middle
and print out the value
of this cookies button.

00:10:08.166 --> 00:10:08.996 A:middle
Little typo.

00:10:13.716 --> 00:10:17.186 A:middle
-- there we go.

00:10:17.606 --> 00:10:28.566 A:middle
I can see that the value of the
cookies button is the string

00:10:28.916 --> 00:10:30.046 A:middle
with the number zero in it.

00:10:32.006 --> 00:10:34.516 A:middle
Next I'm going to
step over that line.

00:10:34.696 --> 00:10:36.056 A:middle
So now it's tap the
cookies button.

00:10:36.146 --> 00:10:41.126 A:middle
I will print out the value
of it again and now I can see

00:10:41.126 --> 00:10:43.886 A:middle
that the value of the button is
the string with the number one.

00:10:44.436 --> 00:10:46.166 A:middle
Great. So now I have all
the information that I need

00:10:46.446 --> 00:10:51.436 A:middle
to assert that the value of the
button changes when it's tapped.

00:10:51.576 --> 00:10:56.416 A:middle
So I'm going to add an assertion
using XCT assert equal.

00:10:56.416 --> 00:11:02.296 A:middle
I'll assert that the value



00:10:56.416 --> 00:11:02.296 A:middle
I'll assert that the value

00:11:02.296 --> 00:11:04.756 A:middle
after the tap is a string
with the number one.

00:11:05.196 --> 00:11:07.526 A:middle
The value is in any object.

00:11:07.586 --> 00:11:11.546 A:middle
So I am going to need to
assert that this is a string.

00:11:11.956 --> 00:11:13.586 A:middle
So I'll use as string.

00:11:13.586 --> 00:11:18.326 A:middle
And assert that it's
number one after the tap.

00:11:19.006 --> 00:11:21.846 A:middle
And I'll assert that
it is the number string

00:11:21.846 --> 00:11:25.716 A:middle
with the number zero
before the tap.

00:11:25.716 --> 00:11:30.926 A:middle
And lastly, after the delete
confirmation button is tapped I

00:11:30.926 --> 00:11:34.336 A:middle
want to assert that that
cookies row goes away.

00:11:34.336 --> 00:11:36.816 A:middle
I'll call XCT assert
equal and assert

00:11:37.136 --> 00:11:38.876 A:middle
that the button no
longer exists.

00:11:43.636 --> 00:11:46.406 A:middle
Now iIf I run this test again we
should see it does all the same

00:11:46.406 --> 00:11:48.176 A:middle
thing but also passing
these assertions.

00:11:57.516 --> 00:12:00.626 A:middle
Great, so now I have
just added my first test.



00:11:57.516 --> 00:12:00.626 A:middle
Great, so now I have
just added my first test.

00:12:01.936 --> 00:12:02.436 A:middle
Back to you, Wil.

00:12:03.516 --> 00:12:09.446 A:middle
[Applause]

00:12:09.946 --> 00:12:10.946 A:middle
&gt;&gt; WIL TURNER: That
was pretty awesome.

00:12:10.946 --> 00:12:13.446 A:middle
You can see just how easily
Brooke took an existing

00:12:13.446 --> 00:12:16.836 A:middle
application and used it,
just like he would as a user,

00:12:17.426 --> 00:12:19.816 A:middle
and in a handful of
minutes he created a test.

00:12:20.226 --> 00:12:22.676 A:middle
He could expand that
test using XCT assert

00:12:22.676 --> 00:12:27.136 A:middle
to do some additional validation
and he just added reliability

00:12:27.136 --> 00:12:29.256 A:middle
to his project with
minimal effort.

00:12:29.916 --> 00:12:32.846 A:middle
That's pretty exciting.

00:12:33.216 --> 00:12:36.376 A:middle
So you can see we added
UI testing target,

00:12:36.736 --> 00:12:38.926 A:middle
very straightforward just like
all our other other targets,

00:12:38.926 --> 00:12:40.426 A:middle
with an assistant and templates.

00:12:41.406 --> 00:12:46.636 A:middle
Used recording, interacted with
the app, and it creates the code

00:12:46.636 --> 00:12:49.206 A:middle
that uses the elements
and synthesizes the events

00:12:49.296 --> 00:12:53.446 A:middle
and then the additional
validation with XCT assert.

00:12:55.696 --> 00:12:58.856 A:middle
Let's take a look at
this UI testing API.



00:13:00.586 --> 00:13:02.596 A:middle
I mentioned earlier that
there are three classes.

00:13:02.846 --> 00:13:05.436 A:middle
They are XCUIApplication,

00:13:05.666 --> 00:13:09.466 A:middle
XCUIElement, and
XCUIElementQuery.

00:13:10.166 --> 00:13:10.816 A:middle
How do they work?

00:13:11.586 --> 00:13:14.606 A:middle
Let's start with a very
simple, something even simpler

00:13:14.956 --> 00:13:16.686 A:middle
than Brooke's example.

00:13:17.276 --> 00:13:21.076 A:middle
Line-by-line going through here
first I am instantiating my

00:13:21.076 --> 00:13:22.126 A:middle
application object.

00:13:22.126 --> 00:13:24.856 A:middle
This is a proxy for
my application.

00:13:25.606 --> 00:13:26.406 A:middle
Then I launch it.

00:13:26.866 --> 00:13:27.936 A:middle
That brings it up for me.

00:13:29.376 --> 00:13:32.646 A:middle
And then I use element and
query to find the add button.

00:13:33.756 --> 00:13:36.976 A:middle
And then I synthesize the
event that taps on it.

00:13:36.976 --> 00:13:40.156 A:middle
Finally, I add in an
assertion just like Brooke did

00:13:40.596 --> 00:13:43.016 A:middle
to make sure that the UI
had the expected state

00:13:43.156 --> 00:13:45.416 A:middle
at the end of the test.

00:13:46.166 --> 00:13:48.916 A:middle
So I mentioned that
UIApplication is a proxy

00:13:49.006 --> 00:13:50.246 A:middle
for the tested application.

00:13:51.206 --> 00:13:54.126 A:middle
It is independent of the
lifecycle of the launch

00:13:54.126 --> 00:13:55.866 A:middle
and termination lifecycle
of your app.

00:13:56.256 --> 00:13:58.316 A:middle
Because Your tests are
running in a separate process.

00:13:58.756 --> 00:14:01.586 A:middle
You get explicit control
over when the app is launched



00:13:58.756 --> 00:14:01.586 A:middle
You get explicit control
over when the app is launched

00:14:01.926 --> 00:14:06.466 A:middle
and when it is terminated.

00:14:06.466 --> 00:14:09.976 A:middle
When you launch we will
always spawn a new process.

00:14:10.246 --> 00:14:13.006 A:middle
So that's something
we do to kind

00:14:13.006 --> 00:14:17.076 A:middle
of not give you completely Clean
Slate because you have a lot

00:14:17.076 --> 00:14:19.586 A:middle
of state in your application
that it's up to you to control.

00:14:19.976 --> 00:14:23.016 A:middle
But by launching a
process clean each time,

00:14:23.316 --> 00:14:25.956 A:middle
we help you minimize the number
of variables that you have

00:14:25.996 --> 00:14:26.826 A:middle
to deal with in your test.

00:14:27.916 --> 00:14:29.556 A:middle
So if it's already running,

00:14:29.716 --> 00:14:32.746 A:middle
calling launch will terminate
the previous existing instance.

00:14:34.776 --> 00:14:38.466 A:middle
Application is also the starting
point for finding elements.

00:14:38.966 --> 00:14:40.266 A:middle
Let's talk about elements.

00:14:40.926 --> 00:14:44.906 A:middle
XCUIElement, just like
Application, is a proxy object,

00:14:45.226 --> 00:14:47.456 A:middle
but this time for user
interface elements

00:14:47.646 --> 00:14:48.906 A:middle
in the tested application.

00:14:49.596 --> 00:14:50.826 A:middle
Elements have types.

00:14:51.476 --> 00:14:54.196 A:middle
Types are like button, or
cell, or window, and so forth.

00:14:54.326 --> 00:14:58.536 A:middle
They have what we call
identifiers, strings of data

00:14:58.536 --> 00:15:00.316 A:middle
that we get from the
accessibility system,



00:14:58.536 --> 00:15:00.316 A:middle
that we get from the
accessibility system,

00:15:00.906 --> 00:15:04.376 A:middle
hich are an identifier or
label or title, so forth.

00:15:05.886 --> 00:15:08.656 A:middle
Most of the time you'll find
elements using a combination

00:15:08.656 --> 00:15:10.206 A:middle
of the type and the label.

00:15:10.206 --> 00:15:12.276 A:middle
For example, if you have
a bullton which is add,

00:15:12.276 --> 00:15:16.786 A:middle
you'll look for the button
type with the identifier add.

00:15:17.496 --> 00:15:20.436 A:middle
Elements form a hierarchy
in your application.

00:15:20.496 --> 00:15:22.996 A:middle
The application is
the root of a tree.

00:15:23.296 --> 00:15:25.636 A:middle
If you think back to your
computer science days you'll

00:15:25.636 --> 00:15:26.916 A:middle
remember tree data structures.

00:15:27.716 --> 00:15:33.026 A:middle
With the lister application we
have this very simple tree here

00:15:33.026 --> 00:15:35.036 A:middle
with the application
at the top and we have

00:15:35.036 --> 00:15:39.816 A:middle
like the nav bar
and the add button.

00:15:39.876 --> 00:15:40.946 A:middle
Groceries label.

00:15:41.076 --> 00:15:42.116 A:middle
So on and so forth.

00:15:42.696 --> 00:15:44.546 A:middle
So each of these is an element

00:15:45.266 --> 00:15:47.376 A:middle
that you can reference
in your tests.

00:15:48.056 --> 00:15:50.196 A:middle
These are used by queries.

00:15:50.666 --> 00:15:53.466 A:middle
This hierarchy, as well
as type and identifier,

00:15:53.626 --> 00:15:54.616 A:middle
to find your elements.

00:15:56.376 --> 00:15:58.046 A:middle
Elements, when you
work with them

00:15:58.046 --> 00:16:00.166 A:middle
in your test, must be unique.



00:15:58.046 --> 00:16:00.166 A:middle
in your test, must be unique.

00:16:00.876 --> 00:16:01.726 A:middle
So what does that mean?

00:16:02.156 --> 00:16:04.666 A:middle
Well, every one of these
elements is backed by a query.

00:16:05.006 --> 00:16:07.856 A:middle
The query has to resolve
to a single instance.

00:16:09.206 --> 00:16:11.746 A:middle
Otherwise when we go to
synthesize the events

00:16:11.746 --> 00:16:14.406 A:middle
that you tell us to tap but
there's multiple buttons

00:16:14.406 --> 00:16:16.596 A:middle
that match that, it
is not deterministic.

00:16:16.596 --> 00:16:18.686 A:middle
We can't really know what
you mean for us to do.

00:16:19.086 --> 00:16:22.486 A:middle
Similarly, if you ask us for
a property of the element,

00:16:22.976 --> 00:16:25.946 A:middle
we don't know which one
did you really mean?

00:16:25.946 --> 00:16:27.166 A:middle
Maybe there wasn't one at all.

00:16:27.626 --> 00:16:29.706 A:middle
So it's important to the
queries for the elements

00:16:29.706 --> 00:16:31.906 A:middle
to resolve to exactly one match.

00:16:33.106 --> 00:16:36.636 A:middle
If they don't, when you access
the element we'll raise a

00:16:36.636 --> 00:16:37.376 A:middle
failure for that.

00:16:38.306 --> 00:16:40.166 A:middle
There is one exception to this,

00:16:40.266 --> 00:16:44.086 A:middle
which is an API called the
exists property on XCUIElement.

00:16:44.626 --> 00:16:48.186 A:middle
This allows you to test for the
existence of the element safely.

00:16:48.756 --> 00:16:50.916 A:middle
You can use this as
Brooke did to verify

00:16:50.916 --> 00:16:52.676 A:middle
that the element had
been removed from the UI

00:16:52.776 --> 00:16:56.086 A:middle
and you can also use
this to handle cases

00:16:56.086 --> 00:16:57.466 A:middle
where you have conditional UI

00:16:57.596 --> 00:16:59.386 A:middle
that might display
in some context.

00:16:59.386 --> 00:17:02.506 A:middle
For example, if you are
saving a file to a location



00:16:59.386 --> 00:17:02.506 A:middle
For example, if you are
saving a file to a location

00:17:02.506 --> 00:17:05.425 A:middle
where another file already
exists, you might get some kind

00:17:05.425 --> 00:17:06.526 A:middle
of confirmation sheet.

00:17:06.945 --> 00:17:08.826 A:middle
That wouldn't be
present all the time.

00:17:08.826 --> 00:17:10.476 A:middle
Just the case where
there's these conflicts.

00:17:10.476 --> 00:17:13.826 A:middle
You can use an exist
check for those cases.

00:17:15.126 --> 00:17:18.256 A:middle
Elements are where event
synthesis APIs live.

00:17:18.886 --> 00:17:22.736 A:middle
Event synthesis is how we
simulate user interaction,

00:17:22.736 --> 00:17:26.165 A:middle
and do this at the lowest level
of the system so everything goes

00:17:26.165 --> 00:17:29.796 A:middle
through the same channels it
would when the user interacts.

00:17:29.796 --> 00:17:32.486 A:middle
The APIs for event synthesis
are platform-specific

00:17:33.006 --> 00:17:33.986 A:middle
with some exceptions.

00:17:34.576 --> 00:17:37.136 A:middle
We have button click,
for example in OS X

00:17:37.136 --> 00:17:41.796 A:middle
and the corresponding
is button tap on iOS.

00:17:41.796 --> 00:17:44.806 A:middle
We have type text which is
the same on both platforms

00:17:44.806 --> 00:17:48.316 A:middle
and takes a string of text.

00:17:48.856 --> 00:17:53.176 A:middle
XCUIElementQuery is our API
for specifying elements.

00:17:54.136 --> 00:17:58.806 A:middle
Queries resolve to collections
of accessible elements.

00:17:58.806 --> 00:18:01.856 A:middle
They can only find elements that
are visible to Accessibility.



00:17:58.806 --> 00:18:01.856 A:middle
They can only find elements that
are visible to Accessibility.

00:18:02.756 --> 00:18:07.376 A:middle
And they will resolve
to a set of these.

00:18:07.596 --> 00:18:08.886 A:middle
That means you can
get the number

00:18:08.886 --> 00:18:10.656 A:middle
of matches using
the count property.

00:18:10.656 --> 00:18:15.116 A:middle
And you can also
specify distinct elements

00:18:15.386 --> 00:18:18.156 A:middle
in that set using
subscripting with an identifier

00:18:19.136 --> 00:18:21.076 A:middle
or using an element
at index API.

00:18:21.076 --> 00:18:23.906 A:middle
We will look at these
more in a moment.

00:18:24.436 --> 00:18:26.496 A:middle
So how do queries work?

00:18:27.756 --> 00:18:29.566 A:middle
So I mentioned that
element hierarchy.

00:18:30.426 --> 00:18:34.016 A:middle
So the relationships in
that hierarchy are one side

00:18:34.016 --> 00:18:34.916 A:middle
of how queries work.

00:18:35.126 --> 00:18:36.816 A:middle
The other side is by filtering.

00:18:37.836 --> 00:18:40.456 A:middle
Filtering is taking
one set and reducing

00:18:40.456 --> 00:18:42.996 A:middle
that set according
to certain criteria.

00:18:44.416 --> 00:18:48.206 A:middle
With our lister example again
here is how we might express

00:18:48.206 --> 00:18:51.276 A:middle
certain relationships, the
first of which is descendants.

00:18:51.276 --> 00:18:54.076 A:middle
In this case I'm
showing the view.

00:18:54.756 --> 00:18:57.066 A:middle
All the gold cells
are its descendents.

00:18:58.226 --> 00:19:01.366 A:middle
On the other hand children is a
more restrictive relationship.



00:18:58.226 --> 00:19:01.366 A:middle
On the other hand children is a
more restrictive relationship.

00:19:01.366 --> 00:19:04.906 A:middle
It's just the elements that
are directly below the element

00:19:04.906 --> 00:19:05.556 A:middle
you're querying.

00:19:05.626 --> 00:19:08.016 A:middle
So, the table's children
are just the cells.

00:19:08.976 --> 00:19:11.746 A:middle
The final relationship
we use is containment.

00:19:12.176 --> 00:19:14.696 A:middle
This happens to be very
useful when we have cases

00:19:14.696 --> 00:19:17.406 A:middle
where the elements, like the
cells, they don't have a lot

00:19:17.406 --> 00:19:19.576 A:middle
of data that unique
them from each other,

00:19:19.946 --> 00:19:22.116 A:middle
but they contain
elements which are unique.

00:19:22.416 --> 00:19:25.226 A:middle
For example, the first cell
contains the groceries label.

00:19:26.706 --> 00:19:31.106 A:middle
Filtering lets us take
things like the element type,

00:19:32.266 --> 00:19:35.596 A:middle
or its identifiers,
to create queries

00:19:35.846 --> 00:19:37.816 A:middle
that filter a previous query.

00:19:38.396 --> 00:19:41.976 A:middle
We can also do this with
predicates which will allow us

00:19:42.286 --> 00:19:45.316 A:middle
to go beyond the identifiers
to look at the values

00:19:45.646 --> 00:19:47.766 A:middle
or do partial matching
such as "begins with"

00:19:47.766 --> 00:19:50.576 A:middle
and that sort of thing.

00:19:50.576 --> 00:19:54.066 A:middle
We combine relationships and
the filtering in the APIs

00:19:54.136 --> 00:19:57.196 A:middle
and the first of which is
descendantsMatchingType.

00:19:57.286 --> 00:19:59.166 A:middle
You can figure out
what that does.

00:19:59.626 --> 00:20:02.146 A:middle
It find the descendants
that match a certain type.



00:19:59.626 --> 00:20:02.146 A:middle
It find the descendants
that match a certain type.

00:20:02.556 --> 00:20:05.276 A:middle
This turns out to be the
most common query you'll use.

00:20:05.666 --> 00:20:09.106 A:middle
Some examples of this are,
I can find all the buttons

00:20:09.106 --> 00:20:11.566 A:middle
in an application
by calling app,

00:20:12.256 --> 00:20:13.826 A:middle
descendentsMatchingType button.

00:20:15.006 --> 00:20:17.746 A:middle
Similarly I can find
all the cells in a table

00:20:18.206 --> 00:20:21.386 A:middle
by telling the table to give me
descendentsMatchingType cell,

00:20:22.106 --> 00:20:24.116 A:middle
or, another example,
with menu items.

00:20:25.426 --> 00:20:29.076 A:middle
This is such a common query
that we provide convenience API

00:20:29.076 --> 00:20:32.096 A:middle
for every one of these types.

00:20:32.456 --> 00:20:35.836 A:middle
DescendentsMatchingType
buttons, becomes just buttons.

00:20:37.486 --> 00:20:40.326 A:middle
DescendentsMatchingType
cell becomes just cells,

00:20:41.216 --> 00:20:43.136 A:middle
and so on and so forth.

00:20:44.016 --> 00:20:48.216 A:middle
These convenience APIs help
make your tests very expressive

00:20:48.376 --> 00:20:49.346 A:middle
yet concise.

00:20:51.516 --> 00:20:56.036 A:middle
[Applause]

00:20:56.536 --> 00:20:59.036 A:middle
ChildrenMatchingType is
the other combination

00:20:59.036 --> 00:21:00.356 A:middle
of relationships in filtering.



00:20:59.036 --> 00:21:00.356 A:middle
of relationships in filtering.

00:21:01.066 --> 00:21:03.816 A:middle
So in that, that allows
us to differentiate

00:21:03.816 --> 00:21:06.466 A:middle
between descendants, all the
descendants that match a type,

00:21:06.636 --> 00:21:08.796 A:middle
and just those that
match, that are children.

00:21:10.406 --> 00:21:13.696 A:middle
Again the all buttons
example, is app.buttons,

00:21:13.796 --> 00:21:17.086 A:middle
if I want to find just the
buttons that are children

00:21:17.086 --> 00:21:19.156 A:middle
of my nav bar, I
can take my nav bar

00:21:19.156 --> 00:21:20.696 A:middle
and say childrenMatchingType
button.

00:21:21.236 --> 00:21:24.096 A:middle
It is not as common a
query, but there are cases

00:21:24.096 --> 00:21:26.496 A:middle
where it becomes very
useful to differentiate.

00:21:28.016 --> 00:21:29.766 A:middle
Finally, containing type.

00:21:30.366 --> 00:21:34.416 A:middle
This allows us to find elements
by describing their descendants.

00:21:35.306 --> 00:21:37.496 A:middle
So in the example
we have the cells

00:21:37.576 --> 00:21:40.716 A:middle
that are each somewhat
anonymous.

00:21:40.716 --> 00:21:43.076 A:middle
They don't have any
identifying characteristics,

00:21:43.696 --> 00:21:45.756 A:middle
but they do contain
unique labels.

00:21:46.426 --> 00:21:48.316 A:middle
Labels are also known
as static texts.

00:21:49.396 --> 00:21:53.226 A:middle
So here I can form a cell
query which takes the cells

00:21:53.286 --> 00:21:56.206 A:middle
and finds the one that is
containing the type static text

00:21:56.346 --> 00:21:58.166 A:middle
with the identifier groceries.

00:21:58.666 --> 00:21:59.976 A:middle
That will find the
first cell for me.



00:22:00.706 --> 00:22:04.836 A:middle
There's also predicate
variant for this API.

00:22:05.486 --> 00:22:07.056 A:middle
So those are our three APIs

00:22:07.056 --> 00:22:09.306 A:middle
that combine relationships
and filtering.

00:22:09.596 --> 00:22:12.046 A:middle
DescendentsMatchingType,
childrenMatchingType,

00:22:12.556 --> 00:22:15.526 A:middle
containingType, and of course
all the convenience APIs

00:22:15.526 --> 00:22:16.646 A:middle
for descendentsMatchingType.

00:22:18.756 --> 00:22:20.676 A:middle
The other powerful
thing about query is

00:22:20.676 --> 00:22:22.376 A:middle
that they can be
chained together.

00:22:22.746 --> 00:22:26.906 A:middle
So we can take the output of
one query and make it the input

00:22:26.906 --> 00:22:29.556 A:middle
of the next, just like you
would pipe commands together

00:22:29.556 --> 00:22:30.636 A:middle
on a Unix command line.

00:22:31.396 --> 00:22:33.316 A:middle
This is ver powerful,
and lets you build

00:22:33.316 --> 00:22:35.706 A:middle
up very complex queries,
again in a way

00:22:35.706 --> 00:22:37.146 A:middle
that is concise and expressive.

00:22:38.266 --> 00:22:41.496 A:middle
So here we have our
application and I want

00:22:41.496 --> 00:22:43.496 A:middle
to find just the
labels in the table.

00:22:43.996 --> 00:22:44.946 A:middle
So I start with the app.

00:22:45.866 --> 00:22:46.996 A:middle
And then I get the tables.

00:22:47.646 --> 00:22:50.016 A:middle
And I ask for static
texts and I'm done.

00:22:50.166 --> 00:22:51.316 A:middle
I have those three labels.

00:22:53.196 --> 00:22:56.656 A:middle
So queries are sometimes
the end unto themselves.

00:22:56.656 --> 00:22:59.426 A:middle
You want to get the count of
the query and maybe assert

00:22:59.426 --> 00:23:01.236 A:middle
that you have the right
number of items in there.



00:22:59.426 --> 00:23:01.236 A:middle
that you have the right
number of items in there.

00:23:01.586 --> 00:23:04.576 A:middle
But often the goal of a
query is to find an element.

00:23:04.576 --> 00:23:06.886 A:middle
All of our elements
are backed by a query.

00:23:07.346 --> 00:23:10.616 A:middle
To get an element from a
query we provide several

00:23:10.616 --> 00:23:11.436 A:middle
different choices.

00:23:11.756 --> 00:23:14.776 A:middle
The first is subscripting,
which allows us to take a query

00:23:14.776 --> 00:23:17.326 A:middle
and then subscript
using an identifier.

00:23:17.596 --> 00:23:19.176 A:middle
That would give me
back an element

00:23:19.406 --> 00:23:20.576 A:middle
which is the groceries label.

00:23:20.576 --> 00:23:23.826 A:middle
It can also do this
with element and index.

00:23:24.076 --> 00:23:26.586 A:middle
If I have a set, maybe
the rows in the table

00:23:26.586 --> 00:23:27.856 A:middle
and I want to iterate over them.

00:23:27.856 --> 00:23:32.256 A:middle
I could one at a time call
element and index on these.

00:23:32.256 --> 00:23:35.206 A:middle
If I have a query which
I know resolves uniquely,

00:23:35.496 --> 00:23:38.546 A:middle
hat is to a single thing, maybe
I only have one navigation bar

00:23:38.546 --> 00:23:41.346 A:middle
in my application, I can
use the element property

00:23:41.626 --> 00:23:45.506 A:middle
to create a new element
backed by that query.

00:23:46.666 --> 00:23:48.916 A:middle
So when are queries evaluated?

00:23:49.546 --> 00:23:51.396 A:middle
So they are not actually
evaluated just

00:23:51.396 --> 00:23:52.366 A:middle
when you create them.

00:23:52.426 --> 00:23:54.936 A:middle
They are evaluated on-demand
or as they are needed.

00:23:55.686 --> 00:23:59.786 A:middle
This means that with an element,
the query will be evaluated



00:24:00.066 --> 00:24:04.206 A:middle
when you synthesize events
or read property values.

00:24:04.206 --> 00:24:06.516 A:middle
You can create the element
but until you use it,

00:24:06.516 --> 00:24:07.826 A:middle
the query won't be evaluated.

00:24:08.536 --> 00:24:12.106 A:middle
Similarly if you create a query
directly it will be evaluated

00:24:12.106 --> 00:24:15.216 A:middle
when you get the number of
matches or if you call one

00:24:15.216 --> 00:24:16.986 A:middle
of the APIs that
returns all the matches.

00:24:16.986 --> 00:24:19.236 A:middle
It will have to be
evaluated at that point

00:24:20.266 --> 00:24:23.896 A:middle
and we will reevaluate
queries when the UI changes.

00:24:24.216 --> 00:24:27.046 A:middle
So you are always working
with the most current view

00:24:27.046 --> 00:24:30.306 A:middle
of the application rather
than data from ten seconds ago

00:24:30.306 --> 00:24:32.336 A:middle
or two minutes ago, depending
on the length of your test.

00:24:33.946 --> 00:24:36.466 A:middle
So in this way you
can think of queries

00:24:36.466 --> 00:24:38.936 A:middle
and elements being
somewhat similar to URLs.

00:24:39.636 --> 00:24:42.636 A:middle
They are, with a URL
you can create a URL

00:24:42.636 --> 00:24:44.876 A:middle
but it doesn't fetch a
resource immediately.

00:24:44.876 --> 00:24:48.386 A:middle
It is not until you actually
go to create your URL request

00:24:48.386 --> 00:24:52.386 A:middle
or session that the
actual URL gets resolved.

00:24:52.866 --> 00:24:55.216 A:middle
And so even if the
URL was invalid,

00:24:55.406 --> 00:24:57.816 A:middle
no error would be
raised until that point.

00:24:58.746 --> 00:25:03.406 A:middle
Similarly, queries and elements,
they are just specifications



00:24:58.746 --> 00:25:03.406 A:middle
Similarly, queries and elements,
they are just specifications

00:25:03.576 --> 00:25:06.136 A:middle
for accessible elements
in the tested application.

00:25:06.876 --> 00:25:11.746 A:middle
So creating them doesn't do
anything until you need them

00:25:11.866 --> 00:25:13.436 A:middle
and at that point
they are resolved.

00:25:14.126 --> 00:25:16.706 A:middle
So that's the API.

00:25:17.736 --> 00:25:20.376 A:middle
There's three classes:
The application

00:25:20.376 --> 00:25:23.306 A:middle
for launching your
application; elements,

00:25:23.736 --> 00:25:26.736 A:middle
which like the application
are proxy objects for elements

00:25:26.736 --> 00:25:29.366 A:middle
in your app; and
finally queries,

00:25:29.696 --> 00:25:32.586 A:middle
which are more complex
ways to specify elements.

00:25:34.356 --> 00:25:36.036 A:middle
So now I want to
talk a little bit

00:25:36.036 --> 00:25:37.936 A:middle
about Accessibility
and UI testing.

00:25:38.396 --> 00:25:39.336 A:middle
I mentioned earlier

00:25:39.646 --> 00:25:43.076 A:middle
that accessibility data is
what makes UI testing possible.

00:25:44.596 --> 00:25:48.856 A:middle
So given that, it is not
hard to see how the quality

00:25:49.116 --> 00:25:53.356 A:middle
of the accessibility data
really impacts your testing.

00:25:53.706 --> 00:25:55.556 A:middle
In fact, the better
the accessibility data

00:25:55.556 --> 00:25:58.316 A:middle
for your application, the
easier it is to write tests

00:25:58.316 --> 00:26:01.506 A:middle
and the more reliable
those tests are over time.



00:25:58.316 --> 00:26:01.506 A:middle
and the more reliable
those tests are over time.

00:26:02.136 --> 00:26:05.296 A:middle
So you get a double benefit

00:26:05.296 --> 00:26:07.236 A:middle
when you improve
the accessibility

00:26:07.236 --> 00:26:08.156 A:middle
in your application.

00:26:08.836 --> 00:26:11.086 A:middle
You've not only made it
easier for your own testing

00:26:11.296 --> 00:26:13.376 A:middle
but you've improved
the experience for all

00:26:13.376 --> 00:26:14.506 A:middle
of our disabled users.

00:26:14.916 --> 00:26:17.786 A:middle
I would really encourage you to
keep that in mind when you work

00:26:17.786 --> 00:26:19.346 A:middle
with UI testing and
accessibility.

00:26:21.436 --> 00:26:23.316 A:middle
Sometimes up's need
to do some debugging.

00:26:23.876 --> 00:26:27.536 A:middle
It's an element may not be
accessible, may not be showing

00:26:27.536 --> 00:26:29.576 A:middle
up for you even when
you are using recording.

00:26:30.456 --> 00:26:32.886 A:middle
That could be because of
the custom view subclass

00:26:32.956 --> 00:26:34.816 A:middle
that may not be accessible
by default.

00:26:35.526 --> 00:26:38.076 A:middle
Or it's actually not a view.

00:26:38.256 --> 00:26:41.526 A:middle
It's a graphics object in a
lower level graphics subsystem

00:26:41.526 --> 00:26:43.576 A:middle
such as a layer and
that sort of thing.

00:26:44.686 --> 00:26:46.636 A:middle
In other cases, the
element is visible

00:26:46.636 --> 00:26:49.026 A:middle
but has poor accessibility data.

00:26:49.356 --> 00:26:50.976 A:middle
All those table cells
I was looking

00:26:51.076 --> 00:26:54.756 A:middle
at in the containment query,
partly that might have gone away

00:26:54.756 --> 00:26:57.356 A:middle
if the cells themselves had
better accessibility data.

00:26:58.476 --> 00:27:00.816 A:middle
When this happens, there's
a couple tools I would point



00:26:58.476 --> 00:27:00.816 A:middle
When this happens, there's
a couple tools I would point

00:27:00.816 --> 00:27:01.106 A:middle
you at.

00:27:01.396 --> 00:27:04.006 A:middle
The first of which is
UI recording itself

00:27:04.286 --> 00:27:06.796 A:middle
because UI recording will
give you the closest view

00:27:07.106 --> 00:27:09.986 A:middle
into how the testing
system sees the elements.

00:27:10.416 --> 00:27:13.366 A:middle
But beyond that there's also
great accessibility inspectors

00:27:13.366 --> 00:27:14.126 A:middle
on our platform.

00:27:14.426 --> 00:27:17.156 A:middle
They'll let you see the
raw accessibility data

00:27:17.456 --> 00:27:19.456 A:middle
as it is exposed
by the application.

00:27:20.046 --> 00:27:23.576 A:middle
When you need to go
and improve that data,

00:27:24.066 --> 00:27:25.996 A:middle
your first stop should
be Interface Builder.

00:27:26.606 --> 00:27:31.076 A:middle
Interface Builder has a
great accessibility inspector

00:27:31.506 --> 00:27:34.106 A:middle
which allows you to enable
or disable accessibility,

00:27:34.366 --> 00:27:37.116 A:middle
set values for the various
accessibility attributes,

00:27:37.526 --> 00:27:40.226 A:middle
and configure the traits
which have a direct impact

00:27:40.286 --> 00:27:43.366 A:middle
on how the element is expressed
as a type in UI testing.

00:27:45.126 --> 00:27:47.466 A:middle
There's also API if you're
working with elements

00:27:47.506 --> 00:27:50.316 A:middle
that you can't access
through Interface Builder.

00:27:50.896 --> 00:27:53.676 A:middle
You can use APIs
in NSAccessibility

00:27:53.736 --> 00:27:57.956 A:middle
and UIAccessibility to directly
control how the element is

00:27:57.956 --> 00:27:59.246 A:middle
expressed to Accessibility.

00:27:59.886 --> 00:28:04.386 A:middle
So with that in mind,
let's see another demo.



00:27:59.886 --> 00:28:04.386 A:middle
So with that in mind,
let's see another demo.

00:28:04.856 --> 00:28:05.976 A:middle
This time Brooke
is going to take us

00:28:05.976 --> 00:28:09.456 A:middle
through more complex test
cases and also a little bit

00:28:09.456 --> 00:28:10.656 A:middle
of accessibility debugging.

00:28:11.166 --> 00:28:11.296 A:middle
Brooke?

00:28:11.296 --> 00:28:11.556 A:middle
&gt;&gt; BROOKE CALLAHAN: Thanks, Wil.

00:28:12.516 --> 00:28:19.396 A:middle
[Applause]

00:28:19.896 --> 00:28:22.236 A:middle
&gt;&gt; BROOKE CALLAHAN: So in the
last demo we saw adding a test

00:28:22.236 --> 00:28:27.066 A:middle
that can add and remove
an item from the list.

00:28:27.596 --> 00:28:30.506 A:middle
So while I'm here I would
like to add some more tests

00:28:30.506 --> 00:28:32.006 A:middle
around this area
of user interface.

00:28:32.406 --> 00:28:33.586 A:middle
First I'm going to add a test

00:28:34.106 --> 00:28:37.846 A:middle
that adds multiple
items to the same list.

00:28:38.316 --> 00:28:41.876 A:middle
With this multiple items
with the same name to a list.

00:28:42.586 --> 00:28:45.646 A:middle
So to do that I'm going
to copy this code here

00:28:45.646 --> 00:28:46.536 A:middle
from the last test.

00:28:47.056 --> 00:28:51.926 A:middle
And I'll call this new
test, add to cookies.

00:28:53.036 --> 00:28:54.116 A:middle
I'll just paste that code in.

00:28:55.306 --> 00:28:59.736 A:middle
Great. Now I have a test
that is going to tap

00:28:59.736 --> 00:29:01.746 A:middle
on the groceries label.



00:28:59.736 --> 00:29:01.746 A:middle
on the groceries label.

00:29:02.456 --> 00:29:05.356 A:middle
Next it is going to add the
new cookies item to the list,

00:29:05.756 --> 00:29:08.656 A:middle
and then it is going to
tap on that cookies button

00:29:08.656 --> 00:29:12.146 A:middle
in that item, and verify
that it actually gets

00:29:12.146 --> 00:29:14.256 A:middle
to that tapped state.

00:29:15.126 --> 00:29:16.976 A:middle
So to add the second
item I'm just going

00:29:16.976 --> 00:29:17.856 A:middle
to copy this code here.

00:29:17.856 --> 00:29:23.816 A:middle
And then to verify that the new
button exists and gets tapped,

00:29:24.586 --> 00:29:26.126 A:middle
I'm going to copy that section.

00:29:26.676 --> 00:29:34.406 A:middle
So let's run this test
and see how that works.

00:29:34.606 --> 00:29:35.836 A:middle
Now let's add the first one.

00:29:37.116 --> 00:29:37.626 A:middle
Second one.

00:29:38.786 --> 00:29:40.546 A:middle
Ahh, failed an assertion here.

00:29:40.906 --> 00:29:44.566 A:middle
So on this line here, where
we are getting the value

00:29:44.766 --> 00:29:47.986 A:middle
of the cookies button for
the second time around,

00:29:48.636 --> 00:29:49.996 A:middle
we are actually failing
the assertion.

00:29:50.426 --> 00:29:52.586 A:middle
Looks like it's failing because
multiple matches are found.

00:29:53.036 --> 00:29:55.206 A:middle
I think I have an idea
of what went wrong here.

00:29:56.546 --> 00:30:00.246 A:middle
The way that the cookies
button constant is specified,



00:29:56.546 --> 00:30:00.246 A:middle
The way that the cookies
button constant is specified,

00:30:00.246 --> 00:30:02.646 A:middle
it is just looking for all
the buttons in the table,

00:30:02.736 --> 00:30:05.726 A:middle
and giving me one
that's called cookies.

00:30:06.206 --> 00:30:07.796 A:middle
By this point in the test,

00:30:07.796 --> 00:30:11.226 A:middle
there are two buttons
called cookies in the table.

00:30:11.226 --> 00:30:15.136 A:middle
It will find both of them
and there is not going

00:30:15.136 --> 00:30:17.946 A:middle
to be one value that
the element can return

00:30:17.946 --> 00:30:19.266 A:middle
because there's these
two matches.

00:30:20.236 --> 00:30:23.256 A:middle
Now, I only know that because
I just saw the test running.

00:30:23.686 --> 00:30:27.346 A:middle
Normally you are not going to be
watching your test as it runs.

00:30:28.356 --> 00:30:30.926 A:middle
So we thought we should
provide a way for you

00:30:30.926 --> 00:30:33.956 A:middle
to see what the test looks
like when it last ran

00:30:34.816 --> 00:30:38.126 A:middle
and we've added this information
to the test reports in Xcode.

00:30:39.596 --> 00:30:42.456 A:middle
So if I go to the report
navigator and click

00:30:42.456 --> 00:30:43.686 A:middle
on the most recent test report,

00:30:44.066 --> 00:30:47.366 A:middle
you can see the test
add to cookies test.

00:30:48.336 --> 00:30:51.946 A:middle
If I expand this item, you
can see all of the activities

00:30:51.946 --> 00:30:53.376 A:middle
that happen during the test.

00:30:54.216 --> 00:30:57.056 A:middle
And down here I see this last
find the cookies button item.

00:30:57.326 --> 00:30:58.066 A:middle
There's my failure.

00:30:58.066 --> 00:30:59.156 A:middle
Multiple matches found.

00:30:59.896 --> 00:31:03.626 A:middle
There's also a quick look button
here, where I can look on that



00:30:59.896 --> 00:31:03.626 A:middle
There's also a quick look button
here, where I can look on that

00:31:03.626 --> 00:31:05.746 A:middle
and it will show
me the exact state

00:31:05.746 --> 00:31:07.246 A:middle
of the application
when that happened.

00:31:07.246 --> 00:31:09.516 A:middle
Just like we know
happened, yeah,

00:31:09.516 --> 00:31:10.946 A:middle
there's two rows called cookies.

00:31:11.516 --> 00:31:13.596 A:middle
One of them is tapped and
one of them is not tapped.

00:31:14.516 --> 00:31:18.936 A:middle
[Applause]

00:31:19.436 --> 00:31:21.876 A:middle
&gt;&gt; BROOKE CALLAHAN: I am going
to close that and if I want

00:31:21.876 --> 00:31:23.506 A:middle
to see the complete
assertion failure,

00:31:23.506 --> 00:31:25.426 A:middle
I can go to the log section

00:31:26.506 --> 00:31:32.396 A:middle
and on this line I can
expand the log for that test.

00:31:32.566 --> 00:31:37.326 A:middle
And here we can see the complete
assertion failure showing the

00:31:37.326 --> 00:31:40.176 A:middle
accessibility hierarchy
of both those buttons.

00:31:40.776 --> 00:31:44.366 A:middle
And here on the side I can see
that yeah, there's one button

00:31:44.366 --> 00:31:46.686 A:middle
that is unchecked and
the other one is checked,

00:31:47.666 --> 00:31:49.186 A:middle
just like I expect.

00:31:49.996 --> 00:31:51.436 A:middle
Let's go back and fix that test.

00:31:52.626 --> 00:31:55.656 A:middle
The easiest way for
me to fix this test is

00:31:55.656 --> 00:31:56.556 A:middle
to use recording again.

00:31:57.096 --> 00:31:59.576 A:middle
I'll set a breakpoint on this
line right before the assertion

00:31:59.576 --> 00:32:11.096 A:middle
failure, and run the
test at that point.



00:31:59.576 --> 00:32:11.096 A:middle
failure, and run the
test at that point.

00:32:11.316 --> 00:32:11.586 A:middle
All right.

00:32:11.656 --> 00:32:14.846 A:middle
So now I've got the application
in exactly the state I need it

00:32:14.846 --> 00:32:18.176 A:middle
to be to get the value
of that unchecked button.

00:32:18.326 --> 00:32:20.906 A:middle
All I'm going to do is I'm
going to click on recording,

00:32:20.906 --> 00:32:25.466 A:middle
tap on that button,
and stop recording.

00:32:26.506 --> 00:32:29.416 A:middle
Now I have a way to refer
to that second button.

00:32:30.206 --> 00:32:30.806 A:middle
I'm going to clean this

00:32:30.806 --> 00:32:33.446 A:middle
up by using the table
constant in both.

00:32:33.446 --> 00:32:36.696 A:middle
I'm going to call this
cookies button two,

00:32:36.806 --> 00:32:38.866 A:middle
a new constant in my test.

00:32:45.306 --> 00:32:47.856 A:middle
And now to fix the test
I'm going to change each

00:32:47.856 --> 00:32:49.656 A:middle
of the next three lines
to use that new reference.

00:32:53.476 --> 00:32:56.036 A:middle
And when I run the test again,
we should see that it works.



00:33:06.896 --> 00:33:07.156 A:middle
Great!

00:33:08.516 --> 00:33:13.156 A:middle
[Applause]

00:33:13.656 --> 00:33:13.916 A:middle
All right.

00:33:14.246 --> 00:33:16.636 A:middle
Now I've got one test that
can add and remove an item

00:33:16.636 --> 00:33:18.816 A:middle
from the list and another
test that can add two items

00:33:18.816 --> 00:33:21.456 A:middle
to the same list, and
verify they both exist.

00:33:21.456 --> 00:33:23.226 A:middle
Now I want to build a test

00:33:23.506 --> 00:33:26.296 A:middle
that will remove all
the items from the list.

00:33:26.896 --> 00:33:30.856 A:middle
Once again I'm going
to use recording.

00:33:30.856 --> 00:33:39.516 A:middle
I am going to tap on groceries,
edit, and then I'm going

00:33:39.516 --> 00:33:45.586 A:middle
to remove the apples
row from the test.

00:33:45.756 --> 00:33:46.036 A:middle
All right?

00:33:46.126 --> 00:33:47.256 A:middle
I'll tap stop recording.

00:33:48.026 --> 00:33:53.086 A:middle
So all this much of the test
is pretty much how I want,

00:33:53.646 --> 00:33:57.766 A:middle
but what I want to do is, I
want to make my test agnostic

00:33:57.766 --> 00:33:59.166 A:middle
to the data of the application.

00:33:59.436 --> 00:34:01.766 A:middle
I want it to remove all these
items, but I don't want it



00:33:59.436 --> 00:34:01.766 A:middle
I want it to remove all these
items, but I don't want it

00:34:01.766 --> 00:34:05.246 A:middle
to actually refer to the
items by their labels.

00:34:06.486 --> 00:34:08.286 A:middle
Because that is going to
get kind of wordy here.

00:34:08.716 --> 00:34:14.585 A:middle
So first thing I'm going to
do, you see these tokens here,

00:34:14.585 --> 00:34:20.565 A:middle
the tokens provide multiple ways
to get to the same UI element.

00:34:20.565 --> 00:34:23.846 A:middle
In this case, for that
first delete apples button,

00:34:23.846 --> 00:34:27.815 A:middle
I can get to this by calling
table.button delete apples.

00:34:28.016 --> 00:34:34.056 A:middle
I can be more specific and say
it's the delete apples button

00:34:34.565 --> 00:34:35.676 A:middle
in the cell called apples.

00:34:35.716 --> 00:34:38.146 A:middle
So I'm going to use that.

00:34:38.146 --> 00:34:45.136 A:middle
And I'm going to double click
on it to convert it to text.

00:34:45.136 --> 00:34:48.516 A:middle
So now I've got two rows here

00:34:48.596 --> 00:34:50.985 A:middle
where we are getting the
elements the same way.

00:34:51.275 --> 00:34:55.156 A:middle
What I would like to do is
get the cell simply by index.

00:34:55.156 --> 00:35:00.116 A:middle
I will add a constant called let
cell, table., and set this equal



00:34:55.156 --> 00:35:00.116 A:middle
I will add a constant called let
cell, table., and set this equal

00:35:00.436 --> 00:35:03.456 A:middle
to table.cells elements index.

00:35:03.926 --> 00:35:09.126 A:middle
Since the apples row was index
one, I'm going to use that.

00:35:09.506 --> 00:35:17.406 A:middle
I can simply replace these with
the reference to that constant.

00:35:17.406 --> 00:35:17.586 A:middle
All right.

00:35:17.586 --> 00:35:18.406 A:middle
I'm almost done.

00:35:19.536 --> 00:35:22.486 A:middle
The next part I need to change
here is how I'm getting the

00:35:22.486 --> 00:35:25.836 A:middle
button out of the cell because
the other rows are not going

00:35:25.986 --> 00:35:27.296 A:middle
to have a delete apples button.

00:35:27.296 --> 00:35:29.906 A:middle
They will have a delete
oranges button or delete bread.

00:35:30.276 --> 00:35:33.306 A:middle
What I need is a way
to find the button

00:35:33.846 --> 00:35:35.946 A:middle
where the label starts
with the word delete.

00:35:36.626 --> 00:35:41.806 A:middle
To do that I'm going
to use a predicate.

00:35:41.886 --> 00:35:45.706 A:middle
So here I'm using
matching predicate

00:35:45.836 --> 00:35:49.506 A:middle
to find the button whose label
begins with the word delete.

00:35:49.506 --> 00:35:50.226 A:middle
All right.

00:35:51.096 --> 00:35:54.866 A:middle
So the last thing I
need to change here,

00:35:54.986 --> 00:35:56.776 A:middle
I want to add an
assertion just like before.

00:35:56.836 --> 00:35:59.106 A:middle
I want to verify that
that cell goes away

00:35:59.106 --> 00:36:00.566 A:middle
after we've removed it.



00:35:59.106 --> 00:36:00.566 A:middle
after we've removed it.

00:36:00.566 --> 00:36:02.656 A:middle
I am going to use
XCTAssertEqual,

00:36:02.656 --> 00:36:06.676 A:middle
and assert that the cells
exist property returns false

00:36:06.676 --> 00:36:09.136 A:middle
after we tap that delete
confirmation button.

00:36:09.136 --> 00:36:11.756 A:middle
I'm going to run the test now.

00:36:12.436 --> 00:36:26.176 A:middle
It is removing the apples
row but failed the assertion.

00:36:26.736 --> 00:36:28.886 A:middle
I have an idea what
might be going on here.

00:36:30.456 --> 00:36:33.506 A:middle
To show you what is going
on I'll use the debugger.

00:36:33.606 --> 00:36:36.216 A:middle
I'll set a breakpoint here
and run the test again,

00:36:36.256 --> 00:36:44.946 A:middle
to that same breakpoint.

00:36:45.296 --> 00:36:45.596 A:middle
All right.

00:36:45.656 --> 00:36:48.876 A:middle
Now in the debugger, I'm going

00:36:48.876 --> 00:36:50.636 A:middle
to call debug description
on the cell.

00:36:58.556 --> 00:37:01.826 A:middle
So the debug description
has a lot of information



00:36:58.556 --> 00:37:01.826 A:middle
So the debug description
has a lot of information

00:37:01.826 --> 00:37:03.906 A:middle
about how the cell
is actually resolved.

00:37:04.376 --> 00:37:07.116 A:middle
So I can see here
that when I call it,

00:37:07.886 --> 00:37:10.646 A:middle
this cell result first
finds the application

00:37:12.776 --> 00:37:16.046 A:middle
and then it finds the
table in the application.

00:37:17.296 --> 00:37:18.306 A:middle
Then all the cells.

00:37:18.306 --> 00:37:21.946 A:middle
And then the element and
index in those cells.

00:37:22.596 --> 00:37:24.816 A:middle
I can see that it's actually
finding the oranges row.

00:37:25.966 --> 00:37:28.016 A:middle
It looks like what might
be happening here is

00:37:29.196 --> 00:37:34.886 A:middle
when we call the exist property
on this element called cell,

00:37:35.696 --> 00:37:37.526 A:middle
it is actually re-resolving
itself.

00:37:37.866 --> 00:37:41.096 A:middle
Even though we just
removed the apples row

00:37:41.096 --> 00:37:45.926 A:middle
from the table there's now
a new cell at index one.

00:37:46.836 --> 00:37:49.026 A:middle
So that is no problem.

00:37:50.286 --> 00:37:52.986 A:middle
It just means I need to
use a different way to find

00:37:53.156 --> 00:37:55.456 A:middle
out whether or not
we've removed the row.

00:37:56.026 --> 00:37:57.996 A:middle
So I'm going to add
an assertion,

00:37:58.026 --> 00:37:59.936 A:middle
assert that the number of cells



00:38:00.156 --> 00:38:03.396 A:middle
in the table goes
down at this point.

00:38:03.396 --> 00:38:05.886 A:middle
So I'm going to add a new
constant called "count"

00:38:06.466 --> 00:38:11.576 A:middle
and I'll set this equal to the
count of the cells in the table.

00:38:12.126 --> 00:38:18.356 A:middle
And then I'll simply assert that
that's equal to count minus 1.

00:38:18.356 --> 00:38:22.626 A:middle
Now, the last thing I need
to do, I said this was going

00:38:22.626 --> 00:38:24.346 A:middle
to be a remove all items test.

00:38:24.346 --> 00:38:31.076 A:middle
I'm going to change it to add
a wild loop and simply do this

00:38:31.076 --> 00:38:33.196 A:middle
over and over again as
long as there's more

00:38:33.196 --> 00:38:39.016 A:middle
than one cell in the table.

00:38:39.186 --> 00:38:40.366 A:middle
Let's run that.

00:38:43.576 --> 00:38:49.426 A:middle
So it's removing the
apples row, and oranges.

00:38:55.556 --> 00:38:56.256 A:middle
All right.

00:38:57.516 --> 00:39:04.096 A:middle
[Applause]



00:38:57.516 --> 00:39:04.096 A:middle
[Applause]

00:39:04.596 --> 00:39:07.676 A:middle
&gt;&gt; BROOKE CALLAHAN: Last thing
I would like to do is add a test

00:39:07.816 --> 00:39:10.626 A:middle
to use that color row that
we saw in the edit UI.

00:39:15.216 --> 00:39:20.666 A:middle
And once again I'm going to
use the recorder for this.

00:39:21.386 --> 00:39:23.526 A:middle
I'll tap on groceries and edit.

00:39:24.066 --> 00:39:29.586 A:middle
Now, the color UI here lets me
change the color for a list.

00:39:29.866 --> 00:39:31.316 A:middle
It looks like right
now this list is green.

00:39:31.906 --> 00:39:35.726 A:middle
So I'll try changing it
to red or how about blue?

00:39:37.776 --> 00:39:40.006 A:middle
Okay, so when I tap on
those buttons it looks

00:39:40.006 --> 00:39:42.806 A:middle
like it's not actually
recording what I want.

00:39:42.806 --> 00:39:44.946 A:middle
It looks like it's
recording a tap

00:39:45.266 --> 00:39:47.826 A:middle
on the static text called
color, which you see over here.

00:39:48.566 --> 00:39:51.906 A:middle
So I think what might
be going on here is

00:39:51.906 --> 00:39:54.196 A:middle
that these UI elements
simply might not be visible

00:39:54.196 --> 00:39:54.956 A:middle
to Accessibility.

00:39:54.956 --> 00:39:56.976 A:middle
So I'm going to stop recording,

00:39:56.976 --> 00:40:01.696 A:middle
and I can actually use the
accessibility inspector



00:39:56.976 --> 00:40:01.696 A:middle
and I can actually use the
accessibility inspector

00:40:01.696 --> 00:40:02.616 A:middle
to tell me what's going on.

00:40:03.176 --> 00:40:05.706 A:middle
I'll right click on Xcode and
go to open developer tool,

00:40:05.736 --> 00:40:06.836 A:middle
accessibility inspector.

00:40:08.326 --> 00:40:11.466 A:middle
And the accessibility inspector
provides a lot of information,

00:40:11.466 --> 00:40:15.776 A:middle
but all I want to use it for
is ths shortcut, command S7.

00:40:15.776 --> 00:40:18.716 A:middle
It will highlight the UI
element that's underneath the

00:40:18.716 --> 00:40:19.226 A:middle
mouse cursor.

00:40:19.796 --> 00:40:22.976 A:middle
If I put the mouse cursor

00:40:22.976 --> 00:40:26.126 A:middle
over the word bread here,
and press command F7.

00:40:26.126 --> 00:40:27.336 A:middle
it highlights bread.

00:40:28.006 --> 00:40:31.416 A:middle
If I put it over the
delete bread button,

00:40:31.776 --> 00:40:33.426 A:middle
you can see that
it highlights that.

00:40:35.426 --> 00:40:37.976 A:middle
Now, let's see what happens
if I put the mouse cursor

00:40:37.976 --> 00:40:42.136 A:middle
over this yellow color button.

00:40:42.276 --> 00:40:44.236 A:middle
Aha! So it highlighted
the whole row.

00:40:44.236 --> 00:40:46.916 A:middle
So that pretty much confirms

00:40:46.916 --> 00:40:49.656 A:middle
that this UI element is simply
not visible to accessibility.

00:40:51.096 --> 00:40:52.466 A:middle
Luckily I can actually
change this,

00:40:52.816 --> 00:40:55.306 A:middle
and fix this problem
using the story board.

00:40:55.306 --> 00:41:05.316 A:middle
I'll open the story board now.



00:40:55.306 --> 00:41:05.316 A:middle
I'll open the story board now.

00:41:05.546 --> 00:41:07.866 A:middle
So here I've got the same
buttons in my story board

00:41:09.696 --> 00:41:12.856 A:middle
and if I open the
inspector, here I can see

00:41:12.856 --> 00:41:17.986 A:middle
that these buttons actually have
a class of color tappable view.

00:41:18.276 --> 00:41:19.976 A:middle
I'm familiar with this class.

00:41:19.976 --> 00:41:22.506 A:middle
I know it's actually
not UI button.

00:41:23.116 --> 00:41:24.436 A:middle
It's custom view.

00:41:24.436 --> 00:41:26.566 A:middle
If I go down to the
accessibility part

00:41:26.706 --> 00:41:30.296 A:middle
of the inspector, I can see
it's not enabled for them.

00:41:30.296 --> 00:41:33.626 A:middle
I have gone through and
added labels for them.

00:41:34.276 --> 00:41:37.806 A:middle
To fix this all I need to do
is select all of the buttons.

00:41:37.806 --> 00:41:45.346 A:middle
And then I'll check the enabled
for accessibility check box.

00:41:45.616 --> 00:41:46.816 A:middle
Since they behave like buttons,

00:41:46.816 --> 00:41:48.006 A:middle
I am going to give
these the button trait.

00:41:48.546 --> 00:41:48.706 A:middle
All right?

00:41:51.336 --> 00:41:54.166 A:middle
Now let's run the
application again.



00:42:02.266 --> 00:42:05.806 A:middle
And now I'm going to record
this test one more time.

00:42:06.086 --> 00:42:08.626 A:middle
Tap on groceries and edit.

00:42:09.486 --> 00:42:12.516 A:middle
Then red. And orange.

00:42:12.806 --> 00:42:16.946 A:middle
Yellow, green, blue, and gray.

00:42:17.196 --> 00:42:21.486 A:middle
Great. Now it actually
recorded all those.

00:42:21.646 --> 00:42:23.966 A:middle
I'll stop recording and
let's run it and see

00:42:23.966 --> 00:42:32.996 A:middle
if it can play it back as well.

00:42:32.996 --> 00:42:35.946 A:middle
Great. I've fixed
accessibility in my application.

00:42:36.666 --> 00:42:38.276 A:middle
And I've also made
it more testable.

00:42:38.596 --> 00:42:40.326 A:middle
If I was going to
complete this test,

00:42:41.456 --> 00:42:43.886 A:middle
I would probably add
some assertions to verify

00:42:43.886 --> 00:42:45.246 A:middle
that the state of
these buttons changes.

00:42:45.466 --> 00:42:46.716 A:middle
For now, I'll hand
the stage back to Wil.

00:42:47.516 --> 00:42:53.426 A:middle
[Applause]

00:42:53.926 --> 00:42:55.366 A:middle
&gt;&gt; WIL TURNER: So that's
really quite awesome,

00:42:55.486 --> 00:42:58.916 A:middle
especially just how easy
it was to make this view

00:42:58.916 --> 00:43:01.356 A:middle
that previously a Voice Over
user would have had no luck



00:42:58.916 --> 00:43:01.356 A:middle
that previously a Voice Over
user would have had no luck

00:43:01.356 --> 00:43:04.876 A:middle
with at all and just
with a few quick changes

00:43:04.876 --> 00:43:07.186 A:middle
in interface builder
Brooke was able to make

00:43:07.216 --> 00:43:09.656 A:middle
that both accessible
and UI testable.

00:43:10.266 --> 00:43:15.186 A:middle
So in the demo, some sort
of more advanced UI testing.

00:43:15.186 --> 00:43:17.786 A:middle
You saw he had cases where
he dealt with a conflict

00:43:17.786 --> 00:43:20.906 A:middle
and a query, and how to
correct those queries,

00:43:20.906 --> 00:43:25.296 A:middle
and how to debug it, and also
how he can loop over elements

00:43:25.736 --> 00:43:28.826 A:middle
and validate them, and how you
can use the exists property

00:43:28.826 --> 00:43:32.456 A:middle
and also highlighted how
queries are reevaluated.

00:43:32.696 --> 00:43:35.946 A:middle
They use the criteria that
you created them with.

00:43:35.996 --> 00:43:39.256 A:middle
That specification is
what gets reevaluated.

00:43:39.686 --> 00:43:41.976 A:middle
We used element at index one.

00:43:41.976 --> 00:43:45.056 A:middle
That pointed to the apples
label the first time through.

00:43:45.276 --> 00:43:47.436 A:middle
As soon as that was
gone and the UI changed,

00:43:47.606 --> 00:43:50.866 A:middle
now that was pointing to the
oranges label.And then finally,

00:43:51.576 --> 00:43:52.766 A:middle
how to improve accessibility,

00:43:53.016 --> 00:43:57.526 A:middle
and the rewards are truly
fantastic for doing that.

00:43:58.256 --> 00:44:01.116 A:middle
Brooke also gave you a
peek at the test reports.



00:43:58.256 --> 00:44:01.116 A:middle
Brooke also gave you a
peek at the test reports.

00:44:01.116 --> 00:44:03.826 A:middle
We have done some
work in Xcode 7

00:44:03.906 --> 00:44:07.366 A:middle
to overhaul them for UI testing.

00:44:07.716 --> 00:44:11.096 A:middle
To recap are, the test reports
are where you see the results

00:44:11.096 --> 00:44:12.376 A:middle
for all the tests that ran.

00:44:12.956 --> 00:44:16.336 A:middle
It shows the pass or the
fail, the failure message,

00:44:16.976 --> 00:44:18.266 A:middle
performance metrics

00:44:18.266 --> 00:44:20.296 A:middle
for performance tests
are shown in the reports.

00:44:21.056 --> 00:44:24.236 A:middle
You get the same UI in
XCode and in Xcode server.

00:44:24.366 --> 00:44:26.416 A:middle
It's a consistent
experience regardless

00:44:26.416 --> 00:44:28.946 A:middle
of whether you are looking
at integrations or the run

00:44:28.946 --> 00:44:30.576 A:middle
that you just did on
your local computer.

00:44:31.426 --> 00:44:34.016 A:middle
On Xcode server you also
get per-device results,

00:44:34.016 --> 00:44:36.886 A:middle
because you can have the devices
integrating multiple devices

00:44:36.886 --> 00:44:37.696 A:middle
at the same time.

00:44:38.466 --> 00:44:41.116 A:middle
The additions for UI testing,

00:44:41.536 --> 00:44:43.836 A:middle
we collected additional
data during UI testing,

00:44:43.836 --> 00:44:45.666 A:middle
and this includes screen shots.

00:44:46.316 --> 00:44:50.366 A:middle
You saw how it helped Brooke
debug the conflict in his query

00:44:50.366 --> 00:44:53.066 A:middle
by pulling up the screen shot
at the time that query failed.

00:44:54.096 --> 00:44:59.126 A:middle
Also, we organized the API calls
into these nested activities

00:44:59.126 --> 00:45:02.126 A:middle
that help you understand
how the API call is working.



00:44:59.126 --> 00:45:02.126 A:middle
that help you understand
how the API call is working.

00:45:02.766 --> 00:45:04.636 A:middle
So let's take a look
at an example of this.

00:45:04.986 --> 00:45:06.336 A:middle
This is not the list draft.

00:45:06.336 --> 00:45:07.456 A:middle
It is a different application.

00:45:07.876 --> 00:45:11.106 A:middle
But I'm going to show you
how there are several steps

00:45:11.106 --> 00:45:12.876 A:middle
in the nested activities
breakdown.

00:45:13.596 --> 00:45:15.806 A:middle
This example we're
typing into a test field

00:45:15.806 --> 00:45:18.876 A:middle
so the high level you
call the API type test.

00:45:19.686 --> 00:45:21.206 A:middle
But internally that breaks down.

00:45:21.616 --> 00:45:24.246 A:middle
In the first step where we wait
for the application to idle.

00:45:24.626 --> 00:45:27.136 A:middle
We're actually observing
the main run loop

00:45:27.446 --> 00:45:28.776 A:middle
of the tested application.

00:45:29.126 --> 00:45:31.276 A:middle
Because We don't want
to send events to it,

00:45:31.616 --> 00:45:33.026 A:middle
when it's busy processing.

00:45:33.026 --> 00:45:34.996 A:middle
We want it to be
responsive as possible.

00:45:35.726 --> 00:45:41.186 A:middle
Once it's idled we capture the
data we need from Accessibility

00:45:41.586 --> 00:45:42.846 A:middle
and we resolve the query,

00:45:42.846 --> 00:45:45.066 A:middle
make sure it matches
exactly one thing.

00:45:46.166 --> 00:45:48.616 A:middle
Next step, we synthesize
the actual events

00:45:48.716 --> 00:45:50.646 A:middle
that insert the text
into that field.

00:45:51.616 --> 00:45:55.086 A:middle
Finally, we wait one more time
for the app to idle afterwards.

00:45:55.166 --> 00:45:58.226 A:middle
Because, again, we want to
hand off control in a way

00:45:58.226 --> 00:46:01.446 A:middle
where things are reliable
and deterministic.



00:45:58.226 --> 00:46:01.446 A:middle
where things are reliable
and deterministic.

00:46:01.976 --> 00:46:05.586 A:middle
The quick looks are
provided for screen shots

00:46:05.586 --> 00:46:07.586 A:middle
that are captured
during critical steps.

00:46:07.976 --> 00:46:11.476 A:middle
You can see here is the state
right after I type that text in.

00:46:11.736 --> 00:46:14.326 A:middle
Make sure everything looked
just the way you expected.

00:46:15.196 --> 00:46:19.986 A:middle
So UI testing is obviously
a huge expansion of the kind

00:46:19.986 --> 00:46:22.056 A:middle
of testing you can do
for your applications.

00:46:22.436 --> 00:46:24.046 A:middle
So when do you use it, right?

00:46:24.466 --> 00:46:26.736 A:middle
We've got unit testing already.

00:46:27.116 --> 00:46:30.166 A:middle
UI testing is a complement to
UI testing, not a replacement.

00:46:30.556 --> 00:46:33.536 A:middle
You should continue to use unit
testing for your model objects,

00:46:33.536 --> 00:46:35.196 A:middle
and your controller logic,

00:46:35.536 --> 00:46:38.476 A:middle
because unit testing will more
precisely pinpoint failures

00:46:38.476 --> 00:46:39.506 A:middle
when they happen in your code.

00:46:40.196 --> 00:46:43.446 A:middle
UI testing allows you to
cover much broader ranges

00:46:43.446 --> 00:46:45.726 A:middle
of functionality, but tracking

00:46:45.726 --> 00:46:47.346 A:middle
down the failures can
be more challenging.

00:46:47.736 --> 00:46:51.156 A:middle
It's a balance in your project,
of finding the right blend

00:46:51.186 --> 00:46:53.106 A:middle
between unit testing
and UI testing.

00:46:54.796 --> 00:46:56.726 A:middle
Some great candidates
for UI testing.

00:46:57.216 --> 00:46:58.136 A:middle
Well, think about your app.

00:46:58.186 --> 00:47:00.306 A:middle
You have customers,
you show it to them,



00:46:58.186 --> 00:47:00.306 A:middle
You have customers,
you show it to them,

00:47:00.306 --> 00:47:02.826 A:middle
and you have little demo
sequences that you show to them,

00:47:02.826 --> 00:47:03.776 A:middle
and you walk them
through, "well,

00:47:03.776 --> 00:47:05.006 A:middle
here's how you do
this with the app."

00:47:05.506 --> 00:47:08.656 A:middle
Demo sequences are great
candidates for UI testing.

00:47:08.656 --> 00:47:11.926 A:middle
You'll know nightly
build after nightly build

00:47:12.256 --> 00:47:13.746 A:middle
that those demos are
going to work for you.

00:47:14.636 --> 00:47:17.056 A:middle
Second, beyond that,
common workflows.

00:47:17.646 --> 00:47:20.986 A:middle
What the app is used for,
if it's an editing app,

00:47:21.066 --> 00:47:22.426 A:middle
how you edit the documents.

00:47:22.426 --> 00:47:25.916 A:middle
Any custom views you
have in the application.

00:47:26.526 --> 00:47:29.456 A:middle
And finally document-based
workflows, opening and saving.

00:47:29.756 --> 00:47:31.116 A:middle
These are all great
things to automate.

00:47:31.116 --> 00:47:33.596 A:middle
They are really hard to
capture with unit testing.

00:47:33.976 --> 00:47:36.646 A:middle
When they go wrong they
have a huge impact on users.

00:47:38.756 --> 00:47:40.496 A:middle
So UI testing.

00:47:41.576 --> 00:47:42.706 A:middle
New in XCode 7.

00:47:43.776 --> 00:47:45.606 A:middle
Opens up a world
of possibilities

00:47:45.606 --> 00:47:47.796 A:middle
for how you can test
your applications.

00:47:49.266 --> 00:47:51.916 A:middle
In UI testing you
find and interact

00:47:52.146 --> 00:47:55.256 A:middle
with user interface elements
and you synthesize events

00:47:55.296 --> 00:47:57.996 A:middle
that drives them, just
the way a user does.

00:47:58.986 --> 00:48:01.646 A:middle
You can validate the UI
properties and state.



00:47:58.986 --> 00:48:01.646 A:middle
You can validate the UI
properties and state.

00:48:03.126 --> 00:48:06.616 A:middle
And UI recording lets you
create these tests super quick,

00:48:06.856 --> 00:48:07.646 A:middle
super easy.

00:48:09.196 --> 00:48:11.586 A:middle
Finally, we've overhauled
the test reports

00:48:12.066 --> 00:48:15.566 A:middle
to make you better able to
understand how your tests work

00:48:16.066 --> 00:48:17.666 A:middle
and collect additional
data about them.

00:48:18.666 --> 00:48:19.446 A:middle
So that's UI testing.

00:48:20.516 --> 00:48:27.916 A:middle
[Applause]

00:48:28.416 --> 00:48:30.726 A:middle
&gt;&gt; WIL TURNER: So for more
information we've got great

00:48:30.726 --> 00:48:32.026 A:middle
documentation on XCTest.

00:48:32.236 --> 00:48:35.226 A:middle
You can get to it through Xcode
itself and on our website.

00:48:35.556 --> 00:48:37.866 A:middle
And Accessibility also
has great documentation,

00:48:37.866 --> 00:48:39.056 A:middle
and I encourage you
to check out.

00:48:40.516 --> 00:48:43.286 A:middle
Developer Forums are great
places to raise questions

00:48:43.286 --> 00:48:47.226 A:middle
and trade tips with other users
about how you're using things.

00:48:47.406 --> 00:48:50.346 A:middle
Our evangelist Stefan
Lesser is a great contact

00:48:50.566 --> 00:48:51.506 A:middle
to get you started.

00:48:52.736 --> 00:48:55.546 A:middle
There's some related sessions
if you want to dial back in time

00:48:55.546 --> 00:48:58.036 A:middle
and watch the accessibility
session from yesterday morning,

00:48:58.456 --> 00:49:00.396 A:middle
probably watch the video
on your lunch if you want,



00:48:58.456 --> 00:49:00.396 A:middle
probably watch the video
on your lunch if you want,

00:49:01.056 --> 00:49:04.466 A:middle
and continuous integration and
code coverage, new technology

00:49:04.796 --> 00:49:07.946 A:middle
in Xcode server, you can
see tomorrow afternoon --

00:49:07.946 --> 00:49:08.706 A:middle
tomorrow morning.

00:49:09.096 --> 00:49:09.976 A:middle
Have great conference,
everybody.

00:49:10.516 --> 00:49:13.500 A:middle
[Applause]

