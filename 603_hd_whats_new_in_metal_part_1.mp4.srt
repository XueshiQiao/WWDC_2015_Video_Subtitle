WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:29.036 --> 00:00:31.036 A:middle
[Applause]

00:00:31.056 --> 00:00:31.776 A:middle
&gt;&gt; RAV DHIRAJ: Good afternoon.

00:00:31.776 --> 00:00:33.876 A:middle
Welcome to WWDC 2015.

00:00:34.516 --> 00:00:39.556 A:middle
[Applause]

00:00:40.056 --> 00:00:40.656 A:middle
&gt;&gt; RAV DHIRAJ: And the first

00:00:40.656 --> 00:00:42.766 A:middle
of two What's New
in Metal sessions.

00:00:44.096 --> 00:00:47.036 A:middle
So we have a lot of Metal
content to cover this week

00:00:47.226 --> 00:00:48.546 A:middle
across three sessions.

00:00:48.546 --> 00:00:51.946 A:middle
In fact, we've added so
much new stuff to the API,

00:00:51.976 --> 00:00:54.366 A:middle
that we've decided to
break the What's New

00:00:54.366 --> 00:00:56.456 A:middle
in Metal session into two parts.

00:00:57.046 --> 00:01:01.926 A:middle
So today, I'll be focusing on
providing a high-level review

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.046 --> 00:01:01.926 A:middle
So today, I'll be focusing on
providing a high-level review

00:01:02.206 --> 00:01:05.325 A:middle
of the Metal ecosystem
over the last 12 months.

00:01:06.466 --> 00:01:09.596 A:middle
Developers like you have
already created some tremendous

00:01:09.596 --> 00:01:10.906 A:middle
applications using Metal.

00:01:11.456 --> 00:01:14.536 A:middle
I'll then talk about
some of the new features

00:01:14.846 --> 00:01:17.466 A:middle
that we're introducing
this year, and we'll end

00:01:17.466 --> 00:01:21.036 A:middle
with a specific example of
how Metal integrates well

00:01:21.196 --> 00:01:22.346 A:middle
with the rest of the system

00:01:22.736 --> 00:01:25.356 A:middle
by describing a technology
called app thinning.

00:01:25.936 --> 00:01:31.566 A:middle
In the second what's new in
Metal session, Dan Omachi

00:01:31.566 --> 00:01:34.346 A:middle
and Anna Tikhonova
will provide details

00:01:34.656 --> 00:01:37.776 A:middle
on a great new support
library that we're introducing

00:01:37.776 --> 00:01:41.546 A:middle
in Metal this year or two great
new support libraries rather,

00:01:42.506 --> 00:01:46.566 A:middle
MetalKit which provides
convenience APIs that allow you

00:01:46.566 --> 00:01:48.566 A:middle
to create a great
Metal application,

00:01:49.626 --> 00:01:54.116 A:middle
and Metal Performance Shaders
our highly optimized library

00:01:54.116 --> 00:01:57.876 A:middle
of shaders that you can call
directly from your application.

00:01:58.476 --> 00:02:04.556 A:middle
And finally in the last
session, Phil Bennett will dive

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:58.476 --> 00:02:04.556 A:middle
And finally in the last
session, Phil Bennett will dive

00:02:04.896 --> 00:02:07.196 A:middle
into great techniques for
taking advantage of --

00:02:07.526 --> 00:02:10.106 A:middle
for extracting the best
possible performance

00:02:10.336 --> 00:02:11.686 A:middle
out of your Metal applications.

00:02:13.006 --> 00:02:18.836 A:middle
We'll be introducing our
new GPU System Trace tool

00:02:19.066 --> 00:02:25.146 A:middle
in this session, so be
sure to check it out.

00:02:25.876 --> 00:02:29.706 A:middle
We introduced Metal at
WWDC last year for iOS 8.

00:02:30.456 --> 00:02:35.476 A:middle
Our goal was a ground-up
reimplementation of our graphics

00:02:35.676 --> 00:02:39.656 A:middle
and compute APIs to give you
the best possible performance

00:02:39.816 --> 00:02:41.386 A:middle
on the GPUs in our platform.

00:02:42.386 --> 00:02:46.276 A:middle
So we achieved this by getting
much of the software between you

00:02:46.466 --> 00:02:48.386 A:middle
and the GPU out of your way.

00:02:51.396 --> 00:02:55.356 A:middle
To better illustrate this
let's look back at an example

00:02:55.356 --> 00:02:59.606 A:middle
that we showed last year at WWDC
that describes the work done

00:02:59.606 --> 00:03:02.896 A:middle
by the GPU and The
CPU per frame.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.606 --> 00:03:02.896 A:middle
by the GPU and The
CPU per frame.

00:03:04.236 --> 00:03:07.736 A:middle
In this example the top bar
represents the time spent

00:03:07.736 --> 00:03:12.116 A:middle
by the CPU and the bottom
bar represents the GPU time.

00:03:13.226 --> 00:03:15.876 A:middle
So as you can see, we're
currently CPU bound

00:03:16.246 --> 00:03:19.756 A:middle
and the GPU is idle
for part of the frame.

00:03:21.336 --> 00:03:22.526 A:middle
So with Metal we're able

00:03:22.526 --> 00:03:26.356 A:middle
to dramatically reduce
the GPU API overhead

00:03:26.726 --> 00:03:32.516 A:middle
and effectively make the GPU the
bottleneck in the great frame.

00:03:32.726 --> 00:03:35.556 A:middle
So the great thing is that this
allows you to take advantage

00:03:35.606 --> 00:03:39.626 A:middle
of this additional CPU idle
time to make your game better.

00:03:41.086 --> 00:03:43.706 A:middle
You can add more physics
or AI for example,

00:03:45.056 --> 00:03:47.166 A:middle
or you can issue more draw calls

00:03:47.546 --> 00:03:49.536 A:middle
to increase the complexity
of your scene.

00:03:50.106 --> 00:03:53.386 A:middle
But we didn't just stop there.

00:03:54.296 --> 00:03:57.506 A:middle
Metal also allows you to
move expensive operations

00:03:57.976 --> 00:04:02.386 A:middle
like shader compilation and
state validation from draw time

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:57.976 --> 00:04:02.386 A:middle
like shader compilation and
state validation from draw time

00:04:02.756 --> 00:04:07.106 A:middle
which happens many thousands of
times per frame, to load time

00:04:07.216 --> 00:04:11.306 A:middle
which happens very infrequently,
and even better in some cases

00:04:11.306 --> 00:04:16.326 A:middle
to build time, when your users
don't see any impact at all.

00:04:18.776 --> 00:04:24.876 A:middle
Additionally, with iOS 8 we
not only introduced compute

00:04:24.876 --> 00:04:28.126 A:middle
or exposed compute for the
first time on our iOS devices,

00:04:28.126 --> 00:04:33.806 A:middle
but we also provided you with a
cohesive interoperability story

00:04:34.096 --> 00:04:37.696 A:middle
between the graphics and
compute APIs allowing

00:04:37.696 --> 00:04:41.686 A:middle
to you efficiently interleave
render and compute operations

00:04:41.846 --> 00:04:43.416 A:middle
on Metal capable devices.

00:04:44.156 --> 00:04:51.256 A:middle
And finally, with Metal,
your application is able

00:04:51.326 --> 00:04:53.786 A:middle
to make efficient
use of multithreading

00:04:54.086 --> 00:04:57.306 A:middle
without the API getting
in your way, allowing you

00:04:57.366 --> 00:04:59.466 A:middle
to encode for multiple threads.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.186 --> 00:05:03.536 A:middle
And the results have
been stunning.

00:05:04.596 --> 00:05:10.706 A:middle
So last year we showed
you Epic's Zen Garden demo

00:05:10.936 --> 00:05:13.926 A:middle
where they used Metal to
achieve ten times the number

00:05:13.926 --> 00:05:17.236 A:middle
of draw calls in the scene.

00:05:17.466 --> 00:05:20.876 A:middle
We also showed you EA's Plants
Versus Zombies technology demo

00:05:21.406 --> 00:05:25.016 A:middle
where they used Metal to bring
their console rendering engine

00:05:25.456 --> 00:05:26.896 A:middle
to the iOS platform.

00:05:28.326 --> 00:05:31.016 A:middle
Now this set a high bar for
the development community.

00:05:31.756 --> 00:05:34.566 A:middle
And over the last year
we've witnessed the release

00:05:34.566 --> 00:05:36.466 A:middle
of some truly astounding titles

00:05:36.946 --> 00:05:40.196 A:middle
that have taken great
advantage of the Metal API.

00:05:40.976 --> 00:05:45.336 A:middle
Titles like the MOBA Vainglory
by Super Evil Mega Corp

00:05:46.506 --> 00:05:51.496 A:middle
that used Metal to achieve 60
frames per second in their game.

00:05:51.706 --> 00:05:55.506 A:middle
Disney's Infinity: Toy
Box 2, Metal enabled them

00:05:55.576 --> 00:05:57.936 A:middle
to bring their console,
graphics,

00:05:58.276 --> 00:06:02.446 A:middle
and game play experience to iOS.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.276 --> 00:06:02.446 A:middle
and game play experience to iOS.

00:06:02.616 --> 00:06:07.246 A:middle
Gameloft Asphalt 8, they were
able to improve their gameplay

00:06:07.396 --> 00:06:10.316 A:middle
by using Metal to render
three times the number

00:06:10.346 --> 00:06:11.766 A:middle
of opponents in the game.

00:06:12.346 --> 00:06:15.616 A:middle
But it's not just about games.

00:06:16.856 --> 00:06:18.676 A:middle
With the new version
of Pixelmator

00:06:19.626 --> 00:06:21.956 A:middle
for the iPhone they're
using Metal

00:06:22.226 --> 00:06:23.906 A:middle
to accelerate image processing

00:06:24.016 --> 00:06:26.596 A:middle
in their powerful
new distort tools.

00:06:27.096 --> 00:06:32.966 A:middle
In fact, the response has been
overwhelming, with a number

00:06:32.966 --> 00:06:36.326 A:middle
of key content and game
developers now adopting Metal

00:06:36.516 --> 00:06:38.196 A:middle
on OS X.

00:06:39.046 --> 00:06:42.486 A:middle
And much of this content has
been enabled by our commitment

00:06:42.946 --> 00:06:46.656 A:middle
to bring the leading
game console engines

00:06:46.656 --> 00:06:48.546 A:middle
to the iOS platform.

00:06:49.236 --> 00:06:52.546 A:middle
This includes Unity,
Epic's Unreal Engine 4,

00:06:53.086 --> 00:06:56.756 A:middle
and EA's Frostbite
mobile engine.

00:06:59.936 --> 00:07:04.256 A:middle
Last year we also showed you how
Metal fits in the big picture

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.936 --> 00:07:04.256 A:middle
Last year we also showed you how
Metal fits in the big picture

00:07:04.256 --> 00:07:07.196 A:middle
of how your application
accesses the GPU.

00:07:07.886 --> 00:07:10.986 A:middle
On the one side we
have our high-level 2D

00:07:10.986 --> 00:07:13.466 A:middle
and 3D scene graphs APIs

00:07:13.836 --> 00:07:17.886 A:middle
that give you incredible
functionality and convenience.

00:07:18.156 --> 00:07:20.096 A:middle
And on the other
side with Metal,

00:07:20.566 --> 00:07:23.206 A:middle
we provided a direct
access path to the GPU.

00:07:23.886 --> 00:07:27.466 A:middle
So this gives you an amazing
range to do what's right

00:07:27.466 --> 00:07:31.146 A:middle
for your application, and
if you choose to use one

00:07:31.146 --> 00:07:34.316 A:middle
of the higher level
APIs, the great thing is

00:07:34.316 --> 00:07:36.956 A:middle
that we can make
improvements under the covers

00:07:37.406 --> 00:07:38.866 A:middle
and you can benefit from them

00:07:39.276 --> 00:07:43.536 A:middle
without us changing a
single line of code.

00:07:43.996 --> 00:07:46.046 A:middle
Well this year, we're
happy to announce

00:07:46.046 --> 00:07:49.786 A:middle
that we've done just that,
and we're bringing the power

00:07:49.786 --> 00:07:52.916 A:middle
and efficiency of Metal to
the system-wide technologies.

00:07:53.756 --> 00:07:55.346 A:middle
We really believe
that this is going

00:07:55.346 --> 00:07:57.856 A:middle
to improve the user
experience on our platforms.

00:07:58.526 --> 00:08:05.306 A:middle
This is also a great year
for Metal capable devices.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.526 --> 00:08:05.306 A:middle
This is also a great year
for Metal capable devices.

00:08:06.216 --> 00:08:09.066 A:middle
The iPhone 5s and the iPad
Air were the headliners

00:08:09.066 --> 00:08:14.556 A:middle
at WWDC last year, and with the
introduction of the iPhone 6,

00:08:15.106 --> 00:08:17.726 A:middle
the 6+, and the iPad Air 2,

00:08:17.926 --> 00:08:20.596 A:middle
we now have an incredible
install base

00:08:20.596 --> 00:08:22.106 A:middle
of Metal capable devices.

00:08:22.686 --> 00:08:24.736 A:middle
But of course we
didn't just stop there.

00:08:25.366 --> 00:08:27.576 A:middle
We're happy to announce

00:08:27.836 --> 00:08:34.456 A:middle
that we're bringing Metal
to the OS X platform.

00:08:34.456 --> 00:08:36.135 A:middle
We have broad support for Metal

00:08:36.436 --> 00:08:38.756 A:middle
across all our shipping
configurations.

00:08:39.116 --> 00:08:44.006 A:middle
In fact, Metal is supported on
all Macs introduced since 2012.

00:08:45.066 --> 00:08:46.806 A:middle
This of course means
that we have support

00:08:46.866 --> 00:08:51.516 A:middle
for all three GPU venders:
Intel, AMD, and Nvidia.

00:08:52.126 --> 00:08:57.676 A:middle
And the other big news is that
we're bringing all the tools

00:08:57.676 --> 00:09:00.176 A:middle
that you're familiar
with using on iOS

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:57.676 --> 00:09:00.176 A:middle
that you're familiar
with using on iOS

00:09:00.486 --> 00:09:02.126 A:middle
to the Mac platform as well.

00:09:02.826 --> 00:09:06.736 A:middle
This includes the Frame
Debugger, the Shader Profiler,

00:09:07.096 --> 00:09:09.296 A:middle
and all our API analysis tools.

00:09:09.896 --> 00:09:12.146 A:middle
This is huge.

00:09:12.856 --> 00:09:15.916 A:middle
We understand the challenges
of debugging complex graphics

00:09:15.986 --> 00:09:17.386 A:middle
and compute applications,

00:09:17.876 --> 00:09:19.936 A:middle
and think that these
will be invaluable

00:09:19.936 --> 00:09:21.816 A:middle
in your development
efforts on OS X.

00:09:21.816 --> 00:09:26.636 A:middle
And of course, all of this is
available in the seed build

00:09:26.636 --> 00:09:29.546 A:middle
of OS X El Capitan that
you can download today.

00:09:31.916 --> 00:09:36.286 A:middle
So Metal on OS X is the same
API you're familiar with using

00:09:36.716 --> 00:09:39.566 A:middle
on iOS with a few key additions.

00:09:40.826 --> 00:09:45.626 A:middle
With new APIs to support device
selection, discrete memory,

00:09:45.966 --> 00:09:49.936 A:middle
and new texture formats, Metal
makes it incredibly easy for you

00:09:49.936 --> 00:09:55.136 A:middle
to bring your iOS
applications to OS X.

00:09:55.366 --> 00:09:56.666 A:middle
And here are a few examples

00:09:56.666 --> 00:09:58.656 A:middle
of developers who've
done exactly that.

00:09:59.426 --> 00:10:03.036 A:middle
So you heard in the keynote that
we've been working with Epic

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.426 --> 00:10:03.036 A:middle
So you heard in the keynote that
we've been working with Epic

00:10:03.446 --> 00:10:06.646 A:middle
to bring their iOS
Metal development code

00:10:07.016 --> 00:10:08.546 A:middle
to a Unreal Engine on the Mac.

00:10:09.896 --> 00:10:14.186 A:middle
Well, Epic used Metal and
their deferred renderer

00:10:14.416 --> 00:10:17.516 A:middle
to create this amazing
stylized look in Fortnite.

00:10:19.416 --> 00:10:23.866 A:middle
Additionally folks at Unity
brought up their engine

00:10:24.336 --> 00:10:26.746 A:middle
and demonstrated their
Viking Village demo

00:10:26.986 --> 00:10:28.336 A:middle
in only a few weeks.

00:10:28.916 --> 00:10:32.516 A:middle
It's really great to see this
content on OS X on Metal.

00:10:32.986 --> 00:10:36.276 A:middle
And we've been working
with a number

00:10:36.276 --> 00:10:40.256 A:middle
of additional Mac developers to
enable them to access the power

00:10:40.256 --> 00:10:41.656 A:middle
of the GPU through Metal.

00:10:44.796 --> 00:10:46.576 A:middle
So you also heard in the keynote

00:10:46.706 --> 00:10:49.396 A:middle
about digital content
creation applications.

00:10:50.606 --> 00:10:54.276 A:middle
Developers like Adobe, they're
using Metal to access the GPU

00:10:54.346 --> 00:10:56.146 A:middle
to accelerate image processing.

00:10:56.756 --> 00:11:01.496 A:middle
The guys at The Foundry
have also been using Metal

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:56.756 --> 00:11:01.496 A:middle
The guys at The Foundry
have also been using Metal

00:11:01.546 --> 00:11:05.196 A:middle
to accelerate their 3D
modeling application MODO.

00:11:05.826 --> 00:11:10.966 A:middle
And here today to talk about
their experience adopting Metal

00:11:10.966 --> 00:11:13.726 A:middle
in OS X is Jack Greasley
from the The Foundry.

00:11:14.031 --> 00:11:16.031 A:middle
[Applause]

00:11:16.046 --> 00:11:16.426 A:middle
Welcome Jack.

00:11:16.986 --> 00:11:17.386 A:middle
&gt;&gt; JACK GREASLEY: Thank you Rav.

00:11:21.186 --> 00:11:22.816 A:middle
Hi. I'm Jack Greasley.

00:11:22.816 --> 00:11:24.996 A:middle
I'm head of new technology
at The Foundry.

00:11:25.976 --> 00:11:29.426 A:middle
And at The Foundry we create
tools for digital artists.

00:11:30.536 --> 00:11:34.746 A:middle
Our software is used around
the world in games, movies, TV,

00:11:34.746 --> 00:11:38.106 A:middle
and film, including some
photo real Peruvian bears,

00:11:39.686 --> 00:11:40.736 A:middle
mutant monster hunters.

00:11:41.976 --> 00:11:43.306 A:middle
But it's not just
about the virtual.

00:11:44.086 --> 00:11:47.106 A:middle
Some of our design customers
like Adidas actually make things

00:11:48.376 --> 00:11:50.106 A:middle
and if you ask a
designer they'll tell you

00:11:50.726 --> 00:11:56.216 A:middle
that any product is a result of
thousands of little experiments.

00:11:56.216 --> 00:11:57.436 A:middle
We understand this process

00:11:57.436 --> 00:12:02.306 A:middle
and we create our tools
specifically to support it.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:57.436 --> 00:12:02.306 A:middle
and we create our tools
specifically to support it.

00:12:02.576 --> 00:12:06.746 A:middle
MODO is our premier 3D modeling
animation and rendering system.

00:12:06.916 --> 00:12:09.906 A:middle
It is used to make games,
films, product design,

00:12:10.326 --> 00:12:11.336 A:middle
lots of different things.

00:12:12.366 --> 00:12:15.536 A:middle
Our users create stunning
imagery and animations

00:12:15.536 --> 00:12:17.096 A:middle
for things both real
and imaginary.

00:12:17.746 --> 00:12:22.416 A:middle
In our latest version
of MODO 9.01,

00:12:22.506 --> 00:12:24.416 A:middle
we revamped out GPU renderer,

00:12:25.896 --> 00:12:28.866 A:middle
the aim was to provide a
fluid interactive experience

00:12:29.516 --> 00:12:31.576 A:middle
with a highest possible
quality to designers.

00:12:32.676 --> 00:12:35.956 A:middle
The benefit of this is that if
your viewport is realtime you

00:12:35.956 --> 00:12:37.996 A:middle
can make tens of decisions
in the time it would take

00:12:37.996 --> 00:12:39.156 A:middle
to do a single software render.

00:12:39.816 --> 00:12:45.066 A:middle
We had already done some
early work with Metal in iOS,

00:12:45.996 --> 00:12:48.216 A:middle
but a couple of months ago
we got a great opportunity

00:12:48.216 --> 00:12:50.746 A:middle
to start working
with Metal on OS X.

00:12:51.576 --> 00:12:53.776 A:middle
So we put together a small
team and set them a challenge,

00:12:54.396 --> 00:12:56.196 A:middle
we gave them four
weeks to see how much

00:12:56.196 --> 00:12:58.546 A:middle
of the new MODO viewport
they could bring over

00:12:58.546 --> 00:12:59.576 A:middle
and get running on Metal.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:00.566 --> 00:13:03.116 A:middle
And we almost immediately
got some stunning results.

00:13:04.386 --> 00:13:09.086 A:middle
Although it's only
a small triangle,

00:13:09.086 --> 00:13:11.246 A:middle
it actually represents
a huge milestone for us.

00:13:11.986 --> 00:13:13.476 A:middle
Once we did that, we
were able to very,

00:13:13.476 --> 00:13:14.836 A:middle
very quickly make progress.

00:13:15.356 --> 00:13:17.826 A:middle
And our plan of attack was to
really work from the bottom up,

00:13:18.336 --> 00:13:19.786 A:middle
and to start bringing
the functionality

00:13:19.786 --> 00:13:21.466 A:middle
from our new viewport
over onto Metal.

00:13:22.096 --> 00:13:26.726 A:middle
So here on day one we
started with the environment.

00:13:26.726 --> 00:13:28.946 A:middle
We added a few more triangles.

00:13:28.946 --> 00:13:33.756 A:middle
A little bit of shading started

00:13:33.756 --> 00:13:39.646 A:middle
to make this look a little
bit more like a real car.

00:13:39.646 --> 00:13:40.716 A:middle
Putting in the soft shadows

00:13:40.716 --> 00:13:43.416 A:middle
and specular highlights really
added a little bit of bling,

00:13:43.526 --> 00:13:44.516 A:middle
and everybody loves shiny.

00:13:45.136 --> 00:13:48.456 A:middle
And so here we are,
four weeks later,

00:13:48.646 --> 00:13:49.936 A:middle
and you remember
that single triangle?

00:13:49.936 --> 00:13:52.056 A:middle
We got some incredible results.

00:13:52.836 --> 00:13:59.316 A:middle
Putting this all back into Metal
gave us a fully functional view

00:13:59.316 --> 00:14:03.606 A:middle
port running inside of MODO
on Metal in just four weeks.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.316 --> 00:14:03.606 A:middle
port running inside of MODO
on Metal in just four weeks.

00:14:04.206 --> 00:14:06.356 A:middle
One of the great things for us,

00:14:06.536 --> 00:14:09.716 A:middle
is this gives us a standardized
renderer across iOS and OS X,

00:14:11.266 --> 00:14:14.586 A:middle
we created a WYSIWYG workflow
between the two platforms.

00:14:16.736 --> 00:14:18.296 A:middle
So, what did we learn?

00:14:19.356 --> 00:14:21.316 A:middle
The first thing we learned is
that working with Metal is fun.

00:14:22.096 --> 00:14:23.916 A:middle
I've spent 20 years
working with OpenGL,

00:14:23.916 --> 00:14:27.216 A:middle
and I can tell you having a
nice lean easy to use API is

00:14:27.216 --> 00:14:28.276 A:middle
like a breath of fresh air.

00:14:30.196 --> 00:14:33.256 A:middle
Secondly, the debugging
and optimization tools

00:14:33.256 --> 00:14:35.046 A:middle
in Metal are absolutely
fantastic.

00:14:35.726 --> 00:14:38.306 A:middle
As I have said, if you have
done debugging on GPUs,

00:14:38.306 --> 00:14:39.996 A:middle
you know why this is important.

00:14:41.456 --> 00:14:43.216 A:middle
Metal can also be really fast.

00:14:43.726 --> 00:14:46.066 A:middle
In some of our tests, we
got three times speed-up,

00:14:46.346 --> 00:14:49.236 A:middle
and that's using exactly the
same data on the same GPU.

00:14:49.806 --> 00:14:53.426 A:middle
Going forward we have some big
plans from our new viewport

00:14:53.486 --> 00:14:55.846 A:middle
and we're actually looking
to integrate it into all

00:14:55.846 --> 00:14:57.086 A:middle
of our tools across The Foundry,

00:14:57.666 --> 00:14:59.226 A:middle
so hopefully we'll be
seeing the Metal cropping

00:14:59.226 --> 00:15:00.986 A:middle
up in interesting
places very, very soon.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.226 --> 00:15:00.986 A:middle
up in interesting
places very, very soon.

00:15:01.946 --> 00:15:04.246 A:middle
So I'm going to hand you back
to Rav, and thank you very much.

00:15:05.516 --> 00:15:11.206 A:middle
[Applause]

00:15:11.706 --> 00:15:12.206 A:middle
&gt;&gt; RAV DHIRAJ: Thank you Jack.

00:15:12.386 --> 00:15:13.346 A:middle
That was fantastic.

00:15:14.056 --> 00:15:19.776 A:middle
Okay, so I'd like to now
talk about the new features

00:15:19.776 --> 00:15:23.706 A:middle
that we're introducing in
iOS 9 and OS X El Capitan.

00:15:23.706 --> 00:15:26.806 A:middle
And there is a lot of them.

00:15:28.266 --> 00:15:29.396 A:middle
This is a just a selection

00:15:29.396 --> 00:15:31.096 A:middle
of the features we've
added this year.

00:15:32.046 --> 00:15:34.716 A:middle
Now I don't have time to talk
about every single one of these,

00:15:35.096 --> 00:15:36.846 A:middle
so I'm going to focus
on a subset,

00:15:37.446 --> 00:15:41.096 A:middle
including GPU family sets,
our new memory model,

00:15:41.576 --> 00:15:44.886 A:middle
texture barriers, our
expanded texturing support.

00:15:44.886 --> 00:15:48.366 A:middle
Of course, as I mentioned
before, you can learn more

00:15:48.366 --> 00:15:51.546 A:middle
about MetalKit, Metal
Performance Shaders,

00:15:52.036 --> 00:15:54.116 A:middle
and our new Metal
System Trace tool

00:15:54.476 --> 00:15:56.036 A:middle
in the sessions later this week.

00:15:57.586 --> 00:15:59.416 A:middle
So let's dive right into them.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.206 --> 00:16:03.936 A:middle
I would like to start with the
GPU, our Metal feature sets.

00:16:04.736 --> 00:16:08.386 A:middle
Metal defines collections of
features that are specific

00:16:08.506 --> 00:16:10.696 A:middle
to generations of GPU hardware.

00:16:11.316 --> 00:16:14.116 A:middle
Metal calls these GPU families.

00:16:14.926 --> 00:16:21.026 A:middle
So a GPU feature set is defined
by the platform, iOS, or OS X,

00:16:22.016 --> 00:16:24.026 A:middle
the Family Name,
which is specific

00:16:24.026 --> 00:16:28.176 A:middle
to a hardware generation,
and a version that allows us

00:16:28.246 --> 00:16:30.376 A:middle
to augment the feature
set over time.

00:16:31.756 --> 00:16:34.206 A:middle
It's really trivial to
query the feature set,

00:16:35.116 --> 00:16:38.836 A:middle
simply call supportFeatureSet on
your Metal device to determine

00:16:38.836 --> 00:16:40.766 A:middle
if that GPU family is supported.

00:16:41.326 --> 00:16:46.046 A:middle
So here is our iOS
feature set matrix.

00:16:47.296 --> 00:16:49.756 A:middle
Now you'll notice
that we have support

00:16:49.756 --> 00:16:53.736 A:middle
for two major GPU families and
versioning to differentiate

00:16:53.736 --> 00:16:57.586 A:middle
between our iOS 8 and
our iOS 9 features.

00:16:57.586 --> 00:17:04.996 A:middle
On OS X the GPUFamily1 v1
feature set represents the

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:57.586 --> 00:17:04.996 A:middle
On OS X the GPUFamily1 v1
feature set represents the

00:17:04.996 --> 00:17:08.435 A:middle
features that we're going to
be shipping in OS X El Capitan.

00:17:09.076 --> 00:17:11.965 A:middle
This defines the base for
a Metal capable device

00:17:11.965 --> 00:17:12.976 A:middle
on the desktop platform.

00:17:12.976 --> 00:17:17.705 A:middle
Now I would like to talk

00:17:17.925 --> 00:17:21.386 A:middle
about two new shader constant
updates APIs that we're adding.

00:17:21.386 --> 00:17:23.556 A:middle
First a little bit
of background.

00:17:24.496 --> 00:17:26.175 A:middle
So for every draw
that you encode

00:17:26.175 --> 00:17:29.076 A:middle
into command buffer there's
some constant data you need

00:17:29.076 --> 00:17:29.956 A:middle
to send to the shader.

00:17:30.726 --> 00:17:32.856 A:middle
Now it will be incredibly
inefficient for you

00:17:32.856 --> 00:17:35.276 A:middle
to have a separate
constant buffer per draw

00:17:35.686 --> 00:17:38.996 A:middle
so generally most Metal
applications allocate a single

00:17:38.996 --> 00:17:41.596 A:middle
constant buffer that
they have per frame.

00:17:42.806 --> 00:17:45.636 A:middle
They then append the
constant data into the buffer

00:17:45.876 --> 00:17:47.256 A:middle
as they encode their draws.

00:17:48.476 --> 00:17:49.646 A:middle
So what does the code look like?

00:17:51.046 --> 00:17:52.276 A:middle
Well, first we have some setup

00:17:52.276 --> 00:17:53.716 A:middle
for the constant
buffer and the data.

00:17:54.666 --> 00:17:58.996 A:middle
Then just like in that
diagram, within your draw loop,

00:17:59.326 --> 00:18:01.056 A:middle
you send in the new
constant data

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.326 --> 00:18:01.056 A:middle
you send in the new
constant data

00:18:01.056 --> 00:18:03.606 A:middle
or you pen the new constant
data into your constant buffer.

00:18:04.726 --> 00:18:08.416 A:middle
Now it's worth noting that the
setVertexBuffer call here is

00:18:08.486 --> 00:18:10.156 A:middle
actually doing two things.

00:18:11.806 --> 00:18:13.236 A:middle
It's setting the
constant buffer,

00:18:14.166 --> 00:18:16.136 A:middle
and it is updating
the offset in it.

00:18:16.886 --> 00:18:20.746 A:middle
Now, of these two
operations, it's that call

00:18:20.746 --> 00:18:23.486 A:middle
to set the constant buffer
that's the most expensive.

00:18:24.306 --> 00:18:26.286 A:middle
So Metal now has
APIs that allows you

00:18:26.286 --> 00:18:30.346 A:middle
to separate these two operations
and move that expensive call

00:18:30.556 --> 00:18:33.226 A:middle
to set the constant buffer,
or the vertex buffer,

00:18:33.226 --> 00:18:34.606 A:middle
outside of your draw loop.

00:18:35.886 --> 00:18:38.526 A:middle
If you have thousands
of draw calls per frame,

00:18:38.886 --> 00:18:40.366 A:middle
this can be a significant
savings.

00:18:41.046 --> 00:18:45.436 A:middle
But if you only have a small
amount of constant data,

00:18:45.736 --> 00:18:47.466 A:middle
it might be more
efficient for Metal

00:18:47.466 --> 00:18:49.386 A:middle
to manage the constant
buffer for you.

00:18:50.436 --> 00:18:53.116 A:middle
So Metal now has the
setVertexBytes API,

00:18:53.116 --> 00:18:58.606 A:middle
you can use this to append new
constants at every draw call.

00:18:58.736 --> 00:19:03.426 A:middle
Actually there is one more
thing I want to say about that.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.736 --> 00:19:03.426 A:middle
Actually there is one more
thing I want to say about that.

00:19:04.126 --> 00:19:07.716 A:middle
So that API is great if you only
have a small number of constants

00:19:07.716 --> 00:19:10.226 A:middle
as I said, and that's tens
of bytes of constants.

00:19:10.826 --> 00:19:14.316 A:middle
If you have larger constant
sets you really want

00:19:14.316 --> 00:19:17.016 A:middle
to use on of the other APIs.

00:19:17.596 --> 00:19:19.656 A:middle
There's a good chance that
it'll be way more performant.

00:19:20.296 --> 00:19:24.236 A:middle
All right let me talk about
the new memory model now.

00:19:25.556 --> 00:19:28.456 A:middle
So, our goal with the
new memory model was

00:19:28.456 --> 00:19:31.446 A:middle
to support both unified
and discrete memory systems

00:19:31.446 --> 00:19:33.356 A:middle
without you having
to make much change.

00:19:33.966 --> 00:19:35.926 A:middle
Now Metal supports
discrete memory now,

00:19:36.196 --> 00:19:40.256 A:middle
and that's high speed
memory that the GPU

00:19:40.256 --> 00:19:42.156 A:middle
on some desktops have access to.

00:19:42.686 --> 00:19:45.436 A:middle
So the way we've
achieved this is

00:19:45.476 --> 00:19:50.116 A:middle
by introducing new storage
modes that allow you to specify

00:19:50.526 --> 00:19:53.416 A:middle
where the resource
will reside in memory.

00:19:54.346 --> 00:19:58.386 A:middle
So the modes are shared,
private, and managed.

00:19:58.386 --> 00:20:01.486 A:middle
So I'll talk about
each of these in turn

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.386 --> 00:20:01.486 A:middle
So I'll talk about
each of these in turn

00:20:01.576 --> 00:20:02.776 A:middle
over the next few slides.

00:20:03.506 --> 00:20:07.206 A:middle
Let's start by talking about
the shared storage mode.

00:20:07.926 --> 00:20:09.056 A:middle
So this is the mode that's

00:20:09.526 --> 00:20:11.866 A:middle
in the existing implementation
of iOS 8.

00:20:12.696 --> 00:20:15.806 A:middle
So in a unified memory
system, the memory that you use

00:20:15.806 --> 00:20:18.066 A:middle
to store a buffer or a texture,

00:20:18.336 --> 00:20:20.956 A:middle
is shared between
the CPU and the GPU.

00:20:22.296 --> 00:20:24.306 A:middle
There's only one
copy of the memory

00:20:24.756 --> 00:20:27.726 A:middle
and the memory is coherent
at command buffer boundaries.

00:20:28.186 --> 00:20:29.896 A:middle
So this means that you
have to just be done

00:20:29.896 --> 00:20:33.006 A:middle
with the GPU before
accessing it with the CPU.

00:20:33.856 --> 00:20:35.816 A:middle
This makes it very easy to use.

00:20:36.346 --> 00:20:43.256 A:middle
But now new in iOS 9 and in OS X
El Capitan we're introducing the

00:20:43.716 --> 00:20:44.936 A:middle
private storage mode.

00:20:45.706 --> 00:20:49.386 A:middle
So private memory can only
be accessed by the GPU

00:20:49.736 --> 00:20:52.176 A:middle
through render, compute,
or blit operations.

00:20:53.236 --> 00:20:55.896 A:middle
The advantage of private
memory is performance.

00:20:56.676 --> 00:20:59.786 A:middle
Metal can store the data in
a way that's more optimal

00:20:59.786 --> 00:21:04.276 A:middle
for the GPU to access, by
using frame buffer compression

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.786 --> 00:21:04.276 A:middle
for the GPU to access, by
using frame buffer compression

00:21:04.276 --> 00:21:04.926 A:middle
for example.

00:21:07.436 --> 00:21:10.776 A:middle
Private storage mode
also works really well

00:21:10.776 --> 00:21:14.106 A:middle
with discrete memory systems,
and you can put your resources

00:21:14.346 --> 00:21:19.996 A:middle
into the memory that the GPU
has the fastest access to.

00:21:20.496 --> 00:21:22.366 A:middle
And now new in OS X, only,

00:21:22.436 --> 00:21:25.266 A:middle
we're introducing the
managed storage mode.

00:21:25.606 --> 00:21:27.976 A:middle
With managed memory the
resource has storage

00:21:27.976 --> 00:21:31.716 A:middle
in both the discrete memory
and the system memory,

00:21:32.306 --> 00:21:35.296 A:middle
and Metal manages the coherency
between those two copies.

00:21:35.296 --> 00:21:40.246 A:middle
Now this gives you the
convenience and flexibility

00:21:40.296 --> 00:21:44.086 A:middle
of the shared storage mode, and
in most cases, the performance

00:21:44.136 --> 00:21:45.656 A:middle
of the private storage mode.

00:21:46.156 --> 00:21:53.586 A:middle
And if you have a desktop system
with a unified memory system,

00:21:53.586 --> 00:21:54.666 A:middle
you don't have to worry

00:21:54.666 --> 00:21:56.926 A:middle
about managed having
any extra overhead.

00:21:57.256 --> 00:22:00.186 A:middle
There's only one copy of the
resource that Metal maintains.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.256 --> 00:22:00.186 A:middle
There's only one copy of the
resource that Metal maintains.

00:22:00.866 --> 00:22:06.116 A:middle
So there are a couple
other considerations

00:22:06.396 --> 00:22:09.336 A:middle
with managed resources if
you're going to modify the data

00:22:09.336 --> 00:22:10.876 A:middle
with a CPU or the GPU.

00:22:11.666 --> 00:22:15.466 A:middle
So first, if you modifying
the data with a CPU you have

00:22:15.746 --> 00:22:19.016 A:middle
to let Metal know by calling
the buffer didModifyRange

00:22:19.456 --> 00:22:22.146 A:middle
or the texture replaceRegion
APIs.

00:22:23.596 --> 00:22:25.856 A:middle
Likewise, if you want
to read the data back,

00:22:26.136 --> 00:22:29.126 A:middle
you'll need to call the
synchronizeResource API.

00:22:29.996 --> 00:22:33.066 A:middle
It's also worth noting that you
need to wait for the operation

00:22:33.066 --> 00:22:35.196 A:middle
to be complete before you
actually read the data

00:22:35.196 --> 00:22:36.056 A:middle
with the CPU.

00:22:39.436 --> 00:22:42.836 A:middle
So let's look back at that
shader constant update example I

00:22:42.836 --> 00:22:43.586 A:middle
showed earlier.

00:22:44.066 --> 00:22:47.406 A:middle
So this example is
currently using shared memory.

00:22:48.026 --> 00:22:52.706 A:middle
So in a discrete memory system,
you ideally want the constants

00:22:52.756 --> 00:22:54.676 A:middle
to be in discrete memory.

00:22:55.266 --> 00:22:57.796 A:middle
Now you could possibly do
this with a private buffer,

00:22:58.256 --> 00:23:00.806 A:middle
but you'd have to manage
the transfer to that buffer.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.256 --> 00:23:00.806 A:middle
but you'd have to manage
the transfer to that buffer.

00:23:01.706 --> 00:23:05.036 A:middle
It's actually a lot simpler
to use managed buffers,

00:23:05.266 --> 00:23:06.566 A:middle
it makes it really easy.

00:23:06.906 --> 00:23:08.696 A:middle
There is only two
things you need to do.

00:23:09.466 --> 00:23:13.056 A:middle
First, you have to specify
the managed storage mode

00:23:13.146 --> 00:23:16.586 A:middle
when you create the
constant buffer, and then,

00:23:16.936 --> 00:23:20.216 A:middle
you have to call
didModifyRange to tell Metal

00:23:20.216 --> 00:23:23.206 A:middle
that you've now updated
the constants with the CPU.

00:23:23.676 --> 00:23:24.536 A:middle
And that's it.

00:23:24.536 --> 00:23:29.666 A:middle
The rest of the code
remains exactly the same.

00:23:29.886 --> 00:23:31.916 A:middle
It's worth noting that
buffers are shared

00:23:31.916 --> 00:23:33.956 A:middle
by default on all platforms.

00:23:35.306 --> 00:23:38.866 A:middle
On iOS, textures are
shared by default as well,

00:23:39.406 --> 00:23:43.146 A:middle
but on OS X we chose to
make the default mode

00:23:43.146 --> 00:23:45.626 A:middle
for textures managed,
because it allows you

00:23:45.626 --> 00:23:49.116 A:middle
to write portable code without
sacrificing performance.

00:23:49.666 --> 00:23:53.986 A:middle
But there are some cases
where you don't want

00:23:53.986 --> 00:23:55.396 A:middle
to use a managed texture.

00:23:55.886 --> 00:23:56.616 A:middle
This is one of them.

00:23:57.286 --> 00:24:00.006 A:middle
When you have a frame buffer
or a renderable texture,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:57.286 --> 00:24:00.006 A:middle
When you have a frame buffer
or a renderable texture,

00:24:00.306 --> 00:24:02.466 A:middle
then you want to use
the private storage mode

00:24:02.686 --> 00:24:03.936 A:middle
to get the best performance.

00:24:04.516 --> 00:24:05.856 A:middle
This is particularly important

00:24:05.856 --> 00:24:08.416 A:middle
if the GPU is the only
one accessing the data.

00:24:09.006 --> 00:24:13.096 A:middle
And that's our new
memory model in Metal.

00:24:13.356 --> 00:24:15.846 A:middle
I'd like to talk about
two new features in Metal

00:24:15.846 --> 00:24:19.276 A:middle
that are specific to OS X that
I think you'll really like.

00:24:20.266 --> 00:24:21.946 A:middle
The first is layered rendering.

00:24:21.946 --> 00:24:26.976 A:middle
So the intent of this API is
for you to be able to render

00:24:26.976 --> 00:24:29.046 A:middle
to a specific layer of a texture

00:24:29.226 --> 00:24:31.796 A:middle
for every triangle
that you draw.

00:24:32.166 --> 00:24:35.486 A:middle
So this could be the
slice of an array texture,

00:24:35.846 --> 00:24:40.196 A:middle
the plane of a 3D texture, or
the face of a cube texture.

00:24:41.926 --> 00:24:46.356 A:middle
So on a per triangle basis,
you can specify which layer

00:24:46.356 --> 00:24:49.176 A:middle
to render into by simply
specifying the array index

00:24:49.386 --> 00:24:50.386 A:middle
in your vertex shader.

00:24:51.696 --> 00:24:55.156 A:middle
The game Fortnite used this
very technique to render

00:24:55.156 --> 00:24:57.846 A:middle
into the faces of
a cube map for some

00:24:57.846 --> 00:24:59.046 A:middle
of their environmental lighting.

00:24:59.506 --> 00:25:02.136 A:middle
So we think you'll find
this equally useful.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.506 --> 00:25:02.136 A:middle
So we think you'll find
this equally useful.

00:25:04.916 --> 00:25:06.906 A:middle
The second feature
that's specific

00:25:06.906 --> 00:25:10.506 A:middle
to OS X is texture barriers.

00:25:11.816 --> 00:25:14.986 A:middle
So by default GPUs tend
to overlap the execution

00:25:14.986 --> 00:25:18.636 A:middle
of their draw calls, and you
can't reliably use the output

00:25:18.636 --> 00:25:21.796 A:middle
of one draw call in a subsequent
one, without some form

00:25:21.796 --> 00:25:23.396 A:middle
of explicit synchronization.

00:25:24.466 --> 00:25:28.286 A:middle
Metal now has an API that
allows you to insert a barrier

00:25:28.286 --> 00:25:29.526 A:middle
between these draw calls.

00:25:30.086 --> 00:25:32.876 A:middle
So this is critical

00:25:32.876 --> 00:25:36.796 A:middle
for implementing efficient
programmable blending on OS X.

00:25:38.276 --> 00:25:40.486 A:middle
The API is really easy to use.

00:25:40.876 --> 00:25:44.366 A:middle
Simply insert the barrier
between the draw operations

00:25:44.366 --> 00:25:45.486 A:middle
that you want to synchronize.

00:25:46.156 --> 00:25:51.446 A:middle
And last, but certainly
not least, I want to talk

00:25:51.446 --> 00:25:54.836 A:middle
about our expanded texturing
support in Metal this year.

00:25:56.346 --> 00:26:01.506 A:middle
By default the max
limits for all textures

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:56.346 --> 00:26:01.506 A:middle
By default the max
limits for all textures

00:26:01.506 --> 00:26:04.076 A:middle
in iOS have been
increased to 8k.

00:26:04.666 --> 00:26:07.496 A:middle
We've also added cube
array support on OS X,

00:26:08.196 --> 00:26:10.946 A:middle
and bumped up the
quality of anti-aliasing

00:26:10.946 --> 00:26:14.666 A:middle
across the board in
all our platforms.

00:26:14.666 --> 00:26:18.036 A:middle
We've also significantly
flushed out the pixel formats

00:26:18.066 --> 00:26:21.986 A:middle
that you can write to, or
read from, a compute shader.

00:26:25.516 --> 00:26:28.436 A:middle
Also new is a texture
usage property.

00:26:29.456 --> 00:26:31.606 A:middle
So this allows you
to tag textures

00:26:32.066 --> 00:26:36.156 A:middle
to tell Metal how you plan on
using them, and Metal will try

00:26:36.156 --> 00:26:37.766 A:middle
to optimize for that usage.

00:26:38.716 --> 00:26:41.726 A:middle
So for example, if you
have a renderable texture,

00:26:42.016 --> 00:26:45.986 A:middle
you want to set the renderTarget
and shaderRead flags.

00:26:47.116 --> 00:26:49.946 A:middle
And this will tell Metal that
you plan on both rendering

00:26:49.946 --> 00:26:52.946 A:middle
to that texture, and
then sampling from it.

00:26:54.076 --> 00:26:57.676 A:middle
By default, the usage is unknown

00:26:58.006 --> 00:27:00.216 A:middle
and Metal won't make any
assumptions about how

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.006 --> 00:27:00.216 A:middle
and Metal won't make any
assumptions about how

00:27:00.216 --> 00:27:02.206 A:middle
that texture is used,
allowing Metal

00:27:02.206 --> 00:27:06.706 A:middle
to use it anywhere
in the system.

00:27:07.156 --> 00:27:10.486 A:middle
Unlike iOS, the desktop
GPUs prefer

00:27:10.486 --> 00:27:12.736 A:middle
to have a single
depth stencil texture,

00:27:13.956 --> 00:27:17.426 A:middle
so we've added two new
combined depth stencil formats.

00:27:18.266 --> 00:27:21.466 A:middle
The 32-8 format is supported

00:27:21.466 --> 00:27:25.036 A:middle
on all our hardware,
both iOS and OS X.

00:27:25.856 --> 00:27:29.166 A:middle
The 24-8 format, however,
is only supported on some.

00:27:29.816 --> 00:27:31.646 A:middle
So if it means your
precision requirements,

00:27:31.906 --> 00:27:33.236 A:middle
you'll have to check
if it is available.

00:27:33.406 --> 00:27:40.216 A:middle
So let's talk about
texture compression.

00:27:41.206 --> 00:27:44.106 A:middle
So the type of compression
format you use depends

00:27:44.106 --> 00:27:46.516 A:middle
on the device you're
targeting and the type

00:27:46.516 --> 00:27:47.776 A:middle
of data you're encoding.

00:27:48.676 --> 00:27:53.196 A:middle
On iOS we support a number of
these formats including PVRTC,

00:27:53.906 --> 00:28:00.456 A:middle
ETC2, and EAC, and
new for GPUFamily2,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:53.906 --> 00:28:00.456 A:middle
ETC2, and EAC, and
new for GPUFamily2,

00:28:00.526 --> 00:28:02.846 A:middle
we're also supporting ASTC.

00:28:04.196 --> 00:28:09.536 A:middle
So ASTC has a very high quality
compression, better than PVRTC

00:28:09.696 --> 00:28:12.936 A:middle
and ETC at the same
equivalent size.

00:28:14.156 --> 00:28:17.246 A:middle
It also allows you to encode
a number of different formats

00:28:17.826 --> 00:28:21.436 A:middle
from photographic
content, height maps,

00:28:21.856 --> 00:28:23.176 A:middle
normal maps, and many more.

00:28:23.836 --> 00:28:29.136 A:middle
It also provides a very
fine-grinned control

00:28:29.136 --> 00:28:30.536 A:middle
between size and quality,

00:28:30.786 --> 00:28:33.456 A:middle
offering between 1
and 8 bits per pixel.

00:28:34.026 --> 00:28:37.946 A:middle
And at the low end, this is half
the storage required for PVRTC.

00:28:38.796 --> 00:28:44.296 A:middle
And finally, as I previously
noted, this is only available

00:28:44.296 --> 00:28:46.306 A:middle
on GPUFamily2 capable devices,

00:28:46.776 --> 00:28:48.506 A:middle
so you'll have to
look out for that.

00:28:52.016 --> 00:28:55.946 A:middle
Finally, in OS X we're
introducing all the native

00:28:56.056 --> 00:28:59.726 A:middle
texture compression formats
that the desktop GPUs support.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:01.066 --> 00:29:04.326 A:middle
Now, these BCn formats should
all be familiar to you.

00:29:04.986 --> 00:29:08.196 A:middle
If you've worked on a desktop
platform or game console before,

00:29:08.566 --> 00:29:11.876 A:middle
you likely have assets that
are already in this format.

00:29:12.396 --> 00:29:15.386 A:middle
And that's our expanded
texturing support

00:29:16.016 --> 00:29:18.316 A:middle
and the features that
I'm going to cover today.

00:29:18.926 --> 00:29:22.836 A:middle
So I'd like to change
topics and talk

00:29:22.836 --> 00:29:25.386 A:middle
about a new technology
called app thinning.

00:29:25.756 --> 00:29:27.476 A:middle
You might have heard
about it in the last talk.

00:29:28.856 --> 00:29:32.576 A:middle
So this is not specifically a
Metal feature, but it does rely

00:29:32.576 --> 00:29:36.726 A:middle
on the GPU families I discussed
earlier in the session.

00:29:37.946 --> 00:29:42.116 A:middle
First, to set context, the
typical game development

00:29:42.146 --> 00:29:44.266 A:middle
and deployment flow
for a developer

00:29:44.266 --> 00:29:46.346 A:middle
on our platform looks
something like this.

00:29:47.996 --> 00:29:49.486 A:middle
You generally have
an art pipeline

00:29:49.486 --> 00:29:51.576 A:middle
that generates some assets.

00:29:52.296 --> 00:29:56.306 A:middle
The assets are built via Xcode
or your custom tools pipeline

00:29:56.676 --> 00:30:01.276 A:middle
into a binary and then that
binary is sent up somewhere

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:56.676 --> 00:30:01.276 A:middle
into a binary and then that
binary is sent up somewhere

00:30:01.276 --> 00:30:05.026 A:middle
to the App Store,
and that specific

00:30:05.026 --> 00:30:07.576 A:middle
or that very same
binary is deployed

00:30:07.786 --> 00:30:09.906 A:middle
to the devices of
all your users.

00:30:10.546 --> 00:30:11.486 A:middle
So this works great.

00:30:12.636 --> 00:30:15.306 A:middle
But as soon as you start
having assets that are specific

00:30:15.306 --> 00:30:17.076 A:middle
to the capability of a device,

00:30:17.136 --> 00:30:19.616 A:middle
you start running
into some issues.

00:30:22.916 --> 00:30:26.716 A:middle
For example, if you have
assets that are specific

00:30:26.716 --> 00:30:30.966 A:middle
to Metal devices, and assets
specific to legacy devices,

00:30:32.476 --> 00:30:35.006 A:middle
you currently have to
download both versions

00:30:35.096 --> 00:30:36.906 A:middle
to all your users' devices.

00:30:37.566 --> 00:30:40.666 A:middle
So obviously this is not ideal.

00:30:41.336 --> 00:30:46.366 A:middle
App thinning let's you solve
this problem by allowing you

00:30:46.366 --> 00:30:48.996 A:middle
to tag assets by capability

00:30:49.296 --> 00:30:52.746 A:middle
and then only the
asset that's needed

00:30:52.836 --> 00:30:55.536 A:middle
for the device is actually
downloaded to the device.

00:30:57.226 --> 00:30:58.076 A:middle
So how do we do this?

00:30:59.336 --> 00:31:05.856 A:middle
Well, app thinning allows
you to define capability

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.336 --> 00:31:05.856 A:middle
Well, app thinning allows
you to define capability

00:31:05.856 --> 00:31:10.986 A:middle
across two axis, GPUFamily
version and device memory size.

00:31:11.526 --> 00:31:14.166 A:middle
Now this creates a matrix
that you can then use

00:31:14.166 --> 00:31:15.996 A:middle
to target specific devices.

00:31:19.436 --> 00:31:24.256 A:middle
So let's look at a
typical normal map example.

00:31:24.256 --> 00:31:26.976 A:middle
Ideally you want to store
the normal maps compressed,

00:31:27.566 --> 00:31:29.536 A:middle
and EAC is a great
format for that.

00:31:30.776 --> 00:31:33.926 A:middle
But since some legacy devices
don't support compressed

00:31:33.966 --> 00:31:37.006 A:middle
textures or EAC in
particular, you probably want

00:31:37.006 --> 00:31:39.706 A:middle
to have an uncompressed
version of the asset as well.

00:31:40.326 --> 00:31:44.346 A:middle
So app thinning allows
you to tag these assets

00:31:44.746 --> 00:31:49.636 A:middle
and only download the compressed
one to the Metal capable device,

00:31:49.636 --> 00:31:53.146 A:middle
and the uncompressed
version to the legacy device.

00:31:53.936 --> 00:31:56.226 A:middle
But app thinning is actually
a lot more capable than this.

00:31:56.556 --> 00:31:57.866 A:middle
So let's extend our example.

00:31:58.596 --> 00:32:00.796 A:middle
And that's support
for more devices.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.596 --> 00:32:00.796 A:middle
And that's support
for more devices.

00:32:00.996 --> 00:32:03.436 A:middle
So in this particular case we're
going to create five assets.

00:32:04.426 --> 00:32:07.916 A:middle
We'll start with a high
resolution ASTC version

00:32:08.486 --> 00:32:11.276 A:middle
for our most capable 2GB device.

00:32:11.276 --> 00:32:14.226 A:middle
And then we'll include a
slightly lower resolution

00:32:14.226 --> 00:32:17.226 A:middle
for the 1GB version
of that device.

00:32:17.776 --> 00:32:20.906 A:middle
And since some Metal capable
devices don't support ASTC,

00:32:20.966 --> 00:32:23.716 A:middle
we'll include the
EAC version as well.

00:32:23.716 --> 00:32:27.046 A:middle
And then, for your
legacy devices,

00:32:27.246 --> 00:32:29.696 A:middle
we have the uncompressed
version of the asset.

00:32:30.086 --> 00:32:32.636 A:middle
And we can extend this
example even further

00:32:33.156 --> 00:32:35.726 A:middle
by including a lower
resolution version

00:32:35.816 --> 00:32:39.366 A:middle
of that uncompressed asset
for our least capable device,

00:32:39.456 --> 00:32:41.746 A:middle
the 512MB configuration.

00:32:41.746 --> 00:32:45.336 A:middle
So you probably don't
want to create five assets

00:32:45.336 --> 00:32:47.596 A:middle
of everything, but the point
I'm trying to make here is

00:32:47.636 --> 00:32:50.326 A:middle
that you have tremendous
amount of flexibility

00:32:50.696 --> 00:32:52.636 A:middle
to target specific devices

00:32:52.636 --> 00:32:55.376 A:middle
and create the best experience
possible for your users.

00:32:55.946 --> 00:33:01.106 A:middle
So Xcode integrates a great
new UI that allows you

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:55.946 --> 00:33:01.106 A:middle
So Xcode integrates a great
new UI that allows you

00:33:01.106 --> 00:33:02.716 A:middle
to tag assets in this way.

00:33:04.226 --> 00:33:06.946 A:middle
The first thing you need to
do, is define the capabilities

00:33:07.066 --> 00:33:08.916 A:middle
of the devices that
you'd like to target.

00:33:09.426 --> 00:33:13.626 A:middle
That creates that little
matrix, and then all you have

00:33:13.656 --> 00:33:18.386 A:middle
to do is drop in the assets that
match the relevant intersection

00:33:18.386 --> 00:33:21.056 A:middle
of GPUFamily and
device memory size

00:33:21.056 --> 00:33:22.206 A:middle
that you're trying to target.

00:33:23.426 --> 00:33:24.966 A:middle
It's that simple.

00:33:25.526 --> 00:33:27.856 A:middle
But of course, we realize

00:33:27.856 --> 00:33:31.406 A:middle
that not all developers have
tools pipelines that exist

00:33:31.406 --> 00:33:34.066 A:middle
in Xcode, so we have you
covered there as well.

00:33:34.886 --> 00:33:37.706 A:middle
We're supporting with app
thinning the JSON file format

00:33:38.006 --> 00:33:41.396 A:middle
that lets you specify
your asset catalogues.

00:33:42.486 --> 00:33:46.566 A:middle
So just like in Xcode, you have
to specify the GPUFamily version

00:33:47.166 --> 00:33:50.316 A:middle
and the device size
for each asset you want

00:33:50.316 --> 00:33:51.376 A:middle
to include in your catalog.

00:33:54.756 --> 00:33:57.416 A:middle
So once you have your
asset catalogs defined,

00:33:58.176 --> 00:34:02.136 A:middle
how do you retrieve
the data at runtime?

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:58.176 --> 00:34:02.136 A:middle
how do you retrieve
the data at runtime?

00:34:02.136 --> 00:34:04.576 A:middle
The answer is the
NSDataAsset class,

00:34:05.226 --> 00:34:08.755 A:middle
it provides the resource
matched to the capabilities

00:34:08.755 --> 00:34:10.446 A:middle
of the device that
you're running on.

00:34:11.846 --> 00:34:14.746 A:middle
Using the NSDataAsset
is really easy.

00:34:16.196 --> 00:34:21.436 A:middle
Simply allocate an NSDataAsset
object using the name

00:34:21.436 --> 00:34:23.416 A:middle
that you assigned in
your asset catalog,

00:34:23.505 --> 00:34:25.065 A:middle
and then use it in your data.

00:34:25.065 --> 00:34:29.146 A:middle
So let's tie this
altogether using the diagram

00:34:29.146 --> 00:34:31.565 A:middle
that I originally showed
and the normal map example.

00:34:31.636 --> 00:34:35.886 A:middle
So in this case, your
artist will create a bunch

00:34:35.886 --> 00:34:38.275 A:middle
of normal maps, some
compressed, some uncompressed

00:34:38.275 --> 00:34:39.656 A:middle
to target the devices
you'd like.

00:34:40.246 --> 00:34:44.636 A:middle
This gets built via Xcode or
your custom tools pipeline

00:34:44.636 --> 00:34:47.496 A:middle
into your binary, big massive
binary with lots of assets

00:34:47.496 --> 00:34:50.036 A:middle
in it, gets uploaded
to the App Store,

00:34:51.076 --> 00:34:55.016 A:middle
and then the great thing is
only the normal map required

00:34:55.016 --> 00:34:57.556 A:middle
by your user, is
downloaded to their device.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:04.116 --> 00:35:05.736 A:middle
And that's app thinning.

00:35:06.916 --> 00:35:10.846 A:middle
We think that this is going
to change the way you create

00:35:10.846 --> 00:35:14.056 A:middle
and deploy content on
Metal capable devices.

00:35:14.766 --> 00:35:20.186 A:middle
So that was a whirlwind
tour of the Metal ecosystem

00:35:20.186 --> 00:35:21.656 A:middle
over the last 12 months.

00:35:22.706 --> 00:35:25.666 A:middle
We've seen developers like
you create amazing content

00:35:25.666 --> 00:35:26.216 A:middle
using Metal.

00:35:27.186 --> 00:35:29.606 A:middle
We have brought Metal to OS X.

00:35:29.606 --> 00:35:33.126 A:middle
We've also brought all our
great Metal GPU tools to OS X.

00:35:34.786 --> 00:35:36.526 A:middle
We've introduced some
powerful new APIs

00:35:36.526 --> 00:35:38.596 A:middle
that we think you're
going to love.

00:35:39.896 --> 00:35:42.856 A:middle
Finally, we also talked about
how Metal integrates well

00:35:42.856 --> 00:35:45.256 A:middle
with a system, by talking
about app thinning.

00:35:46.706 --> 00:35:48.626 A:middle
All in all, it's
been a great year,

00:35:49.026 --> 00:35:51.216 A:middle
and we're really looking forward
to seeing what you're going

00:35:51.216 --> 00:35:56.616 A:middle
to be able to build with
Metal over the next one.

00:35:56.826 --> 00:36:01.956 A:middle
So please visit our online
documentation, and you'd also

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:56.826 --> 00:36:01.956 A:middle
So please visit our online
documentation, and you'd also

00:36:01.956 --> 00:36:03.376 A:middle
like to go to our
support forums,

00:36:03.616 --> 00:36:06.716 A:middle
and if those don't answer your
questions, you're of course free

00:36:06.716 --> 00:36:09.056 A:middle
to reach out to Allan
Schaffer our Game

00:36:09.056 --> 00:36:10.326 A:middle
Technologies Evangelist.

00:36:11.976 --> 00:36:16.576 A:middle
We have two more sessions this
week, What's New in Metal,

00:36:16.626 --> 00:36:18.346 A:middle
Part 2 on Thursday morning,

00:36:18.906 --> 00:36:21.736 A:middle
and Metal Performance
Optimization Techniques,

00:36:22.126 --> 00:36:23.056 A:middle
which is on Friday.

00:36:23.486 --> 00:36:24.816 A:middle
Please be sure to visit those.

00:36:25.686 --> 00:36:26.426 A:middle
Thank you very much.

00:36:27.516 --> 00:36:30.500 A:middle
[Applause]

